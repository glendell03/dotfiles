{"id":"4ce55dc2-9b1f-4b0b-9451-8bb6a6e5a9bc","zed":"context","version":"0.4.0","text":"\nDO NOT GIVE ME HIGH-LEVEL THEORY. IF I ASK FOR A FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT \"Here's how you can blablabla\"\n\nBe casual unless otherwise specified\nBe terse and concise\nSuggest solutions that I didn’t think about—anticipate my needs\nTreat me as an expert\nBe accurate and thorough\nGive the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer\nValue good arguments over authorities, the source is irrelevant\nConsider new technologies and contrarian ideas, not just conventional wisdom\nYou may use high levels of speculation or prediction, just flag it for me\nNo moral lectures\nDiscuss safety only when it's crucial and non-obvious\nIf your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward\nCite sources whenever possible at the end, not inline\nNo need to mention your knowledge cutoff\nNo need to disclose you're an AI\nPlease respect my prettier preferences when you provide code\nSplit into multiple responses if one response isn't enough to answer the question\nFocus on readability over being performant\nFully implement all requested functionality\nLeave NO todos, placeholders, or missing pieces\n\n\n```ts carsu/packages/api/src/services/workManagement/WorkManagementService.ts:1044-1044\n// Excerpt from: class WorkManagementService > public async getAllEstimates( )\n[input?.filters?.status !== \"100\" ? ...result : [], ...appointmentResults].sort((a, b) => {\n```\ncan you please fix this  if the status is 100 please remove the result data and only return the appointment results\nHere's the fixed code:\n\n```ts\nconst combinedResults = input?.filters?.status === \"100\" \n  ? appointmentResults \n  : [...result, ...appointmentResults];\n\ncombinedResults.sort((a, b) => {\n```\n\nThis cleanly separates the logic - if status is \"100\", only use appointmentResults, otherwise combine both arrays. The sort can then be applied to the combined results.\nconst combinedResults = input?.filters?.status?.includes(100)\n      ? appointmentResults\n      : [...result, ...appointmentResults];\nthe status is an array of statuses so in the frontend the user can select multiple statuses to filter by. this logic is working when the status is only 100 but how about when multiple statuses are selected and also include the 100 status?\nIf you want to include appointmentResults only when 100 is the only selected status, modify like this:\n\n```ts\nconst combinedResults = input?.filters?.status?.length === 1 && input?.filters?.status?.includes(100)\n  ? appointmentResults\n  : [...result, ...appointmentResults];\n```\n\nOr if you want to include both results whenever multiple statuses are selected (even if 100 is one of them):\n\n```ts\nconst combinedResults = input?.filters?.status?.length === 1 && input?.filters?.status?.includes(100)\n  ? appointmentResults\n  : [...result, ...appointmentResults];\n```\n\nLet me know which behavior you need and I can provide the exact logic.\nconst combinedResults =\n      input?.filters?.status?.length === 1 &&\n      input?.filters?.status?.includes(100)\n        ? appointmentResults\n        : [...result, ...appointmentResults];\n```ts carsu/packages/api/src/services/workManagement/WorkManagementService.ts\nimport type { IQuickShareEmail } from \"@common/interfaces\";\nimport {\n  convertTimeDateTo12HourFormat,\n  generateTimeButtonsArray,\n  generateTimeRangeButtons,\n} from \"@common/utils/timeButton\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  addDays,\n  addHours,\n  endOfWeek,\n  isWithinInterval,\n  startOfWeek,\n} from \"date-fns\";\nimport { format, fromZonedTime } from \"date-fns-tz\";\nimport {\n  and,\n  between,\n  eq,\n  gt,\n  gte,\n  is,\n  isNull,\n  lt,\n  not,\n  notNotNull,\n  sql,\n} from \"drizzle-orm\";\nimport type { z } from \"zod\";\n\nimport type { Database } from \"@carsu/db\";\nimport { db, schema } from \"@carsu/db\";\nimport { getQuickShareEmailContactFilter } from \"@carsu/db/utils/filters\";\nimport type {\n  CheckQuickShareLinkDto,\n  CreateAppointmentDto,\n  CreateAppointmentSlotsDto,\n  DeprecatedWorkCardCreateRequest,\n  EstimateCreateRequest,\n  EstimateGetAllSchema,\n  QuickShareEmailDto,\n  WorkCardCreateRequest,\n  WorkCardUpdateRequest,\n} from \"@carsu/types/api\";\nimport {\n  BuiltInEstimateStatus,\n  BuiltInWorkCardStatus,\n  dayNumberToDayOfWeek,\n  DayOfWeek,\n} from \"@carsu/types/constants\";\nimport type {\n  CannedJobFilter,\n  EstimateCreateServiceGroupWithInclude,\n  EstimateServiceGroupUpdateWithInclude,\n  ShareContact,\n  Shop,\n} from \"@carsu/types/db\";\nimport { EstimateSchema, WorkCardSchema } from \"@carsu/types/frontend\";\nimport type { BoardView, Day, Estimate, WorkCard } from \"@carsu/types/frontend\";\n\nimport { env } from \"../../env.mjs\";\nimport type CallContext from \"../CallContext\";\nimport type CustomerService from \"../CustomerService\";\nimport quickShare from \"../emailTemplates/quickShare/services\";\nimport type RandomUtils from \"../RandomUtils\";\nimport type ShopCallContext from \"../ShopCallContext\";\nimport { filterUndefinedFields } from \"../utils\";\nimport type VehicleDAO from \"../VehicleDAO\";\nimport type VehicleService from \"../VehicleService\";\nimport type CannedJobDAO from \"./CannedJobDAO\";\nimport type EstimateDAO from \"./EstimateDAO\";\nimport type { CardResult } from \"./internalTypes\";\nimport type WorkCardDAO from \"./WorkCardDAO\";\n\nexport default class WorkManagementService {\n  private static PUBLIC_ID_LENGTH = 64;\n\n  #workCardDAO: WorkCardDAO;\n  #vehicleDAO: VehicleDAO;\n  #estimateDAO: EstimateDAO;\n  #customerService: CustomerService;\n  #vehicleService: VehicleService;\n  #randomUtils: RandomUtils;\n  #cannedJobDAO: CannedJobDAO;\n\n  constructor(\n    workCardDAO: WorkCardDAO,\n    vehicleDAO: VehicleDAO,\n    estimateDAO: EstimateDAO,\n    vehicleService: VehicleService,\n    customerService: CustomerService,\n    randomUtils: RandomUtils,\n    cannedJobDAO: CannedJobDAO,\n  ) {\n    this.#workCardDAO = workCardDAO;\n    this.#vehicleDAO = vehicleDAO;\n    this.#estimateDAO = estimateDAO;\n    this.#vehicleService = vehicleService;\n    this.#customerService = customerService;\n    this.#randomUtils = randomUtils;\n    this.#cannedJobDAO = cannedJobDAO;\n  }\n\n  private async getExpectedColumn(\n    shopId: string,\n    date: Date,\n  ): Promise<WorkCard[]> {\n    return this.parseCards(\n      // this.#workCardDAO.getByStatusOnDropOffDate({\n      //   shopId,\n      //   status: BuiltInWorkCardStatus.EXPECTED,\n      //   dropOff: date,\n      // }),\n      this.#workCardDAO.getByStatusOnAssignedDate({\n        shopId,\n        status: BuiltInWorkCardStatus.EXPECTED,\n        assignedDate: date,\n      }),\n    );\n  }\n\n  private async getLateExpectedColumn(shopId: string, date: Date) {\n    return this.parseCards(\n      this.#workCardDAO.getByStatusOnAssignedDateLate({\n        shopId,\n        status: BuiltInWorkCardStatus.EXPECTED,\n        assignedDate: date,\n      }),\n    );\n  }\n\n  private async getInHouseColumn(shopId: string): Promise<WorkCard[]> {\n    return this.parseCards(\n      this.#workCardDAO.getByStatus(shopId, BuiltInWorkCardStatus.IN_HOUSE),\n    );\n  }\n\n  private async getInProgressColumn(shopId: string): Promise<WorkCard[]> {\n    return this.parseCards(\n      this.#workCardDAO.getByStatus(shopId, BuiltInWorkCardStatus.IN_PROGRESS),\n    );\n  }\n\n  private async getReadyColumn(shopId: string): Promise<WorkCard[]> {\n    return this.parseCards(\n      this.#workCardDAO.getByStatus(shopId, BuiltInWorkCardStatus.READY),\n    );\n  }\n\n  private async getPickedUpColumn(\n    shopId: string,\n    date: Date,\n  ): Promise<WorkCard[]> {\n    return this.parseCards(\n      this.#workCardDAO.getByStatusOnPickUpDate({\n        shopId,\n        status: BuiltInWorkCardStatus.PICKED_UP,\n        pickUp: date,\n      }),\n    );\n  }\n\n  private async getOnHoldColumn(shopId: string): Promise<WorkCard[]> {\n    return this.parseCards(\n      this.#workCardDAO.getByStatus(shopId, BuiltInWorkCardStatus.ON_HOLD),\n    );\n  }\n\n  public async getBoardView(\n    ctx: ShopCallContext,\n    date: Date,\n  ): Promise<BoardView> {\n    const timer = new Date();\n    const { shopId } = ctx;\n\n    const expectedWorkCards = await this.getExpectedColumn(shopId, date);\n    const inHouseWorkCards = await this.getInHouseColumn(shopId);\n    const inProgressWorkCards = await this.getInProgressColumn(shopId);\n    const readyWorkCards = await this.getReadyColumn(shopId);\n    const pickedUpWorkCards = await this.getPickedUpColumn(shopId, date);\n    const onHoldWorkCards = await this.getOnHoldColumn(shopId);\n    const lateExpectedWorkCards = await this.getLateExpectedColumn(\n      shopId,\n      date,\n    );\n\n    const cardResult: BoardView[\"cards\"] = {\n      [String(BuiltInWorkCardStatus.EXPECTED)]: expectedWorkCards,\n      [String(BuiltInWorkCardStatus.IN_HOUSE)]: inHouseWorkCards,\n      [String(BuiltInWorkCardStatus.IN_PROGRESS)]: inProgressWorkCards,\n      [String(BuiltInWorkCardStatus.READY)]: readyWorkCards,\n      [String(BuiltInWorkCardStatus.PICKED_UP)]: pickedUpWorkCards,\n      [String(BuiltInWorkCardStatus.ON_HOLD)]: onHoldWorkCards,\n    };\n\n    const lateCards = {\n      [String(BuiltInWorkCardStatus.EXPECTED)]: lateExpectedWorkCards,\n    };\n\n    // Create a Set of appointment IDs that are already linked to work cards\n    const linkedAppointmentIds = new Set(\n      expectedWorkCards\n        .filter((item) => item.appointmentId !== null)\n        .map((item) => item.appointmentId),\n    );\n\n    const appointments = await db.query.appointment.findMany({\n      where: and(\n        eq(schema.appointment.shopId, shopId),\n        gte(schema.appointment.date, date),\n      ),\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    cardResult[String(BuiltInWorkCardStatus.EXPECTED)] = [\n      // @ts-expect-error type\n      ...cardResult[String(BuiltInWorkCardStatus.EXPECTED)],\n      ...appointments\n        .filter((appointment) => !linkedAppointmentIds.has(appointment.id))\n        .map((appointment) => ({\n          id: `appointment-${appointment.id}`,\n          title: appointment.title ?? `Appointment with ${appointment.name}`,\n          lastChange: appointment.createdAt,\n          pickUpDate: appointment.endDate,\n          dropOffDate: appointment.date,\n          assignee: appointment.assigneeId,\n          assignedDate: appointment.date,\n          status: BuiltInWorkCardStatus.EXPECTED,\n          position: 0,\n          shopId,\n          customerId: appointment.customerId ?? \"\",\n          vehicleId: \"\",\n          estimateId: \"\",\n          confirmed: false,\n          emailId: null,\n          removed: false,\n          createdAt: appointment.createdAt,\n          updatedAt: appointment.createdAt,\n          comment: appointment.comment ?? undefined,\n        })),\n    ];\n\n    const elapsed = new Date().getTime() - timer.getTime();\n    console.log(\n      `[PROFILING] WorkManagementService.getBoardView ('${shopId}', ${date.toISOString()}) in ${elapsed}ms`,\n    );\n\n    return {\n      cards: cardResult,\n      lateCards,\n    };\n  }\n\n  private convertDayToCardResults = (\n    shopId: string,\n    dateFrom: Date,\n    day: Day,\n    timezone: string,\n  ): CardResult[] => {\n    // If it's a day off, return empty array\n    if (day.day_off === 1) {\n      return [];\n    }\n\n    const cards: CardResult[] = [];\n\n    const createDateWithTime = (timeString: string, day: number) => {\n      // Get the start of the current week (Monday)\n      const weekStart = startOfWeek(addDays(dateFrom, 1), {\n        weekStartsOn: 1,\n      });\n\n      // Add days based on the day parameter (0 = Monday, 1 = Tuesday, etc.)\n      const targetDate = addDays(weekStart, day);\n\n      // Set the time\n      const [hours, minutes] = timeString.split(\":\").map(Number);\n      // Set the time on targetDate\n      targetDate.setHours(hours ?? 0); // This works correctly for 24-hour format\n      targetDate.setMinutes(minutes ?? 0);\n      targetDate.setSeconds(0);\n      targetDate.setMilliseconds(0);\n\n      return fromZonedTime(targetDate, timezone);\n    };\n\n    // // Add working hours card\n    // const workHoursCard: CardResult = {\n    //   id: `work-hours-${day.day}-${crypto.randomUUID()}`,\n    //   title: `Work Hours - ${dayNumberToDayOfWeek[day.day]}`,\n    //   lastChange: day.start\n    //     ? createDateWithTime(day.start, day.day)\n    //     : new Date(),\n    //   pickUpDate: day.start ? createDateWithTime(day.start, day.day) : null,\n    //   dropOffDate: day.finish\n    //     ? createDateWithTime(day.finish, day.day)\n    //     : null,\n    //   assignee: null,\n    //   assignedDate: day.start ? createDateWithTime(day.start, day.day) : null,\n    //   status: 0,\n    //   position: 0,\n    //   shopId: shopId,\n    //   customerId: \"\",\n    //   vehicleId: \"\",\n    //   estimateId: \"\",\n    //   confirmed: false,\n    //   emailId: null,\n    //   removed: false,\n    //   createdAt: day.start\n    //     ? createDateWithTime(day.start, day.day)\n    //     : new Date(),\n    //   updatedAt: day.start\n    //     ? createDateWithTime(day.start, day.day)\n    //     : new Date(),\n    // };\n    // cards.push(workHoursCard);\n\n    // Add opening cards\n    if (day.start) {\n      const openingCard: CardResult = {\n        id: `opening-${day.day}-${crypto.randomUUID()}`,\n        title: `Opening Time - ${dayNumberToDayOfWeek[day.day]}`,\n        lastChange: createDateWithTime(day.start, day.day),\n        pickUpDate: createDateWithTime(day.start, day.day),\n        dropOffDate: createDateWithTime(\"06:00:00\", day.day),\n        assignee: null,\n        assignedDate: createDateWithTime(\"06:00:00\", day.day),\n        status: 0,\n        position: 0,\n        shopId: shopId,\n        customerId: \"\",\n        vehicleId: \"\",\n        estimateId: \"\",\n        confirmed: false,\n        emailId: null,\n        removed: false,\n        createdAt: createDateWithTime(day.start, day.day),\n        updatedAt: createDateWithTime(day.start, day.day),\n      };\n      cards.push(openingCard);\n    }\n\n    if (day.finish) {\n      const closingCard: CardResult = {\n        id: `closing-${day.day}-${crypto.randomUUID()}`,\n        title: `Closing Time - ${dayNumberToDayOfWeek[day.day]}`,\n        lastChange: createDateWithTime(day.finish, day.day),\n        pickUpDate: createDateWithTime(\"20:00:00\", day.day),\n        dropOffDate: createDateWithTime(day.finish, day.day),\n        assignee: null,\n        assignedDate: createDateWithTime(day.finish, day.day),\n        status: 0,\n        position: 0,\n        shopId: shopId,\n        customerId: \"\",\n        vehicleId: \"\",\n        estimateId: \"\",\n        confirmed: false,\n        emailId: null,\n        removed: false,\n        createdAt: createDateWithTime(day.finish, day.day),\n        updatedAt: createDateWithTime(day.finish, day.day),\n      };\n      cards.push(closingCard);\n    }\n\n    // Add break cards\n    day.breaks.forEach((breakTime) => {\n      const breakCard: CardResult = {\n        id: `break-${dateFrom.toISOString()}-${crypto.randomUUID()}`,\n        title: `Break Time - ${dayNumberToDayOfWeek[day.day]}`,\n        lastChange: breakTime.from\n          ? createDateWithTime(breakTime.from, day.day)\n          : new Date(),\n        pickUpDate: breakTime.to\n          ? createDateWithTime(breakTime.to, day.day)\n          : null,\n        dropOffDate: breakTime.from\n          ? createDateWithTime(breakTime.from, day.day)\n          : null,\n        assignee: null,\n        assignedDate: breakTime.from\n          ? createDateWithTime(breakTime.from, day.day)\n          : null,\n        status: 0,\n        position: 0,\n        shopId: shopId,\n        customerId: \"\",\n        vehicleId: \"\",\n        estimateId: \"\",\n        confirmed: false,\n        emailId: null,\n        removed: false,\n        createdAt: breakTime.from\n          ? createDateWithTime(breakTime.from, day.day)\n          : new Date(),\n        updatedAt: breakTime.from\n          ? createDateWithTime(breakTime.from, day.day)\n          : new Date(),\n      };\n      cards.push(breakCard);\n    });\n\n    return cards;\n  };\n\n  public async getWeekViewPublic(\n    shopId: string | undefined,\n    assigneeId: string | undefined,\n    dateFrom: Date,\n    dateTo: Date,\n    timezone: string,\n  ) {\n    if (!shopId) return;\n    const data = await this.#workCardDAO.getAllAssigned(\n      shopId,\n      assigneeId,\n      dateFrom,\n      dateTo,\n    );\n\n    const shop = await db.query.shops.findFirst({\n      where: eq(schema.shops.id, shopId),\n    });\n\n    const workSchedules = shop?.workSchedules;\n\n    // separate the data by day of the week\n    const dataByDayOfWeek: { [key in DayOfWeek]: CardResult[] } = {\n      [DayOfWeek.Monday]: [],\n      [DayOfWeek.Tuesday]: [],\n      [DayOfWeek.Wednesday]: [],\n      [DayOfWeek.Thursday]: [],\n      [DayOfWeek.Friday]: [],\n      [DayOfWeek.Saturday]: [],\n      [DayOfWeek.Sunday]: [],\n    };\n\n    // Convert workSchedules to cards and populate dataByDayOfWeek\n    workSchedules?.forEach((schedule) => {\n      const dayOfWeek = dayNumberToDayOfWeek[schedule.day]! as DayOfWeek;\n      const cards = this.convertDayToCardResults(\n        shopId,\n        dateFrom,\n        schedule,\n        timezone,\n      );\n      dataByDayOfWeek[dayOfWeek].push(...cards);\n    });\n\n    data.forEach((item) => {\n      if (!item.assignedDate) return;\n      const dayOfWeek = format(item.assignedDate, \"EEEE\") as DayOfWeek;\n\n      if (!dataByDayOfWeek[dayOfWeek]) {\n        dataByDayOfWeek[dayOfWeek] = [];\n      }\n\n      dataByDayOfWeek[dayOfWeek].push(item);\n    });\n\n    return dataByDayOfWeek;\n  }\n\n  public async getWeekView(\n    ctx: ShopCallContext,\n    assigneeId: string | undefined,\n    dateFrom: Date,\n    dateTo: Date,\n    timezone: string,\n    customerId?: string | undefined,\n  ) {\n    const { shopId } = ctx;\n    const data = await this.#workCardDAO.getAllAssigned(\n      shopId,\n      assigneeId,\n      dateFrom,\n      dateTo,\n      customerId,\n    );\n\n    const appointments = await db.query.appointment.findMany({\n      where: and(\n        eq(schema.appointment.shopId, shopId),\n        between(schema.appointment.date, dateFrom, dateTo),\n        assigneeId ? eq(schema.appointment.assigneeId, assigneeId) : undefined,\n      ),\n    });\n\n    const shop = await db.query.shops.findFirst({\n      where: eq(schema.shops.id, shopId),\n    });\n\n    const workSchedules = shop?.workSchedules;\n\n    // separate the data by day of the week\n    const dataByDayOfWeek: { [key in DayOfWeek]: CardResult[] } = {\n      [DayOfWeek.Monday]: [],\n      [DayOfWeek.Tuesday]: [],\n      [DayOfWeek.Wednesday]: [],\n      [DayOfWeek.Thursday]: [],\n      [DayOfWeek.Friday]: [],\n      [DayOfWeek.Saturday]: [],\n      [DayOfWeek.Sunday]: [],\n    };\n\n    // Convert workSchedules to cards and populate dataByDayOfWeek\n    workSchedules?.forEach((schedule) => {\n      const dayOfWeek = dayNumberToDayOfWeek[schedule.day]! as DayOfWeek;\n      const cards = this.convertDayToCardResults(\n        shopId,\n        dateFrom,\n        schedule,\n        timezone,\n      );\n      dataByDayOfWeek[dayOfWeek].push(...cards);\n    });\n\n    data.forEach((item) => {\n      if (!item.assignedDate) return;\n      const dayOfWeek = format(item.assignedDate, \"EEEE\") as DayOfWeek;\n\n      if (!dataByDayOfWeek[dayOfWeek]) {\n        dataByDayOfWeek[dayOfWeek] = [];\n      }\n\n      dataByDayOfWeek[dayOfWeek].push(item);\n    });\n\n    // Create a Set of appointment IDs that are already linked to work cards\n    const linkedAppointmentIds = new Set(\n      data\n        .filter((item) => item.appointmentId !== null)\n        .map((item) => item.appointmentId),\n    );\n\n    appointments.forEach((item) => {\n      // Skip if this appointment is already linked to a work card\n      if (!item.date || linkedAppointmentIds.has(item.id)) return;\n\n      const dayOfWeek = format(item.date, \"EEEE\") as DayOfWeek;\n\n      if (!dataByDayOfWeek[dayOfWeek]) {\n        dataByDayOfWeek[dayOfWeek] = [];\n      }\n\n      const [hours, minutes] = item.time.split(\":\").map(Number);\n      const dateWithTime = new Date(item.date);\n      dateWithTime.setHours(hours ?? 0);\n      dateWithTime.setMinutes(minutes ?? 0);\n      dateWithTime.setSeconds(0);\n\n      const isBetween = isWithinInterval(dateWithTime, {\n        start: dateFrom,\n        end: dateTo,\n      });\n\n      if (isBetween) {\n        const card: CardResult = {\n          comment: item.comment ?? undefined,\n          id: `appointment-${item.id}`,\n          title: item.title ?? `Appointment with ${item.name}`,\n          lastChange: fromZonedTime(dateWithTime, timezone),\n          pickUpDate: item.endDate,\n          dropOffDate: fromZonedTime(dateWithTime, timezone),\n          assignee: item.assigneeId,\n          assignedDate: fromZonedTime(dateWithTime, timezone),\n          status: item.assigneeId ? BuiltInWorkCardStatus.EXPECTED : 0,\n          position: 0,\n          shopId: shopId,\n          customerId: item.customerId ?? \"\",\n          vehicleId: \"\",\n          estimateId: \"\",\n          confirmed: false,\n          emailId: null,\n          removed: false,\n          createdAt: item.createdAt,\n          updatedAt: item.createdAt,\n        };\n\n        dataByDayOfWeek[dayOfWeek].push(card);\n      }\n    });\n\n    return dataByDayOfWeek;\n  }\n\n  async parseCards(pendingResult: Promise<CardResult[]>): Promise<WorkCard[]> {\n    const result = await pendingResult;\n    return result.map((card) => WorkCardSchema.parse(card));\n  }\n\n  public async getWorkCardsByStatus(\n    ctx: ShopCallContext,\n    date: Date,\n    status: BuiltInWorkCardStatus,\n  ): Promise<WorkCard[]> {\n    const { shopId } = ctx;\n    switch (status) {\n      case BuiltInWorkCardStatus.EXPECTED:\n        return this.getExpectedColumn(shopId, date);\n      case BuiltInWorkCardStatus.IN_HOUSE:\n        return this.getInHouseColumn(shopId);\n      case BuiltInWorkCardStatus.IN_PROGRESS:\n        return this.getInProgressColumn(shopId);\n      case BuiltInWorkCardStatus.READY:\n        return this.getReadyColumn(shopId);\n      case BuiltInWorkCardStatus.PICKED_UP:\n        return this.getPickedUpColumn(shopId, date);\n      case BuiltInWorkCardStatus.ON_HOLD:\n        return this.getOnHoldColumn(shopId);\n    }\n  }\n\n  public async getWorkCardById(\n    ctx: ShopCallContext,\n    id: string,\n  ): Promise<WorkCard> {\n    const { shopId } = ctx;\n    const data = await this.#workCardDAO.getByIdAndShopId({ id, shopId });\n    return WorkCardSchema.parse(data);\n  }\n\n  public async createWorkCard(\n    ctx: ShopCallContext,\n    data: WorkCardCreateRequest,\n  ): Promise<string> {\n    const { shopId } = ctx;\n    const { estimateId, dropOffDate, pickUpDate, appointmentId } = data;\n    const estimate = await this.#estimateDAO.getBasicEstimate(\n      shopId,\n      estimateId,\n    );\n\n    if (!estimate) {\n      throw new Error(`Couldn't find estimate with id '${estimateId}'`);\n    }\n\n    const appointment = appointmentId\n      ? await db.query.appointment.findFirst({\n          where: eq(schema.appointment.id, appointmentId),\n        })\n      : null;\n\n    const id = await this.#workCardDAO.create({\n      dropOffDate:\n        appointmentId && appointment?.date ? appointment?.date : dropOffDate,\n      pickUpDate:\n        appointmentId && appointment?.endDate\n          ? appointment?.endDate\n          : pickUpDate,\n      estimateId,\n      shopId,\n      customerId: estimate.customerId,\n      vehicleId: estimate.vehicleId,\n      status: BuiltInWorkCardStatus.EXPECTED,\n      lastChange: new Date(),\n      appointmentId: appointmentId ?? null,\n      assignedDate:\n        appointmentId && appointment?.date ? appointment?.date : null,\n    });\n\n    if (id && !appointmentId) {\n      await this.#estimateDAO.update(shopId, estimate.id, {\n        status: BuiltInEstimateStatus.CONCEPT,\n      });\n    } else if (id && appointmentId) {\n      await this.#estimateDAO.update(shopId, estimate.id, {\n        status: BuiltInEstimateStatus.SCHEDULED,\n      });\n    }\n\n    return id;\n  }\n\n  /**\n   * @deprecated We create work cards based on estimates now, use createWorkCard with\n   * an estimateId and the remaining parameters.\n   */\n  public async deprecatedCreateWorkCard(\n    ctx: ShopCallContext,\n    data: DeprecatedWorkCardCreateRequest,\n  ): Promise<string> {\n    const { vehicleId, data: cardData } = data;\n    const customerId = await this.#vehicleDAO.getCustomerId(vehicleId);\n\n    const id = await this.#workCardDAO.create({\n      ...cardData,\n      vehicleId,\n      shopId: ctx.shopId,\n      customerId,\n      lastChange: new Date(),\n    });\n\n    return id;\n  }\n\n  public async changeWorkCardStatus(\n    ctx: ShopCallContext,\n    cardId: string,\n    status: number,\n  ): Promise<void> {\n    const { shopId } = ctx;\n    await this.#workCardDAO.updateStatus({ shopId, cardId, status });\n  }\n\n  public async updateWorkCardPositions(\n    ctx: ShopCallContext,\n    positions: Record<string, number>,\n  ): Promise<void> {\n    const { shopId } = ctx;\n    await this.#workCardDAO.updatePositions({ shopId, positions });\n  }\n\n  public async updateWorkCardPositionsPublic(\n    shopId: string,\n    positions: Record<string, number>,\n  ): Promise<void> {\n    await this.#workCardDAO.updatePositions({ shopId, positions });\n  }\n\n  public async changeWorkCardAssignee(\n    ctx: ShopCallContext,\n    cardId: string,\n    assigneeId: string,\n  ): Promise<void> {\n    const { shopId } = ctx;\n    await this.#workCardDAO.updateAssignee({ shopId, cardId, assigneeId });\n  }\n\n  public async updateWorkCard(\n    ctx: ShopCallContext,\n    req: WorkCardUpdateRequest,\n  ): Promise<void> {\n    const { shopId } = ctx;\n    const { workCardId: cardId, data, estimateStatus } = req;\n    const actualData = filterUndefinedFields(data);\n    await this.#workCardDAO.updateWorkCard(shopId, cardId, actualData);\n    if (data.estimateId) {\n      if (data.assignedDate) {\n        await this.#estimateDAO.update(shopId, data.estimateId, {\n          status: BuiltInEstimateStatus.SCHEDULED,\n        });\n      } else {\n        await this.#estimateDAO.update(shopId, data.estimateId, {\n          status: estimateStatus ?? BuiltInEstimateStatus.CONCEPT,\n        });\n      }\n    }\n  }\n\n  public async updateWorkCardPublic(\n    req: WorkCardUpdateRequest & { shopId: string },\n  ): Promise<void> {\n    const { workCardId: cardId, data, estimateStatus, shopId } = req;\n    const actualData = filterUndefinedFields(data);\n    await this.#workCardDAO.updateWorkCard(shopId, cardId, actualData);\n    if (data.estimateId) {\n      if (data.assignedDate) {\n        await this.#estimateDAO.update(shopId, data.estimateId, {\n          status: BuiltInEstimateStatus.SCHEDULED,\n        });\n      } else {\n        await this.#estimateDAO.update(shopId, data.estimateId, {\n          status: estimateStatus ?? BuiltInEstimateStatus.CONCEPT,\n        });\n      }\n    }\n  }\n\n  public async getAllUnassignedWorkCards(ctx: ShopCallContext) {\n    const { shopId } = ctx;\n\n    const data = this.#workCardDAO.getAllUnassigned(shopId);\n    return this.parseCards(data);\n  }\n\n  public archiveEstimate(\n    ctx: ShopCallContext,\n    estimateId: string,\n  ): Promise<void> {\n    const { shopId } = ctx;\n    return this.#estimateDAO.update(shopId, estimateId, {\n      isArchived: true,\n    });\n  }\n\n  /**\n   * Checks if the given estimate has a public_id associated with it, if not\n   * sets one and returns it. Otherwise the existing public_id is returned.\n   */\n  public async shareEstimate(\n    ctx: ShopCallContext,\n    estimateId: string,\n  ): Promise<string> {\n    const { shopId } = ctx;\n    const estimate = await this.#estimateDAO.getBasicEstimate(\n      shopId,\n      estimateId,\n    );\n    if (!estimate) {\n      throw new Error(`Couldn't find estimate with id '${estimateId}'`);\n    }\n\n    if (estimate.publicId) {\n      return estimate.publicId;\n    }\n\n    const publicId = this.#randomUtils.getRandomString(\n      WorkManagementService.PUBLIC_ID_LENGTH,\n    );\n    await this.#estimateDAO.update(shopId, estimateId, {\n      publicId,\n    });\n\n    return publicId;\n  }\n\n  public async createEstimate(\n    ctx: ShopCallContext,\n    req: EstimateCreateRequest,\n  ): Promise<string> {\n    return this.#estimateDAO.create({\n      ...req,\n      data: {\n        ...req.data,\n        shopId: ctx.shopId,\n      },\n    });\n  }\n\n  public async getEstimateById(\n    ctx: ShopCallContext & CallContext,\n    estimateId: string,\n  ): Promise<Estimate> {\n    const result = await this.#estimateDAO.getByShopAndId(\n      ctx.shopId,\n      estimateId,\n    );\n\n    const vehicleResult = await this.#vehicleService.getById(ctx, [\n      result.vehicleId,\n    ]);\n    const customerResult = await this.#customerService.getById(\n      ctx,\n      ctx.shopId,\n      [result.customerId],\n    );\n\n    const vehicle = vehicleResult.get(result.vehicleId);\n    const customer = customerResult.get(result.customerId);\n\n    return EstimateSchema.parse({\n      ...result,\n      vehicle,\n      customer,\n    });\n  }\n\n  public async getEstimateByPublicId(\n    ctx: CallContext,\n    publicId: string,\n  ): Promise<Estimate> {\n    const baseEstimate = await this.#estimateDAO.getByPublicId(publicId);\n\n    const { customerId, vehicleId, shopId } = baseEstimate;\n    const vehicleResult = await this.#vehicleService.getById(ctx, [vehicleId]);\n\n    const customerResult = await this.#customerService.getById(ctx, shopId, [\n      customerId,\n    ]);\n\n    const vehicle = vehicleResult.get(vehicleId);\n    const customer = customerResult.get(customerId);\n\n    return EstimateSchema.parse({\n      ...baseEstimate,\n      vehicle,\n      customer,\n    });\n  }\n\n  public async getAllEstimates(\n    ctx: ShopCallContext & CallContext,\n    input: z.infer<typeof EstimateGetAllSchema>,\n  ): Promise<Estimate[]> {\n    const { shopId } = ctx;\n    const timer = new Date();\n    const estimateResult = await this.#estimateDAO.getAll(shopId, input);\n    console.log(\n      `[PROFILING] Raw estimates ready after ${\n        new Date().getTime() - timer.getTime()\n      }ms`,\n    );\n\n    // Get workcards for all estimates\n    const allWorkcards = await Promise.all(\n      estimateResult.map((estimate) =>\n        this.#workCardDAO.getWorkCardsByEstimateId(shopId, estimate.id),\n      ),\n    );\n\n    // Flatten the array of workcard arrays and create a Set of appointment IDs\n    const linkedWorkCardAppointmentIds = new Set(\n      allWorkcards\n        .flat()\n        .filter((workcard) => workcard.appointmentId !== null)\n        .map((workcard) => workcard.appointmentId),\n    );\n\n    const customerIds = estimateResult.map((estimate) => estimate.customerId);\n    const vehicleIds = estimateResult.map((estimate) => estimate.vehicleId);\n\n    // Add checks for empty arrays\n    const customers =\n      customerIds.length > 0\n        ? await this.#customerService.getById(ctx, ctx.shopId, customerIds)\n        : new Map();\n\n    const vehicles =\n      vehicleIds.length > 0\n        ? await this.#vehicleService.getById(ctx, vehicleIds)\n        : new Map();\n\n    const result = estimateResult\n      .map((estimate) => {\n        const { vehicleId, customerId } = estimate;\n\n        const customer = customers.get(customerId);\n        const vehicle = vehicles.get(vehicleId);\n\n        if (!customer) {\n          console.error(\n            `Couldn't find customer for estimate '${estimate.id}' (customerId: '${customerId}')`,\n          );\n          return;\n        }\n        if (!vehicle) {\n          console.error(\n            `Couldn't find vehicle for estimate '${estimate.id}' (vehicleId: '${vehicleId}')`,\n          );\n          return;\n        }\n\n        return {\n          ...estimate,\n          customer,\n          vehicle,\n        };\n      })\n      .filter(\n        (possiblyUndefined) => possiblyUndefined !== undefined,\n      ) as Estimate[];\n\n    const appointments = await db.query.appointment.findMany({\n      where: and(\n        eq(schema.appointment.shopId, shopId),\n        between(\n          schema.appointment.date,\n          input?.filters?.between?.from\n            ? new Date(input?.filters?.between?.from)\n            : startOfWeek(new Date(), { weekStartsOn: 1 }),\n          input?.filters?.between?.to\n            ? new Date(input?.filters?.between?.to)\n            : endOfWeek(new Date(), { weekStartsOn: 1 }),\n        ),\n      ),\n    });\n\n    // Get additional customer and vehicle IDs from appointments\n    const appointmentCustomerIds = appointments\n      .map((a) => a.customerId)\n      .filter(Boolean);\n    const appointmentVehicleIds = appointments\n      .map((a) => a.vehicleId)\n      .filter(Boolean);\n\n    // Fetch additional customer and vehicle data\n    const appointmentCustomers =\n      appointmentCustomerIds.length > 0\n        ? await this.#customerService.getById(\n            ctx,\n            ctx.shopId,\n            appointmentCustomerIds,\n          )\n        : new Map();\n\n    const appointmentVehicles =\n      appointmentVehicleIds.length > 0\n        ? await this.#vehicleService.getById(ctx, appointmentVehicleIds)\n        : new Map();\n\n    // Merge with existing maps\n    const allCustomers = new Map([...customers, ...appointmentCustomers]);\n    const allVehicles = new Map([...vehicles, ...appointmentVehicles]);\n\n    const appointmentResults: typeof result = appointments\n      .map((appointment) => {\n        if (linkedWorkCardAppointmentIds.has(appointment.id)) {\n          return null;\n        }\n        const customer = allCustomers.get(appointment.customerId ?? \"\");\n        const vehicle = allVehicles.get(appointment.vehicleId ?? \"\");\n        return {\n          id: `appointment-${appointment.id}`,\n          title: appointment.title ?? `Appointment`,\n          date: appointment.date,\n          customerId: appointment.customerId ?? \"\",\n          vehicleId: appointment.vehicleId ?? \"\",\n          customer,\n          vehicle,\n          type: \"appointment\" as const,\n          status: 0,\n          shopId: shopId,\n          publicId: null,\n          description: appointment.comment ?? \"\",\n          creationDate: appointment.createdAt,\n          discount: 0,\n          expirationDate: appointment.endDate ?? new Date(),\n          kilometers: 0,\n          taxRate: 0,\n          total: 0,\n          totalBeforeTax: 0,\n          totalManHours: 0,\n          isArchived: false,\n          serviceGroups: [],\n        };\n      })\n      .filter((item): item is NonNullable<typeof item> => item !== null);\n\n    const elapsed = new Date().getTime() - timer.getTime();\n    console.log(\n      `[PROFILING] WorkManagementService.getAllEstimates ('${shopId}') in ${elapsed}ms`,\n    );\n\n    const combinedResults =\n      input?.filters?.status?.length === 1 &&\n      input?.filters?.status?.includes(100)\n        ? appointmentResults\n        : [...result, ...appointmentResults];\n\n    return combinedResults.sort((a, b) => {\n      const dateA = new Date(a.creationDate);\n      const dateB = new Date(b.creationDate);\n\n      return input?.filters?.sort === \"desc\"\n        ? dateB.getTime() - dateA.getTime()\n        : dateA.getTime() - dateB.getTime();\n    });\n  }\n\n  public async getAllCannedJob(ctx: ShopCallContext, input: CannedJobFilter) {\n    const { shopId } = ctx;\n\n    const cannedJob = await this.#cannedJobDAO.getAll(shopId, input);\n\n    return cannedJob;\n  }\n\n  public async getCannedJobCategories(ctx: ShopCallContext) {\n    const { shopId } = ctx;\n\n    return await this.#cannedJobDAO.getCannedJobCategories(shopId);\n  }\n\n  public async createCannedJob(\n    ctx: ShopCallContext,\n    data: EstimateCreateServiceGroupWithInclude[],\n    _shopId?: string | undefined,\n  ) {\n    const shopId = ctx.shopId ?? _shopId;\n\n    const serviceGroup = await this.#estimateDAO.createServiceGroup(data);\n\n    const cannedJobId = await this.#cannedJobDAO.create({\n      shopId,\n    });\n\n    await Promise.all(\n      serviceGroup.map(\n        async (s) =>\n          await this.#estimateDAO.updateServiceGroup(shopId, s.id, {\n            cannedJobId,\n          }),\n      ),\n    );\n\n    return cannedJobId;\n  }\n\n  public async updateServiceGroup(\n    ctx: ShopCallContext,\n    data: EstimateServiceGroupUpdateWithInclude,\n  ) {\n    const { shopId } = ctx;\n    const cannedJobs = await this.#cannedJobDAO.getAll(shopId, {});\n    const oldServicesIds = new Set();\n    const newServicesIds = new Set();\n\n    // if (!data.id) throw new Error(\"Data is required\");\n\n    for (const d of data) {\n      const findCannedJob = cannedJobs.find((c) => c.id === d.cannedJobId);\n      findCannedJob?.serviceGroups.forEach((group) => {\n        group.services.forEach((s) => {\n          oldServicesIds.add(s.id);\n        });\n      });\n\n      await this.#estimateDAO.updateServiceGroup(shopId, d.id ?? \"\", d);\n\n      await Promise.all(\n        d.services.map(async (s) => {\n          newServicesIds.add(s.id);\n          await this.#estimateDAO.updateService(shopId, s.id ?? \"\", s);\n        }),\n      );\n    }\n\n    // Remove services\n    for (const service of oldServicesIds) {\n      if (!newServicesIds.has(service)) {\n        await this.#estimateDAO.removeService(shopId, service as string);\n      }\n    }\n    // await Promise.all(\n    //   data.parts.map(\n    //     async (s) => await this.#estimateDAO.updatePart(shopId, s.id ?? \"\", s),\n    //   ),\n    // );\n\n    // return serviceGroup;\n  }\n\n  public async removeCannedJob(ctx: ShopCallContext, id: string) {\n    const { shopId } = ctx;\n\n    return this.#estimateDAO.removeCannedJob(shopId, id);\n  }\n\n  /* eslint-disable */\n  //@ts-ignore\n  public async quickShareByEmail(\n    db: Database,\n    input: QuickShareEmailDto,\n    shopId: string,\n  ): Promise<{ success: boolean; message: string; error?: any; data?: any }> {\n    try {\n      const { quickShareContacts, shops } = schema;\n      const { email, subject, body } = input;\n      const token = crypto.randomUUID();\n      const tokenCreatedAt = new Date();\n      const foundShop = await db\n        .select()\n        .from(shops)\n        .where(eq(shops.id, shopId));\n\n      if (!foundShop.length) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: `Shop with id: ${shopId} not found.`,\n        });\n      }\n      const shop = foundShop?.[0] as Shop | undefined;\n      const { name, email: shopEmail, phoneNumber } = shop!;\n\n      if (!shopEmail) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: ` In shop with id: ${shopId} does not exist email`,\n        });\n      }\n      const shareContact = await db.transaction(\n        async (tx): Promise<ShareContact | undefined> => {\n          let contact;\n          const exist = await tx\n            .select()\n            .from(quickShareContacts)\n            .where(getQuickShareEmailContactFilter(shopId, email));\n          if (exist.length) {\n            contact = (\n              await tx\n                .update(quickShareContacts)\n                .set({\n                  token,\n                  tokenCreatedAt,\n                  usedLink: false,\n                })\n                .where(getQuickShareEmailContactFilter(shopId, email))\n                .returning()\n            )[0];\n          } else {\n            contact = (\n              await tx\n                .insert(quickShareContacts)\n                .values({\n                  email,\n                  phone: \"\",\n                  shopId,\n                  token,\n                  tokenCreatedAt,\n                })\n                .returning()\n            )[0];\n          }\n          return contact;\n        },\n      );\n      const payload: IQuickShareEmail = {\n        email,\n        subject,\n        link: `${env.NEXT_PUBLIC_BASE_URL}/${input.locale}/confirm/appointment?token=${token}&shopId=${shopId}`,\n        body,\n        shop: {\n          name,\n          email: shopEmail,\n          phone: phoneNumber,\n        },\n      } as IQuickShareEmail;\n      return await quickShare(payload);\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        //@ts-ignore\n        message: error.message,\n      });\n    }\n  }\n\n  //@ts-ignore\n  public async checkQuickShareLink(\n    db: Database,\n    input: CheckQuickShareLinkDto,\n  ) {\n    try {\n      const { shopId, token } = input;\n      const { quickShareContacts, appointment } = schema;\n      const existContacts = await db\n        .select()\n        .from(quickShareContacts)\n        .where(\n          and(\n            eq(quickShareContacts.shopId, shopId),\n            eq(quickShareContacts.token, token),\n          ),\n        );\n      // if (!existContacts.length) {\n      //   return {\n      //     error: true,\n      //     message: `Invalid or expired link`,\n      //   };\n      // }\n      const contact = existContacts[0];\n      const { tokenCreatedAt, email, phone, id } = contact!;\n      const tokenAgeInHours = tokenCreatedAt\n        ? (Date.now() - new Date(tokenCreatedAt).getTime()) /\n          (1000 * 60 * 60 * 24)\n        : null;\n      // if (!tokenAgeInHours || tokenAgeInHours > 2) {\n      //   return {\n      //     error: true,\n      //     message: `Expired token`,\n      //   };\n      // }\n      // TODO: open\n      await db\n        .update(quickShareContacts)\n        .set({ token: null, tokenCreatedAt: null, usedLink: true })\n        .where(eq(quickShareContacts.id, id));\n      const findByContactFilter = email\n        ? eq(appointment.email, email)\n        : eq(appointment.phone, phone || \"\");\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      const existAppt = await db\n        .select()\n        .from(appointment)\n        .where(\n          and(\n            eq(appointment.shopId, shopId),\n            findByContactFilter,\n            gt(appointment.date, today),\n          ),\n        );\n      if (existAppt.length) {\n        return { error: true, appt: existAppt[0] };\n      }\n      return { error: false, message: `Appointment does not exist.` };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        //@ts-ignore\n        message: error.message,\n      });\n    }\n  }\n\n  /**\n   * Adjusts the days in the schedule so day 1 becomes Monday, matching JavaScript's getDay().\n   * @param schedules - The array of schedules to adjust.\n   * @returns The adjusted array of schedules.\n   */\n  private adjustScheduleDays(schedules: Day[]): Day[] {\n    return schedules.map((schedule) => {\n      return {\n        ...schedule,\n        day: (schedule.day + 1) % 7,\n      };\n    });\n  }\n\n  public async createAppointmentSlots(\n    db: Database,\n    input: CreateAppointmentSlotsDto,\n  ) {\n    try {\n      const { shopId, date } = input;\n      const { appointment, workCards, shops } = schema;\n      const receivedDate = new Date(date);\n      const startOfDay = new Date(receivedDate.setUTCHours(0, 0, 0, 0));\n      const endOfDay = new Date(receivedDate.setUTCHours(23, 59, 59, 999));\n\n      const appt = await db\n        .select({\n          time: appointment.time,\n          date: appointment.date,\n          endDate: appointment.endDate,\n        })\n        .from(appointment)\n        .where(\n          and(\n            eq(appointment.shopId, shopId),\n            gte(appointment.date, startOfDay),\n            lt(appointment.date, endOfDay),\n          ),\n        );\n      const cards = await db\n        .select({\n          pickUpDate: workCards.pickUpDate,\n          dropOffDate: workCards.dropOffDate,\n        })\n        .from(workCards)\n        .where(\n          and(\n            eq(workCards.shopId, shopId),\n            gte(workCards.dropOffDate, startOfDay),\n            lt(workCards.dropOffDate, endOfDay),\n          ),\n        );\n\n      const [shopSchedule] = await db\n        .select({ workSchedules: shops.workSchedules })\n        .from(shops)\n        .where(eq(shops.id, shopId));\n\n      if (!shopSchedule?.workSchedules) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          //@ts-ignore\n          message: `Check schedule in the shop with id: ${shopId}`,\n        });\n      }\n\n      const [daySchedule] = this.adjustScheduleDays(\n        shopSchedule?.workSchedules!,\n      ).filter((day) => day.day === startOfDay.getDay());\n\n      //@ts-ignore\n      const { start, finish, breaks } = daySchedule;\n\n      const apptTimes = appt.flatMap((appointment) => {\n        const startTime = new Date(appointment?.date ?? new Date());\n        const endTime = appointment.endDate\n          ? new Date(appointment.endDate)\n          : new Date(startTime.getTime() + 60 * 60 * 1000); // Default 1 hour if no endDate\n\n        const times: string[] = [];\n        const currentTime = new Date(startTime);\n\n        while (currentTime <= endTime) {\n          times.push(\n            convertTimeDateTo12HourFormat(format(currentTime, \"HH:mm:ss\")),\n          );\n          // Add 30 minutes\n          currentTime.setMinutes(currentTime.getMinutes() + 30);\n        }\n\n        return times;\n      });\n\n      const cardsTimes = cards.flatMap((wct) => {\n        // Get the earlier and later times\n        const startTime = new Date(\n          Math.min(\n            wct?.dropOffDate?.getTime() ?? 0,\n            wct?.pickUpDate?.getTime() ?? 0,\n          ),\n        );\n        const endTime = new Date(\n          Math.max(\n            wct?.dropOffDate?.getTime() ?? 0,\n            wct?.pickUpDate?.getTime() ?? 0,\n          ),\n        );\n\n        // Generate all time slots between start and end\n        const times: string[] = [];\n        const currentTime = new Date(startTime);\n\n        while (currentTime <= endTime) {\n          times.push(\n            convertTimeDateTo12HourFormat(format(currentTime, \"HH:mm:ss\")),\n          );\n          // Add 30 minutes\n          currentTime.setMinutes(currentTime.getMinutes() + 30);\n        }\n\n        return times;\n      });\n\n      const breakTimes = breaks?.length\n        ? // @ts-expect-error type\n          breaks?.flatMap((br) =>\n            generateTimeRangeButtons(br?.from, br?.to, 30),\n          )\n        : [];\n\n      const busyTimes = Array.from(\n        new Set([...apptTimes, ...cardsTimes, ...breakTimes]),\n      );\n\n      const timeButtonsArr = generateTimeButtonsArray(start, finish);\n\n      const calendarTimeButtons = timeButtonsArr.map((time) => ({\n        time,\n        isAvailable: !busyTimes.includes(time),\n      }));\n\n      return calendarTimeButtons;\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        //@ts-ignore\n        message: error.message,\n      });\n    }\n  }\n  public async createAppointment(db: Database, input: CreateAppointmentDto) {\n    try {\n      const { appointment } = schema;\n      const { date, endDate, timezone } = input;\n      let dateWithTimezone = new Date(date);\n      let endDateWithTimezone = endDate;\n      if (timezone) {\n        dateWithTimezone = fromZonedTime(date, timezone);\n        if (endDate) {\n          endDateWithTimezone = fromZonedTime(endDate, timezone);\n        }\n      }\n\n      //@ts-ignore\n      return await db.transaction(async (tx) => {\n        return (\n          await tx\n            .insert(appointment)\n            .values({\n              ...input,\n              date: new Date(dateWithTimezone),\n              endDate: endDateWithTimezone\n                ? new Date(endDateWithTimezone)\n                : addHours(new Date(dateWithTimezone), 1),\n            })\n            .returning()\n        )[0];\n      });\n    } catch (error) {\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        //@ts-ignore\n        message: error.message,\n      });\n    }\n  }\n\n  public async updateEstimate(\n    ctx: ShopCallContext,\n    req: EstimateCreateRequest & { id: string },\n  ): Promise<void> {\n    const { id, ...updateData } = req;\n\n    // First get all existing service groups for this estimate\n    const existingGroups = await this.#estimateDAO.getServiceGroups(id);\n    const existingServices = existingGroups.flatMap((group) =>\n      group.services.map((service) => service.id),\n    );\n\n    // Create a Set of group IDs that are in the update request\n    const updatedGroupIds = new Set(\n      updateData.serviceGroups.map((group) => group.data.id).filter(Boolean), // Filter out undefined/null IDs\n    );\n\n    const updatedServiceIds = new Set(\n      updateData.serviceGroups.flatMap((group) =>\n        group.services.map((service) => service.id).filter(Boolean),\n      ),\n    );\n\n    // Delete groups that aren't in the update request\n    await Promise.all(\n      existingGroups.map(async (group) => {\n        if (!updatedGroupIds.has(group.id)) {\n          await this.#estimateDAO.removeServiceGroup(ctx.shopId, group.id);\n        }\n        await Promise.all(\n          group.services.map(async (service) => {\n            if (!updatedServiceIds.has(service.id)) {\n              await this.#estimateDAO.removeService(ctx.shopId, service.id);\n            }\n          }),\n        );\n      }),\n    );\n\n    await this.#estimateDAO.update(ctx.shopId, id, {\n      customerId: updateData.data.customerId,\n      vehicleId: updateData.data.vehicleId,\n      discount: updateData.data.discount,\n      taxRate: updateData.data.taxRate,\n      total: updateData.data.total,\n      title: updateData.data.title,\n      totalBeforeTax: updateData.data.totalBeforeTax,\n      totalManHours: updateData.data.totalManHours ?? undefined,\n      description: updateData.data.description,\n      kilometers: updateData.data.kilometers,\n      isArchived: updateData.data.isArchived,\n      publicId: updateData.data.publicId ?? undefined,\n      status: updateData.data.status,\n    });\n\n    // Update or create service groups\n    for (const group of updateData.serviceGroups) {\n      if (group.data.id) {\n        // Update existing service group\n        await this.#estimateDAO.updateServiceGroup(ctx.shopId, group.data.id, {\n          category: group.data.category,\n          description: group.data.description,\n          macroCategory: group.data.macroCategory,\n        });\n\n        await Promise.all(\n          group.services.map(async (service) => {\n            if (service.id) {\n              // Update existing service\n              await this.#estimateDAO.updateService(ctx.shopId, service.id, {\n                description: service.description,\n                price: service.price,\n                manHours: service.manHours,\n                checked: service.checked,\n                total: service.total,\n                position: service.position,\n                internalId: service.internalId,\n              });\n            } else {\n              // Create new service\n              await this.#estimateDAO.createService({\n                serviceGroupId: group.data.id!,\n                description: service.description,\n                price: service.price,\n                manHours: service.manHours,\n                checked: service.checked ?? false,\n                total: service.total ?? 0,\n                position: service.position ?? 0,\n                internalId: service.internalId ?? \"\",\n              });\n            }\n          }),\n        );\n      } else {\n        // Create new service group\n        await this.#estimateDAO.createServiceGroup([\n          {\n            estimateId: id,\n            description: group.data.description,\n            category: group.data.category ?? undefined,\n            macroCategory: group.data.macroCategory ?? undefined,\n            services: group.services,\n          },\n        ]);\n      }\n    }\n  }\n}\n```\n\ncurrent logic is working when the only selected status is 100 but how about 100, 101 and 102 for example \nFor multiple statuses including 100, you probably want to always include both results but filter appointments based on status. Here's the fix:\n\n```ts\nconst combinedResults = [...result, ...appointmentResults].filter(item => {\n  // If no status filter, include everything\n  if (!input?.filters?.status?.length) return true;\n  \n  // For appointments (they have type 'appointment')\n  if (item.type === 'appointment') {\n    return input.filters.status.includes(100);\n  }\n  \n  // For regular estimates\n  return input.filters.status.includes(item.status);\n});\n```\n\nThis way:\n- If status 100 is selected among other statuses, appointments will be included\n- Regular estimates will be filtered by their respective statuses\n- Both types of items will appear together when their respective status filters match\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":845}}},{"id":{"replica_id":0,"value":69},"start":1657,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":846}}},{"id":{"replica_id":0,"value":70},"start":2017,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":847}}},{"id":{"replica_id":0,"value":91},"start":2150,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":848}}},{"id":{"replica_id":0,"value":354},"start":2389,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":849}}},{"id":{"replica_id":0,"value":355},"start":3026,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":850}}},{"id":{"replica_id":0,"value":403},"start":3215,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":851}}},{"id":{"replica_id":0,"value":661},"start":51403,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":852}}},{"id":{"replica_id":0,"value":662},"start":52204,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":853}}}],"summary":"Filter Appointments Status Array Fix","slash_command_output_sections":[{"range":{"start":0,"end":1276},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1275},"icon":"Library","label":"General","metadata":null},{"range":{"start":1278,"end":1540},"icon":"TextSnippet","label":"carsu/packages/api/src/services/workManagement/WorkManagementService.ts, Line 1044","metadata":null},{"range":{"start":3215,"end":51296},"icon":"File","label":"carsu/packages/api/src/services/workManagement/WorkManagementService.ts","metadata":{"path":"carsu/packages/api/src/services/workManagement/WorkManagementService.ts"}}]}
{"id":"fc70c828-0e0e-484c-afc6-52be4c3a5617","zed":"context","version":"0.4.0","text":"\nDO NOT GIVE ME HIGH-LEVEL THEORY. IF I ASK FOR A FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT \"Here's how you can blablabla\"\n\nBe casual unless otherwise specified\nBe terse and concise\nSuggest solutions that I didn’t think about—anticipate my needs\nTreat me as an expert\nBe accurate and thorough\nGive the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer\nValue good arguments over authorities, the source is irrelevant\nConsider new technologies and contrarian ideas, not just conventional wisdom\nYou may use high levels of speculation or prediction, just flag it for me\nNo moral lectures\nDiscuss safety only when it's crucial and non-obvious\nIf your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward\nCite sources whenever possible at the end, not inline\nNo need to mention your knowledge cutoff\nNo need to disclose you're an AI\nPlease respect my prettier preferences when you provide code\nSplit into multiple responses if one response isn't enough to answer the question\nFocus on readability over being performant\nFully implement all requested functionality\nLeave NO todos, placeholders, or missing pieces\n\n```prisma dance-book-app/prisma/schema.prisma\n// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider  = \"postgresql\"\n  url       = env(\"DATABASE_URL\")\n  directUrl = env(\"DIRECT_URL\")\n}\n\nmodel Profile {\n  id     String @id @default(uuid()) @db.Uuid\n  authId String @unique @db.Uuid\n\n  // Relationships\n  studioMembers StudioMember[]\n\n  // Timestamps\n  createdAt        DateTime           @default(now()) @db.Timestamp\n  updatedAt        DateTime           @updatedAt @db.Timestamp\n  Booking          Booking[]\n  StudioInvitation StudioInvitation[]\n}\n\nmodel Studio {\n  id          String  @id @default(uuid()) @db.Uuid\n  slug        String  @unique @db.VarChar(100)\n  name        String  @db.VarChar(100)\n  description String? @db.Text\n  address     String  @db.VarChar(255)\n  city        String  @db.VarChar(100)\n  state       String  @db.VarChar(100)\n  postalCode  String  @db.VarChar(20)\n  country     String  @db.Char(2)\n  logo        String? @db.VarChar(255)\n\n  isActive Boolean @default(true)\n\n  openingHours Json? @db.JsonB // Store hours of operation as JSON\n\n  // Relationships\n  members StudioMember[]\n\n  // Timestamps\n  createdAt        DateTime           @default(now()) @db.Timestamp\n  updatedAt        DateTime           @updatedAt @db.Timestamp\n  Schedule         Schedule[]\n  StudioInvitation StudioInvitation[]\n\n  // Indexes\n  @@index([city, country])\n  @@index([isActive])\n  @@index([slug])\n}\n\nenum StudioRole {\n  OWNER\n  ADMIN\n  CHOREOGRAPHER\n  STAFF\n}\n\nmodel StudioMember {\n  id String @id @default(uuid()) @db.Uuid\n\n  // Relationship fields\n  profileId String  @db.Uuid\n  studioId  String  @db.Uuid\n  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)\n  studio    Studio  @relation(fields: [studioId], references: [id], onDelete: Cascade)\n\n  // Role and permissions\n  role StudioRole @default(STAFF)\n\n  choreographerSchedules Schedule[] @relation(\"ChoreographerSchedules\")\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Unique constraint to prevent duplicate memberships\n  @@unique([profileId, studioId])\n  // Indexes for performance\n  @@index([profileId])\n  @@index([studioId])\n  @@index([role])\n}\n\nmodel Schedule {\n  id          String   @id @default(uuid()) @db.Uuid\n  title       String   @db.VarChar(100)\n  description String?  @db.Text\n  startTime   DateTime @db.Timestamp\n  endTime     DateTime @db.Timestamp\n  maxCapacity Int?     @db.Integer\n\n  // Pricing\n  price    Decimal? @db.Decimal(10, 2)\n  currency String?  @db.Char(3) // ISO 4217 currency code\n\n  // Status\n  isActive    Boolean @default(true)\n  isCancelled Boolean @default(false)\n\n  // Location information (room/studio specific)\n  location String? @db.VarChar(100)\n\n  // Relationships\n  studioId        String        @db.Uuid\n  studio          Studio        @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  choreographerId String?       @db.Uuid\n  choreographer   StudioMember? @relation(name: \"ChoreographerSchedules\", fields: [choreographerId], references: [id], onDelete: SetNull)\n\n  // For handling bookings\n  bookings Booking[]\n\n  // Dance style/class type\n  danceStyle String? @db.VarChar(50)\n  level      String? @db.VarChar(50)\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Indexes\n  @@index([studioId])\n  @@index([choreographerId])\n  @@index([startTime])\n  @@index([isActive, isCancelled])\n  @@index([danceStyle])\n}\n\nmodel Booking {\n  id     String        @id @default(uuid()) @db.Uuid\n  status BookingStatus @default(RESERVED)\n  notes  String?       @db.Text\n\n  // Relationships\n  scheduleId String   @db.Uuid\n  schedule   Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)\n  profileId  String   @db.Uuid\n  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)\n\n  // Payment information\n  paymentId String?  @db.Uuid\n  payment   Payment? @relation(fields: [paymentId], references: [id])\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Indexes\n  @@index([scheduleId])\n  @@index([profileId])\n  @@index([status])\n  @@index([createdAt])\n}\n\nenum BookingStatus {\n  RESERVED\n  CONFIRMED\n  CANCELLED\n  ATTENDED\n  NO_SHOW\n}\n\nmodel Payment {\n  id       String        @id @default(uuid()) @db.Uuid\n  amount   Decimal       @db.Decimal(10, 2)\n  currency String        @db.Char(3) // ISO 4217 currency code\n  status   PaymentStatus @default(PENDING)\n\n  // Payment provider details\n  externalId String? @db.VarChar(100) // ID from payment provider\n  provider   String? @db.VarChar(50) // e.g., \"stripe\", \"paypal\"\n\n  // Relationships\n  bookings Booking[]\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Indexes\n  @@index([status])\n  @@index([externalId])\n}\n\nenum PaymentStatus {\n  PENDING\n  COMPLETED\n  FAILED\n  REFUNDED\n}\n\nmodel StudioInvitation {\n  id          String     @id @default(uuid()) @db.Uuid\n  email       String\n  studioId    String     @db.Uuid\n  studio      Studio     @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  role        StudioRole @default(CHOREOGRAPHER)\n  invitedById String     @db.Uuid\n  invitedBy   Profile    @relation(fields: [invitedById], references: [id])\n  status      String     @default(\"PENDING\")\n  createdAt   DateTime   @default(now()) @db.Timestamp\n  expiresAt   DateTime   @db.Timestamp\n\n  @@index([email, studioId])\n  @@index([status])\n}\n```\n\n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographer: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // 1. Create the Supabase server client\n        const supabase = await createClient({ isAdmin: true });\n\n        // 2. Check for existing member with this email at this studio\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          return {\n            email: input.email,\n            status: \"already_invited\",\n          };\n        }\n\n        // Store actionLink value\n        let actionLink: string | undefined;\n\n        // 3. Send invitation via Supabase OTP\n        try {\n          const { data, error } = await supabase.auth.admin.generateLink({\n            type: \"magiclink\",\n            email: input.email,\n            options: {\n              data: {\n                studioId: input.studioId,\n                invitedRole: input.role,\n              },\n              redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}`,\n            },\n          });\n\n          if (error) {\n            throw new TRPCError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to send invitation\",\n              cause: error,\n            });\n          }\n\n          // Extract the action_link from the response\n          if (data?.properties?.action_link) {\n            actionLink = data.properties.action_link;\n          }\n        } catch (authError) {\n          console.error(\"Error sending invitation:\", authError);\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to send invitation email\",\n            cause: authError,\n          });\n        }\n\n        // 4. Store the pending invitation in your database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx.profile.id,\n            expiresAt: expirationDate,\n            status: \"PENDING\", // Explicitly set status\n          },\n        });\n\n        return {\n          email: input.email,\n          status: \"invited\",\n          actionLink, // Include the action link in the response\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to invite choreographer\",\n          cause: error,\n        });\n      }\n    }),\n\n  acceptInvitation: publicProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Find the pending invitation\n        const invitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            studioId: input.studioId,\n            email: input.email,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"No valid invitation found\",\n          });\n        }\n\n        // Check if not expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        const supabase = await createClient();\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: input.studioId,\n              role: invitation.role, // Use role from invitation record\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  listPendingInvitations: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const invitations = await ctx.db.studioInvitation.findMany({\n          where: {\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            invitedBy: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        return invitations;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list invitations\",\n          cause: error,\n        });\n      }\n    }),\n\n  resendInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Get the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: { id: input.invitationId },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found\",\n          });\n        }\n\n        // Check if invitation is still pending\n        if (invitation.status !== \"PENDING\") {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot resend invitation with status: ${invitation.status}`,\n          });\n        }\n\n        // Create Supabase client\n        const supabase = await createClient();\n\n        // Resend invitation\n        const { error } = await supabase.auth.admin.generateLink({\n          type: \"magiclink\",\n          email: invitation.email,\n          options: {\n            data: {\n              studioId: invitation.studioId,\n              invitedRole: invitation.role,\n            },\n            redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${invitation.studioId}&role=${invitation.role}`,\n          },\n        });\n\n        if (error) {\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to resend invitation\",\n            cause: error,\n          });\n        }\n\n        // Update expiration date\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        const updatedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { expiresAt: expirationDate },\n        });\n\n        return {\n          status: \"resent\",\n          invitation: updatedInvitation,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to resend invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  cancelInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        const deletedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: input.invitationId },\n          data: { status: \"CANCELLED\" },\n        });\n\n        return { status: \"cancelled\", invitation: deletedInvitation };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to cancel invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n```ts dance-book-app/src/server/api/routers/studio.ts:775-785\n// Excerpt from: const studioRouter\nconst supabase = await createClient();\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: input.studioId,\n            },\n          },\n        });\n```\ncan we query in the auth schema where table is users and get the user details base on the email\n\nHere's how you can query the Supabase auth.users table by email:\n\n```typescript\n// In the acceptInvitation procedure\nconst supabase = await createClient({ isAdmin: true });\n\n// Find the user by email\nconst { data: userData, error: userError } = await supabase\n  .from('auth.users')\n  .select('id')\n  .eq('email', input.email)\n  .single();\n\nif (userError || !userData) {\n  throw new TRPCError({\n    code: \"NOT_FOUND\",\n    message: \"User account not found for this email address\",\n  });\n}\n\n// Now you have the user's auth ID in userData.id\nconst authUserId = userData.id;\n\n// Find the corresponding profile\nconst profile = await ctx.db.profile.findUnique({\n  where: { authId: authUserId }\n});\n\nif (!profile) {\n  throw new TRPCError({\n    code: \"NOT_FOUND\",\n    message: \"Profile not found for this user\",\n  });\n}\n\n// Now you can use profile.id to check for existing membership\nconst existingMembership = await ctx.db.studioMember.findUnique({\n  where: {\n    profileId_studioId: {\n      profileId: profile.id,\n      studioId: input.studioId,\n    },\n  },\n});\n```\n\nHowever, there's an issue with this approach. You typically can't query `auth.users` directly with the Supabase client - you need to use the admin API for this. \n\nA better approach is to use the Supabase Admin API:\n\n```typescript\n// In the acceptInvitation procedure\nconst supabase = await createClient({ isAdmin: true });\n\n// Get user by email using admin API\nconst { data: userData, error: userError } = await supabase.auth.admin.getUserByEmail(input.email);\n\nif (userError || !userData?.user) {\n  throw new TRPCError({\n    code: \"NOT_FOUND\",\n    message: \"User account not found for this email address\",\n  });\n}\n\n// Now you have the user's auth ID\nconst authUserId = userData.user.id;\n\n// Find the corresponding profile\nconst profile = await ctx.db.profile.findUnique({\n  where: { authId: authUserId }\n});\n\n// Continue with checking membership as before...\n```\n```tsx dance-book-app/src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\nexport function useAuthWithInvites() {\n  const router = useRouter();\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n  const { mutate: acceptInvitation } = api.studio.acceptInvitation.useMutation({\n    onSuccess: (data) => {\n      // Show success message and redirect to the studio\n      toast.success(\"Successfully joined studio!\");\n      router.push(`/studios/${data.membership?.studioId}`);\n    },\n    onError: (error) => {\n      console.error(\"Error accepting invitation:\", error);\n      toast.error(\"Failed to join studio: \" + error.message);\n    },\n  });\n\n  useEffect(() => {\n    // Initial auth check\n    const checkAuth = async () => {\n      const { data } = await supabase.auth.getSession();\n      if (data.session?.user) {\n        setUser({\n          id: data.session.user.id,\n          email: data.session.user.email ?? \"\",\n        });\n      }\n      setLoading(false);\n    };\n\n    void checkAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else {\n        setUser(null);\n      }\n\n      // Handle sign in events with invitation data\n      if (\n        (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\") &&\n        session?.user\n      ) {\n        const userData = session.user.user_metadata;\n\n        // Check if the user has invitation data in their metadata\n        if (userData?.studioId && userData?.invitedRole && userData?.email) {\n          try {\n            // Accept the invitation - this will update the invitation status\n            // and create the studio membership\n            acceptInvitation({\n              studioId: userData.studioId as string,\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n              role: userData.invitedRole,\n              email: userData.email as string,\n            });\n\n            // Clear the invitation data from the user metadata\n            await supabase.auth.updateUser({\n              data: {\n                studioId: null,\n                invitedRole: null,\n              },\n            });\n          } catch (error) {\n            console.error(\"Error processing invitation:\", error);\n          }\n        }\n      }\n\n      setLoading(false);\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [supabase, router, acceptInvitation]);\n\n  return { user, loading };\n}\n```\n\ndance-book-app/src/app/(public)/studio/[slug]\n```tsx dance-book-app/src/app/(public)/studio/[slug]/page.tsx\nimport { Suspense } from \"react\";\nimport { notFound } from \"next/navigation\";\nimport Link from \"next/link\";\nimport Image from \"next/image\";\nimport {\n  Calendar,\n  ArrowRight,\n  MapPin,\n  Clock,\n  Users,\n  Instagram,\n} from \"lucide-react\";\nimport { api, HydrateClient } from \"~/trpc/server\";\nimport { formatAddress } from \"~/lib/format-address\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoSeparator } from \"~/components/ui/neo-separator\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\n\ninterface StudioProfileProps {\n  slug: string;\n}\n\nasync function StudioProfile({ slug }: StudioProfileProps) {\n  const studio = await api.studio.findUnique({ slug });\n\n  if (!studio) {\n    notFound();\n  }\n\n  // Placeholder opening hours - replace with actual data\n  const openingHours = [\n    { day: \"Monday\", hours: \"10:00 AM - 9:00 PM\" },\n    { day: \"Tuesday\", hours: \"10:00 AM - 9:00 PM\" },\n    { day: \"Wednesday\", hours: \"10:00 AM - 9:00 PM\" },\n    { day: \"Thursday\", hours: \"10:00 AM - 9:00 PM\" },\n    { day: \"Friday\", hours: \"10:00 AM - 8:00 PM\" },\n    { day: \"Saturday\", hours: \"9:00 AM - 5:00 PM\" },\n    { day: \"Sunday\", hours: \"Closed\" },\n  ];\n\n  return (\n    <div className=\"mx-auto max-w-7xl px-4 pb-16 pt-8 md:px-8\">\n      {/* Studio Header - Neobrutalism Style */}\n      <NeoCard variant=\"large-interactive\" className=\"mb-8 p-6 md:p-8\">\n        <div className=\"relative z-10 flex flex-col items-start gap-6 md:flex-row md:items-center md:justify-between\">\n          <div className=\"flex flex-col items-start gap-6 md:flex-row md:items-center\">\n            {/* Logo with thick border */}\n            <div className=\"relative\">\n              <div className=\"neo-border relative h-28 w-28 overflow-hidden rounded-xl bg-white transition-all duration-300 dark:bg-zinc-900 sm:h-32 sm:w-32\">\n                {studio.logo ? (\n                  <Image\n                    src={studio.logo}\n                    alt={`${studio.name} logo`}\n                    fill\n                    className=\"object-cover\"\n                  />\n                ) : (\n                  <div className=\"flex h-full w-full items-center justify-center bg-fuchsia-200 dark:bg-fuchsia-800\">\n                    <span className=\"text-4xl font-black text-black dark:text-white\">\n                      {studio.name.charAt(0)}\n                    </span>\n                  </div>\n                )}\n              </div>\n            </div>\n\n            {/* Studio info with bolder typography */}\n            <div className=\"space-y-3\">\n              <div className=\"flex flex-wrap items-center gap-3\">\n                <h1 className=\"neo-title\">{studio.name}</h1>\n              </div>\n              <p className=\"max-w-lg text-lg font-medium text-zinc-700 dark:text-zinc-300\">\n                {studio.description ?? \"Welcome to our dance studio!\"}\n              </p>\n\n              {/* Location info with bold icon */}\n              {studio.city && (\n                <div className=\"mt-2 flex items-center gap-2 text-base font-medium text-zinc-600 dark:text-zinc-400\">\n                  <MapPin className=\"h-5 w-5\" strokeWidth={2.5} />\n                  <span>{formatAddress(studio)}</span>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </NeoCard>\n\n      {/* Two Column Layout for Details */}\n      <div className=\"mb-8 grid grid-cols-1 gap-6 md:grid-cols-2\">\n        {/* Opening Hours Card */}\n        <NeoCard>\n          <div className=\"mb-4 flex items-center gap-2\">\n            <Clock className=\"h-6 w-6\" strokeWidth={2.5} />\n            <h2 className=\"text-xl font-bold\">Opening Hours</h2>\n          </div>\n          <NeoSeparator className=\"mb-4\" />\n          <div className=\"space-y-2\">\n            {openingHours.map((item) => (\n              <div key={item.day} className=\"flex justify-between font-medium\">\n                <span className=\"font-bold\">{item.day}</span>\n                <span\n                  className={\n                    item.hours === \"Closed\" ? \"font-bold text-red-500\" : \"\"\n                  }\n                >\n                  {item.hours}\n                </span>\n              </div>\n            ))}\n          </div>\n        </NeoCard>\n\n        {/* Choreographers Teaser */}\n        <NeoCard\n          variant=\"colored\"\n          colorClassName=\"bg-fuchsia-100 dark:bg-fuchsia-950\"\n        >\n          <div className=\"mb-4 flex items-center gap-2\">\n            <Users className=\"h-6 w-6\" strokeWidth={2.5} />\n            <h2 className=\"text-xl font-bold\">Our Choreographers</h2>\n          </div>\n          <NeoSeparator className=\"mb-4\" />\n\n          <div className=\"flex -space-x-4\">\n            {[1, 2, 3, 4].map((i) => (\n              <div\n                key={i}\n                className=\"neo-border relative h-16 w-16 overflow-hidden rounded-full bg-white dark:bg-zinc-900\"\n              >\n                <div className=\"flex h-full w-full items-center justify-center bg-violet-300 dark:bg-violet-700\">\n                  <span className=\"font-bold\">C{i}</span>\n                </div>\n              </div>\n            ))}\n            <div className=\"neo-border flex h-16 w-16 items-center justify-center rounded-full bg-yellow-300 font-bold text-black\">\n              +5\n            </div>\n          </div>\n\n          <Link href={`/studio/${slug}/choreographers`}>\n            <NeoButton variant=\"outline\" className=\"mt-4 w-full bg-white\">\n              Meet The Team\n            </NeoButton>\n          </Link>\n        </NeoCard>\n      </div>\n\n      {/* Social Media Section */}\n      <NeoCard className=\"mb-10\">\n        <h2 className=\"mb-4 text-xl font-bold\">Connect With Us</h2>\n        <div className=\"flex gap-3\">\n          <a href=\"#\" className=\"neo-icon-container bg-pink-400\">\n            <Instagram className=\"h-6 w-6\" />\n          </a>\n          {/* Add other social icons as needed */}\n        </div>\n      </NeoCard>\n\n      {/* Call-to-action Button - Big and Bold */}\n      <div className=\"mt-10\">\n        <Link href={`/studio/${slug}/schedules`}>\n          <NeoButton variant=\"lg\" className=\"w-full\">\n            <span className=\"flex items-center justify-center gap-3\">\n              <Calendar className=\"h-6 w-6\" strokeWidth={2.5} />\n              <span>BOOK A DANCE CLASS</span>\n              <ArrowRight\n                className=\"h-6 w-6 transition-transform duration-300 group-hover:translate-x-2\"\n                strokeWidth={2.5}\n              />\n            </span>\n          </NeoButton>\n        </Link>\n      </div>\n    </div>\n  );\n}\n\nfunction StudioProfileSkeleton() {\n  return (\n    <div className=\"mx-auto max-w-7xl px-4 pb-20 pt-12 md:px-8\">\n      {/* Header Skeleton */}\n      <div className=\"neo-border-thick mb-12 rounded-xl bg-neutral-200 p-6 shadow-neo-lg dark:bg-neutral-800\">\n        <div className=\"flex flex-col items-start gap-6 md:flex-row md:items-center\">\n          <div className=\"flex items-center gap-5\">\n            <div className=\"neo-border h-28 w-28 animate-pulse rounded-xl bg-neutral-200 dark:bg-neutral-800 sm:h-32 sm:w-32\" />\n            <div>\n              <div className=\"h-10 w-48 animate-pulse rounded-md bg-neutral-200 dark:bg-neutral-800\" />\n              <div className=\"mt-3 h-5 w-64 animate-pulse rounded-md bg-neutral-200 dark:bg-neutral-800\" />\n              <div className=\"mt-3 h-5 w-40 animate-pulse rounded-md bg-neutral-200 dark:bg-neutral-800\" />\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Two Column Skeleton */}\n      <div className=\"mb-8 grid grid-cols-1 gap-6 md:grid-cols-2\">\n        <div className=\"neo-border h-64 animate-pulse rounded-xl bg-neutral-200 dark:bg-neutral-800\" />\n        <div className=\"neo-border h-64 animate-pulse rounded-xl bg-neutral-200 dark:bg-neutral-800\" />\n      </div>\n\n      {/* Button Skeleton */}\n      <div className=\"neo-border mt-10 h-20 animate-pulse rounded-xl bg-neutral-200 dark:bg-neutral-800\" />\n    </div>\n  );\n}\n\ntype StudioPageProps = {\n  params: Promise<{\n    slug: string;\n  }>;\n};\n\nexport default async function StudioPage({ params }: StudioPageProps) {\n  const { slug } = await params;\n  await api.studio.findUnique.prefetch({ slug });\n\n  return (\n    <main className=\"min-h-screen bg-zinc-50 dark:bg-neutral-950\">\n      <HydrateClient>\n        <Suspense fallback={<StudioProfileSkeleton />}>\n          <StudioProfile slug={slug} />\n        </Suspense>\n      </HydrateClient>\n    </main>\n  );\n}\n```\n\nschedules\n```tsx dance-book-app/src/app/(public)/studio/[slug]/schedules/page.tsx\nimport { Suspense } from \"react\";\nimport { notFound } from \"next/navigation\";\nimport DayContainer from \"~/components/calendar/day-container\";\nimport StudioInfoHeader from \"~/components/studio-info-header\";\nimport { StudioInfoHeaderSkeleton } from \"~/components/studio-info-header/skeleton\";\nimport { DayContainerSkeleton } from \"~/components/calendar/skeleton-day-container-skeleton\";\nimport { api, HydrateClient } from \"~/trpc/server\";\nimport { formatAddress } from \"~/lib/format-address\";\n\n// Define the props type for the Studio content component\ninterface StudioContentProps {\n  slug: string;\n}\n\n// Component to fetch and display studio info\nasync function StudioInfo({ slug }: StudioContentProps) {\n  const studio = await api.studio.findUnique({ slug });\n\n  if (!studio) {\n    notFound();\n  }\n\n  return (\n    <StudioInfoHeader\n      studioData={{\n        name: studio.name,\n        address: formatAddress(studio),\n        phone: \"Not available\",\n        email: \"Not available\",\n        avatarUrl: studio.logo ?? undefined,\n        slug: studio.slug,\n      }}\n    />\n  );\n}\n\ntype StudioPageProps = {\n  params: Promise<{\n    slug: string;\n  }>;\n};\n\nexport default async function StudioPage({ params }: StudioPageProps) {\n  const { slug } = await params;\n\n  // Prefetch the data to improve performance\n  void api.studio.findUnique.prefetch({ slug });\n\n  return (\n    <HydrateClient>\n      <div className=\"flex min-h-screen flex-col bg-zinc-50 dark:bg-neutral-950\">\n        <div>\n          <Suspense fallback={<StudioInfoHeaderSkeleton />}>\n            <StudioInfo slug={slug} />\n          </Suspense>\n        </div>\n        \n        <Suspense fallback={<DayContainerSkeleton />}>\n          <DayContainer />\n        </Suspense>\n      </div>\n    </HydrateClient>\n  );\n}\n```\n\n\nin  the use-auth-with-invites please make sure that the user that is accessing the page is the same user that is in the invitation data\nI added the email in the metadata\nLet's modify the `useAuthWithInvites` hook to validate that the user accessing the page is the same user that was invited. Here's the updated code:\n\n```tsx\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\nexport function useAuthWithInvites() {\n  const router = useRouter();\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n  const { mutate: acceptInvitation } = api.studio.acceptInvitation.useMutation({\n    onSuccess: (data) => {\n      // Show success message and redirect to the studio\n      toast.success(\"Successfully joined studio!\");\n      router.push(`/studios/${data.membership?.studioId}`);\n    },\n    onError: (error) => {\n      console.error(\"Error accepting invitation:\", error);\n      toast.error(\"Failed to join studio: \" + error.message);\n    },\n  });\n\n  useEffect(() => {\n    // Initial auth check\n    const checkAuth = async () => {\n      const { data } = await supabase.auth.getSession();\n      if (data.session?.user) {\n        setUser({\n          id: data.session.user.id,\n          email: data.session.user.email ?? \"\",\n        });\n      }\n      setLoading(false);\n    };\n\n    void checkAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else {\n        setUser(null);\n      }\n\n      // Handle sign in events with invitation data\n      if (\n        (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\") &&\n        session?.user\n      ) {\n        const userData = session.user.user_metadata;\n        const userEmail = session.user.email;\n\n        // Check if the user has invitation data in their metadata\n        if (userData?.studioId && userData?.invitedRole && userData?.email) {\n          // Validate that the logged-in user is the same as the invited user\n          if (userEmail !== userData.email) {\n            toast.error(\n              \"You must sign in with the email address the invitation was sent to.\"\n            );\n            return;\n          }\n\n          try {\n            // Accept the invitation - this will update the invitation status\n            // and create the studio membership\n            acceptInvitation({\n              studioId: userData.studioId as string,\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n              role: userData.invitedRole,\n              email: userData.email as string,\n            });\n\n            // Clear the invitation data from the user metadata\n            await supabase.auth.updateUser({\n              data: {\n                studioId: null,\n                invitedRole: null,\n                email: null, // Also clear the email from metadata\n              },\n            });\n          } catch (error) {\n            console.error(\"Error processing invitation:\", error);\n          }\n        }\n      }\n\n      setLoading(false);\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [supabase, router, acceptInvitation]);\n\n  return { user, loading };\n}\n```\n\nI've made the following changes:\n\n1. Extract the current user's email directly from the session: `const userEmail = session.user.email;`\n\n2. Added validation to ensure the signed-in user's email matches the invited email:\n   ```typescript\n   if (userEmail !== userData.email) {\n     toast.error(\n       \"You must sign in with the email address the invitation was sent to.\"\n     );\n     return;\n   }\n   ```\n\n3. Also clear the email from metadata when we clean up:\n   ```typescript\n   await supabase.auth.updateUser({\n     data: {\n       studioId: null,\n       invitedRole: null,\n       email: null, // Also clear the email from metadata\n     },\n   });\n   ```\n\nThis ensures that only the user who received the invitation can accept it, preventing potential security issues where someone could log in with a different account and accept an invitation intended for someone else.\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processingAuth, setProcessingAuth] = useState(false);\n  const [invitationProcessed, setInvitationProcessed] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle invitation processing\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  useEffect(() => {\n    async function processInvitation() {\n      if (!studioId || !role) {\n        setError(\"Invalid invitation link\");\n        return;\n      }\n\n      try {\n        // Check if user is already authenticated\n        const {\n          data: { session },\n        } = await supabase.auth.getSession();\n\n        if (session?.user) {\n          // User is already logged in, update their metadata with invitation data\n          await supabase.auth.updateUser({\n            data: {\n              studioId,\n              invitedRole: role,\n            },\n          });\n        } else if (token) {\n          // The token will be automatically processed by Supabase Auth\n          // Just wait for the auth state to update\n        }\n      } catch (err) {\n        console.error(\"Error processing invitation:\", err);\n        setError(\"Failed to process invitation\");\n      }\n    }\n\n    if (!invitationProcessed) {\n      processInvitation();\n      setInvitationProcessed(true);\n    }\n  }, [studioId, role, token, supabase, invitationProcessed]);\n\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !role || !user) return;\n\n    try {\n      setProcessingAuth(true);\n\n      // Update user metadata if not already done\n      await supabase.auth.updateUser({\n        data: {\n          studioId,\n          invitedRole: role,\n        },\n      });\n\n      // The auth hook will handle the redirect after this\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\"Failed to accept invitation\");\n      setProcessingAuth(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if ((processingAuth || authLoading) && studioId && role) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render just the invitation information and action buttons\n  return (\n    <>\n      {/* Invitation Info */}\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n\n        {user ? (\n          <p className=\"text-center text-gray-700\">\n            You're signed in as{\" \"}\n            <strong className=\"font-bold\">{user.email}</strong>\n          </p>\n        ) : (\n          <p className=\"text-center text-gray-700\">\n            Sign in to accept this invitation\n          </p>\n        )}\n      </NeoCard>\n\n      {/* Action Button */}\n      {user ? (\n        <NeoButton\n          onClick={handleAcceptInvitation}\n          disabled={processingAuth}\n          className=\"w-full\"\n          size=\"lg\"\n        >\n          {processingAuth ? (\n            <>\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n              Processing...\n            </>\n          ) : (\n            <>Join {studioName}</>\n          )}\n        </NeoButton>\n      ) : (\n        <div className=\"text-center\">\n          <NeoButton\n            onClick={() => {\n              // Redirect to login with return URL\n              const returnUrl = encodeURIComponent(window.location.href);\n              router.push(`/login?returnUrl=${returnUrl}`);\n            }}\n            size=\"lg\"\n            className=\"w-full\"\n          >\n            Sign In\n          </NeoButton>\n        </div>\n      )}\n    </>\n  );\n}\n```\n\n```tsx dance-book-app/src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\nexport function useAuthWithInvites() {\n  const router = useRouter();\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n  const { mutate: acceptInvitation } = api.studio.acceptInvitation.useMutation({\n    onSuccess: (data) => {\n      // Show success message and redirect to the studio\n      toast.success(\"Successfully joined studio!\");\n      router.push(`/studios/${data.membership?.studioId}`);\n    },\n    onError: (error) => {\n      console.error(\"Error accepting invitation:\", error);\n      toast.error(\"Failed to join studio: \" + error.message);\n    },\n  });\n\n  useEffect(() => {\n    // Initial auth check\n    const checkAuth = async () => {\n      const { data } = await supabase.auth.getSession();\n      if (data.session?.user) {\n        setUser({\n          id: data.session.user.id,\n          email: data.session.user.email ?? \"\",\n        });\n      }\n      setLoading(false);\n    };\n\n    void checkAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else {\n        setUser(null);\n      }\n\n      // Handle sign in events with invitation data\n      if (\n        (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\") &&\n        session?.user\n      ) {\n        const userData = session.user.user_metadata;\n        const userEmail = session.user.email;\n\n        // Check if the user has invitation data in their metadata\n        if (userData?.studioId && userData?.invitedRole && userData?.email) {\n          // Validate that the logged-in user is the same as the invited user\n          if (userEmail !== userData.email) {\n            toast.error(\n              \"You must sign in with the email address the invitation was sent to.\",\n            );\n            return;\n          }\n\n          try {\n            // Accept the invitation - this will update the invitation status\n            // and create the studio membership\n            acceptInvitation({\n              studioId: userData.studioId as string,\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n              role: userData.invitedRole,\n              email: userData.email as string,\n            });\n\n            // Clear the invitation data from the user metadata\n            await supabase.auth.updateUser({\n              data: {\n                studioId: null,\n                invitedRole: null,\n                email: null, // Also clear the email from metadata\n              },\n            });\n          } catch (error) {\n            console.error(\"Error processing invitation:\", error);\n          }\n        }\n      }\n\n      setLoading(false);\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [supabase, router, acceptInvitation]);\n\n  return { user, loading };\n}\n```\n\ncan you please doublee check the code is there anything we can improve\nI've reviewed the code and found a few areas for improvement. Here's an updated version with bug fixes and enhancements:\n\n```tsx\n// dance-book-app/src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\nexport function useAuthWithInvites() {\n  const router = useRouter();\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n  const { mutate: acceptInvitation } = api.studio.acceptInvitation.useMutation({\n    onSuccess: (data) => {\n      // Show success message and redirect to the studio\n      toast.success(\"Successfully joined studio!\");\n      // Fix the URL path - should use /studio/[slug] instead of /studios/[id]\n      router.push(`/studio/${data.membership.studio.slug}`);\n    },\n    onError: (error) => {\n      console.error(\"Error accepting invitation:\", error);\n      toast.error(\"Failed to join studio: \" + error.message);\n    },\n  });\n\n  useEffect(() => {\n    let isMounted = true; // Add this to prevent state updates after unmount\n\n    // Initial auth check\n    const checkAuth = async () => {\n      try {\n        const { data } = await supabase.auth.getSession();\n        if (data.session?.user && isMounted) {\n          setUser({\n            id: data.session.user.id,\n            email: data.session.user.email ?? \"\",\n          });\n        }\n      } catch (error) {\n        console.error(\"Auth session check error:\", error);\n      } finally {\n        if (isMounted) setLoading(false);\n      }\n    };\n\n    void checkAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user && isMounted) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else if (isMounted) {\n        setUser(null);\n      }\n\n      // Handle sign in events with invitation data\n      if (\n        (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\") &&\n        session?.user\n      ) {\n        const userData = session.user.user_metadata;\n        const userEmail = session.user.email;\n\n        // Check if the user has invitation data in their metadata\n        if (userData?.studioId && userData?.invitedRole) {\n          // If email in metadata is defined, validate it matches current user\n          if (userData.email && userEmail !== userData.email) {\n            toast.error(\n              \"You must sign in with the email address the invitation was sent to.\"\n            );\n            return;\n          }\n\n          try {\n            // Accept the invitation - this will update the invitation status\n            // and create the studio membership\n            acceptInvitation({\n              studioId: userData.studioId as string,\n              role: userData.invitedRole as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n              email: userEmail ?? userData.email as string,\n            });\n\n            // Clear the invitation data from the user metadata\n            await supabase.auth.updateUser({\n              data: {\n                studioId: null,\n                invitedRole: null,\n                email: null,\n              },\n            });\n          } catch (error) {\n            console.error(\"Error processing invitation:\", error);\n          }\n        }\n      }\n\n      if (isMounted) setLoading(false);\n    });\n\n    return () => {\n      isMounted = false;\n      subscription.unsubscribe();\n    };\n  }, [supabase, router, acceptInvitation]);\n\n  return { user, loading };\n}\n```\n\n```tsx\n// dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processingAuth, setProcessingAuth] = useState(false);\n  const [invitationProcessed, setInvitationProcessed] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle invitation processing\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  useEffect(() => {\n    let isMounted = true;\n\n    async function processInvitation() {\n      if (!studioId || !role) {\n        setError(\"Invalid invitation link\");\n        return;\n      }\n\n      try {\n        // Check if user is already authenticated\n        const {\n          data: { session },\n        } = await supabase.auth.getSession();\n\n        if (session?.user) {\n          // User is already logged in, update their metadata with invitation data\n          // Store their current email in metadata to ensure validation\n          await supabase.auth.updateUser({\n            data: {\n              studioId,\n              invitedRole: role,\n              email: session.user.email,\n            },\n          });\n        } else if (token) {\n          // The token will be automatically processed by Supabase Auth\n          // Just wait for the auth state to update\n          console.log(\"Token present, waiting for auth to process it\");\n        }\n      } catch (err) {\n        console.error(\"Error processing invitation:\", err);\n        if (isMounted) setError(\"Failed to process invitation\");\n      } finally {\n        if (isMounted) setInvitationProcessed(true);\n      }\n    }\n\n    if (!invitationProcessed) {\n      void processInvitation();\n    }\n\n    return () => {\n      isMounted = false;\n    };\n  }, [studioId, role, token, supabase, invitationProcessed]);\n\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !role || !user) return;\n\n    try {\n      setProcessingAuth(true);\n\n      // Update user metadata if not already done\n      await supabase.auth.updateUser({\n        data: {\n          studioId,\n          invitedRole: role,\n          email: user.email, // Store the current email for validation\n        },\n      });\n\n      // Trigger an auth state refresh to ensure the hook processes the metadata update\n      await supabase.auth.refreshSession();\n\n      // The auth hook will handle the redirect after this\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\"Failed to accept invitation\");\n      setProcessingAuth(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if ((processingAuth || authLoading) && studioId && role) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render just the invitation information and action buttons\n  return (\n    <>\n      {/* Invitation Info */}\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n\n        {user ? (\n          <p className=\"text-center text-gray-700\">\n            You're signed in as{\" \"}\n            <strong className=\"font-bold\">{user.email}</strong>\n          </p>\n        ) : (\n          <p className=\"text-center text-gray-700\">\n            Sign in to accept this invitation\n          </p>\n        )}\n      </NeoCard>\n\n      {/* Action Button */}\n      {user ? (\n        <NeoButton\n          onClick={handleAcceptInvitation}\n          disabled={processingAuth}\n          className=\"w-full\"\n          size=\"lg\"\n        >\n          {processingAuth ? (\n            <>\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n              Processing...\n            </>\n          ) : (\n            <>Join {studioName}</>\n          )}\n        </NeoButton>\n      ) : (\n        <div className=\"text-center\">\n          <NeoButton\n            onClick={() => {\n              // Redirect to login with return URL\n              const returnUrl = encodeURIComponent(window.location.href);\n              router.push(`/login?returnUrl=${returnUrl}`);\n            }}\n            size=\"lg\"\n            className=\"w-full\"\n          >\n            Sign In\n          </NeoButton>\n        </div>\n      )}\n    </>\n  );\n}\n```\n\nHere are the improvements I made:\n\n### In useAuthWithInvites.tsx:\n\n1. **Fixed the redirect URL path**: Changed from `/studios/${id}` to `/studio/${slug}` to match your existing route structure.\n\n2. **Added cleanup with `isMounted` flag**: Prevents state updates after the component is unmounted.\n\n3. **Better type checking**: Explicitly typed the role parameter in the acceptInvitation call.\n\n4. **Improved email validation logic**: Made it more flexible - if email in metadata exists, validate it; otherwise, use the user's current email.\n\n5. **Added error handling** in the initial auth check.\n\n### In invite-accept-content.tsx:\n\n1. **Added cleanup with `isMounted` flag**: Prevents state updates after unmount.\n\n2. **Enhanced invitation processing**:\n   - Always store the user's email in metadata when they're logged in\n   - Better logging\n\n3. **Added session refresh**: Added `supabase.auth.refreshSession()` after updating metadata to ensure the changes are picked up.\n\n4. **Improved error handling** in the useEffect cleanup.\n\nThese changes will make the invitation workflow more robust and prevent race conditions, memory leaks, and improve the user experience.\nhow about the checking of sessions? since we are also calling that in that useAuthWithInvites why call it again in the useEffect? also the role props is not for the auth schema it is for the studioMember role \n```prisma dance-book-app/prisma/schema.prisma:59-90\n// Excerpt from: \nenum StudioRole {\n  OWNER\n  ADMIN\n  CHOREOGRAPHER\n  STAFF\n}\n\nmodel StudioMember {\n  id String @id @default(uuid()) @db.Uuid\n\n  // Relationship fields\n  profileId String  @db.Uuid\n  studioId  String  @db.Uuid\n  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)\n  studio    Studio  @relation(fields: [studioId], references: [id], onDelete: Cascade)\n\n  // Role and permissions\n  role StudioRole @default(STAFF)\n\n  choreographerSchedules Schedule[] @relation(\"ChoreographerSchedules\")\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Unique constraint to prevent duplicate memberships\n  @@unique([profileId, studioId])\n  // Indexes for performance\n  @@index([profileId])\n  @@index([studioId])\n  @@index([role])\n}\n```\n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographer: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // 1. Create the Supabase server client\n        const supabase = await createClient({ isAdmin: true });\n\n        // 2. Check for existing member with this email at this studio\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          return {\n            email: input.email,\n            status: \"already_invited\",\n          };\n        }\n\n        // Store actionLink value\n        let actionLink: string | undefined;\n\n        // 3. Send invitation via Supabase OTP\n        try {\n          const { data, error } = await supabase.auth.admin.generateLink({\n            type: \"magiclink\",\n            email: input.email,\n            options: {\n              data: {\n                studioId: input.studioId,\n                invitedRole: input.role,\n                email: input.email,\n              },\n              redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}`,\n            },\n          });\n\n          if (error) {\n            throw new TRPCError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to send invitation\",\n              cause: error,\n            });\n          }\n\n          // Extract the action_link from the response\n          if (data?.properties?.action_link) {\n            actionLink = data.properties.action_link;\n          }\n        } catch (authError) {\n          console.error(\"Error sending invitation:\", authError);\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to send invitation email\",\n            cause: authError,\n          });\n        }\n\n        // 4. Store the pending invitation in your database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx.profile.id,\n            expiresAt: expirationDate,\n            status: \"PENDING\", // Explicitly set status\n          },\n        });\n\n        return {\n          email: input.email,\n          status: \"invited\",\n          actionLink, // Include the action link in the response\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to invite choreographer\",\n          cause: error,\n        });\n      }\n    }),\n\n  acceptInvitation: publicProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Find the pending invitation\n        const invitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            studioId: input.studioId,\n            email: input.email,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"No valid invitation found\",\n          });\n        }\n\n        // Check if not expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        const supabase = await createClient({ isAdmin: true });\n        // Get user by email using admin API\n        const { data: userData, error: userError } =\n          await supabase.auth.admin.listUsers();\n\n        if (userError) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"User account not found for this email address\",\n          });\n        }\n\n        // Now you have the user's auth ID\n        const authUser = userData.users.find(\n          (user) => user.email === input.email,\n        );\n\n        // Find the corresponding profile\n        const profile = await ctx.db.profile.findUnique({\n          where: { authId: authUser?.id },\n        });\n\n        if (!profile) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"User profile not found\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: profile.id,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: profile.id,\n              studioId: input.studioId,\n              role: invitation.role, // Use role from invitation record\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  listPendingInvitations: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const invitations = await ctx.db.studioInvitation.findMany({\n          where: {\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            invitedBy: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        return invitations;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list invitations\",\n          cause: error,\n        });\n      }\n    }),\n\n  resendInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Get the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: { id: input.invitationId },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found\",\n          });\n        }\n\n        // Check if invitation is still pending\n        if (invitation.status !== \"PENDING\") {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot resend invitation with status: ${invitation.status}`,\n          });\n        }\n\n        // Create Supabase client\n        const supabase = await createClient();\n\n        // Resend invitation\n        const { error } = await supabase.auth.admin.generateLink({\n          type: \"magiclink\",\n          email: invitation.email,\n          options: {\n            data: {\n              studioId: invitation.studioId,\n              invitedRole: invitation.role,\n            },\n            redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${invitation.studioId}&role=${invitation.role}`,\n          },\n        });\n\n        if (error) {\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to resend invitation\",\n            cause: error,\n          });\n        }\n\n        // Update expiration date\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        const updatedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { expiresAt: expirationDate },\n        });\n\n        return {\n          status: \"resent\",\n          invitation: updatedInvitation,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to resend invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  cancelInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        const deletedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: input.invitationId },\n          data: { status: \"CANCELLED\" },\n        });\n\n        return { status: \"cancelled\", invitation: deletedInvitation };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to cancel invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n\nYou're right on both points. Let me refine the code further to address these issues:\n\n```tsx\n// dance-book-app/src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\nexport function useAuthWithInvites() {\n  const router = useRouter();\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n  const { mutate: acceptInvitation } = api.studio.acceptInvitation.useMutation({\n    onSuccess: (data) => {\n      // Show success message and redirect to the studio\n      toast.success(\"Successfully joined studio!\");\n      // Use studio slug for the redirect if available\n      router.push(`/studio/${data.membership.studio.slug}`);\n    },\n    onError: (error) => {\n      console.error(\"Error accepting invitation:\", error);\n      toast.error(\"Failed to join studio: \" + error.message);\n    },\n  });\n\n  useEffect(() => {\n    let isMounted = true;\n\n    // Initial auth check and subscription setup\n    const setupAuth = async () => {\n      try {\n        // Initial session check\n        const { data } = await supabase.auth.getSession();\n        if (data.session?.user && isMounted) {\n          setUser({\n            id: data.session.user.id,\n            email: data.session.user.email ?? \"\",\n          });\n        }\n      } catch (error) {\n        console.error(\"Auth session check error:\", error);\n      } finally {\n        if (isMounted) setLoading(false);\n      }\n    };\n\n    void setupAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user && isMounted) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else if (isMounted) {\n        setUser(null);\n      }\n\n      // Handle sign in events with invitation data\n      if (\n        (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\") &&\n        session?.user\n      ) {\n        const userData = session.user.user_metadata;\n        const userEmail = session.user.email;\n\n        // Check if the user has invitation data in their metadata\n        if (userData?.studioId && userData?.invitedRole) {\n          // If email in metadata is defined, validate it matches current user\n          if (userData.email && userEmail !== userData.email) {\n            toast.error(\n              \"You must sign in with the email address the invitation was sent to.\"\n            );\n            return;\n          }\n\n          try {\n            // Accept the invitation using the current user's email address\n            acceptInvitation({\n              studioId: userData.studioId as string,\n              role: userData.invitedRole as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n              email: userEmail ?? \"\",\n            });\n\n            // Clear the invitation data from the user metadata\n            await supabase.auth.updateUser({\n              data: {\n                studioId: null,\n                invitedRole: null,\n                email: null,\n              },\n            });\n          } catch (error) {\n            console.error(\"Error processing invitation:\", error);\n          }\n        }\n      }\n\n      if (isMounted) setLoading(false);\n    });\n\n    return () => {\n      isMounted = false;\n      subscription.unsubscribe();\n    };\n  }, [supabase, router, acceptInvitation]);\n\n  return { user, loading };\n}\n```\n\n```tsx\n// dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processingAuth, setProcessingAuth] = useState(false);\n  const [invitationProcessed, setInvitationProcessed] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle invitation processing\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  useEffect(() => {\n    let isMounted = true;\n\n    async function processInvitation() {\n      if (!studioId || !role) {\n        setError(\"Invalid invitation link\");\n        return;\n      }\n\n      try {\n        // Check if user is already authenticated\n        const {\n          data: { session },\n        } = await supabase.auth.getSession();\n\n        if (session?.user) {\n          // User is already logged in, update their metadata with invitation data\n          // We don't need to store the email in metadata as we can access it from session\n          await supabase.auth.updateUser({\n            data: {\n              studioId,\n              invitedRole: role,\n            },\n          });\n        } else if (token) {\n          // The token will be automatically processed by Supabase Auth\n          console.log(\"Token present, waiting for auth to process it\");\n        }\n      } catch (err) {\n        console.error(\"Error processing invitation:\", err);\n        if (isMounted) setError(\"Failed to process invitation\");\n      } finally {\n        if (isMounted) setInvitationProcessed(true);\n      }\n    }\n\n    if (!invitationProcessed) {\n      void processInvitation();\n    }\n\n    return () => {\n      isMounted = false;\n    };\n  }, [studioId, role, token, supabase, invitationProcessed]);\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !role || !user) return;\n\n    try {\n      setProcessingAuth(true);\n\n      // Update user metadata with the studio and role info\n      // The email is already in the session\n      await supabase.auth.updateUser({\n        data: {\n          studioId,\n          invitedRole: role,\n        },\n      });\n\n      // Force a session refresh to ensure the metadata updates are picked up\n      await supabase.auth.refreshSession();\n\n      // The auth hook will handle the redirect after metadata is updated\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\"Failed to accept invitation\");\n      setProcessingAuth(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if ((processingAuth || authLoading) && studioId && role) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render just the invitation information and action buttons\n  return (\n    <>\n      {/* Invitation Info */}\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n\n        {user ? (\n          <p className=\"text-center text-gray-700\">\n            You're signed in as{\" \"}\n            <strong className=\"font-bold\">{user.email}</strong>\n          </p>\n        ) : (\n          <p className=\"text-center text-gray-700\">\n            Sign in to accept this invitation\n          </p>\n        )}\n      </NeoCard>\n\n      {/* Action Button */}\n      {user ? (\n        <NeoButton\n          onClick={handleAcceptInvitation}\n          disabled={processingAuth}\n          className=\"w-full\"\n          size=\"lg\"\n        >\n          {processingAuth ? (\n            <>\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n              Processing...\n            </>\n          ) : (\n            <>Join {studioName}</>\n          )}\n        </NeoButton>\n      ) : (\n        <div className=\"text-center\">\n          <NeoButton\n            onClick={() => {\n              // Redirect to login with return URL\n              const returnUrl = encodeURIComponent(window.location.href);\n              router.push(`/login?returnUrl=${returnUrl}`);\n            }}\n            size=\"lg\"\n            className=\"w-full\"\n          >\n            Sign In\n          </NeoButton>\n        </div>\n      )}\n    </>\n  );\n}\n```\n\n### Key improvements:\n\n1. **Simplified session management**: \n   - Removed redundant email storage in the user metadata, since we can get it directly from the session\n   - Used just one primary auth check in the useEffect setup\n\n2. **Fixed the role type**:\n   - Correctly typed the role as `\"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\"` matching your Prisma schema's `StudioRole` enum (excluding OWNER, which isn't allowed for invitations)\n\n3. **Better session handling**:\n   - Added `refreshSession()` call when the user accepts the invitation\n   - This ensures the metadata updates are immediately recognized\n\n4. **Correct redirect path**:\n   - Fixed the redirection URL pattern to `/studio/[slug]` instead of `/studios/[id]` to match your actual routes\n\n5. **Code cleanup**:\n   - Better error handling\n   - Kept the `isMounted` check for cleanup\n   - Added comments to make the flow clearer\n\nThis implementation properly handles the invitation flow while ensuring the user is validated against the invitation email, but skips the redundant email storage since we can get it directly from the user's session.\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx:51-56\n// Excerpt from: function InviteAcceptContent( ) > async function processInvitation()\nawait supabase.auth.updateUser({\n            data: {\n              studioId,\n              invitedRole: role,\n            },\n          });\n```\ni said the role props is not for updating the auth user\nwe should call a trpc mutation  to update the studioInvitation table and the profile to the studioMember table \n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographer: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // 1. Create the Supabase server client\n        const supabase = await createClient({ isAdmin: true });\n\n        // 2. Check for existing member with this email at this studio\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          return {\n            email: input.email,\n            status: \"already_invited\",\n          };\n        }\n\n        // Store actionLink value\n        let actionLink: string | undefined;\n\n        // 3. Send invitation via Supabase OTP\n        try {\n          const { data, error } = await supabase.auth.admin.generateLink({\n            type: \"magiclink\",\n            email: input.email,\n            options: {\n              data: {\n                studioId: input.studioId,\n                invitedRole: input.role,\n                email: input.email,\n              },\n              redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}`,\n            },\n          });\n\n          if (error) {\n            throw new TRPCError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to send invitation\",\n              cause: error,\n            });\n          }\n\n          // Extract the action_link from the response\n          if (data?.properties?.action_link) {\n            actionLink = data.properties.action_link;\n          }\n        } catch (authError) {\n          console.error(\"Error sending invitation:\", authError);\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to send invitation email\",\n            cause: authError,\n          });\n        }\n\n        // 4. Store the pending invitation in your database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx.profile.id,\n            expiresAt: expirationDate,\n            status: \"PENDING\", // Explicitly set status\n          },\n        });\n\n        return {\n          email: input.email,\n          status: \"invited\",\n          actionLink, // Include the action link in the response\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to invite choreographer\",\n          cause: error,\n        });\n      }\n    }),\n\n  acceptInvitation: publicProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Find the pending invitation\n        const invitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            studioId: input.studioId,\n            email: input.email,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"No valid invitation found\",\n          });\n        }\n\n        // Check if not expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        const supabase = await createClient({ isAdmin: true });\n        // Get user by email using admin API\n        const { data: userData, error: userError } =\n          await supabase.auth.admin.listUsers();\n\n        if (userError) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"User account not found for this email address\",\n          });\n        }\n\n        // Now you have the user's auth ID\n        const authUser = userData.users.find(\n          (user) => user.email === input.email,\n        );\n\n        // Find the corresponding profile\n        const profile = await ctx.db.profile.findUnique({\n          where: { authId: authUser?.id },\n        });\n\n        if (!profile) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"User profile not found\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: profile.id,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: profile.id,\n              studioId: input.studioId,\n              role: invitation.role, // Use role from invitation record\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  listPendingInvitations: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const invitations = await ctx.db.studioInvitation.findMany({\n          where: {\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            invitedBy: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        return invitations;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list invitations\",\n          cause: error,\n        });\n      }\n    }),\n\n  resendInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Get the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: { id: input.invitationId },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found\",\n          });\n        }\n\n        // Check if invitation is still pending\n        if (invitation.status !== \"PENDING\") {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot resend invitation with status: ${invitation.status}`,\n          });\n        }\n\n        // Create Supabase client\n        const supabase = await createClient();\n\n        // Resend invitation\n        const { error } = await supabase.auth.admin.generateLink({\n          type: \"magiclink\",\n          email: invitation.email,\n          options: {\n            data: {\n              studioId: invitation.studioId,\n              invitedRole: invitation.role,\n            },\n            redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${invitation.studioId}&role=${invitation.role}`,\n          },\n        });\n\n        if (error) {\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to resend invitation\",\n            cause: error,\n          });\n        }\n\n        // Update expiration date\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        const updatedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { expiresAt: expirationDate },\n        });\n\n        return {\n          status: \"resent\",\n          invitation: updatedInvitation,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to resend invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  cancelInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        const deletedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: input.invitationId },\n          data: { status: \"CANCELLED\" },\n        });\n\n        return { status: \"cancelled\", invitation: deletedInvitation };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to cancel invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n\nYou're absolutely right. I misunderstood the workflow. The `role` in the URL is just information about what role the user is being invited to, but we should be directly calling the trpc mutation to handle the invitation acceptance rather than storing it in auth metadata.\n\nHere's the corrected implementation:\n\n```tsx\n// dance-book-app/src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { api } from \"~/trpc/react\";\n\nexport function useAuthWithInvites() {\n  const router = useRouter();\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n  \n  useEffect(() => {\n    let isMounted = true;\n\n    // Initial auth check\n    const checkAuth = async () => {\n      try {\n        const { data } = await supabase.auth.getSession();\n        if (data.session?.user && isMounted) {\n          setUser({\n            id: data.session.user.id,\n            email: data.session.user.email ?? \"\",\n          });\n        }\n      } catch (error) {\n        console.error(\"Auth session check error:\", error);\n      } finally {\n        if (isMounted) setLoading(false);\n      }\n    };\n\n    void checkAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user && isMounted) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else if (isMounted) {\n        setUser(null);\n      }\n\n      if (isMounted) setLoading(false);\n    });\n\n    return () => {\n      isMounted = false;\n      subscription.unsubscribe();\n    };\n  }, [supabase]);\n\n  return { user, loading };\n}\n```\n\n```tsx\n// dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processingAuth, setProcessingAuth] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle authentication status\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isLoading: isAcceptingInvitation } = \n    api.studio.acceptInvitation.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        router.push(`/studio/${data.membership.studio.slug}`);\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n      },\n    });\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !user?.email || !role) return;\n\n    try {\n      setProcessingAuth(true);\n\n      // Accept the invitation - this will update the invitation status\n      // and create the studio membership via the trpc mutation\n      acceptInvitation({\n        studioId: studioId,\n        role: role as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n        email: user.email,\n      });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(err instanceof Error ? err.message : \"Failed to accept invitation\");\n      setProcessingAuth(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if ((processingAuth || authLoading || isAcceptingInvitation) && studioId && role) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render just the invitation information and action buttons\n  return (\n    <>\n      {/* Invitation Info */}\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n\n        {user ? (\n          <p className=\"text-center text-gray-700\">\n            You're signed in as{\" \"}\n            <strong className=\"font-bold\">{user.email}</strong>\n          </p>\n        ) : (\n          <p className=\"text-center text-gray-700\">\n            Sign in to accept this invitation\n          </p>\n        )}\n      </NeoCard>\n\n      {/* Action Button */}\n      {user ? (\n        <NeoButton\n          onClick={handleAcceptInvitation}\n          disabled={processingAuth || isAcceptingInvitation}\n          className=\"w-full\"\n          size=\"lg\"\n        >\n          {processingAuth || isAcceptingInvitation ? (\n            <>\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n              Processing...\n            </>\n          ) : (\n            <>Join {studioName}</>\n          )}\n        </NeoButton>\n      ) : (\n        <div className=\"text-center\">\n          <NeoButton\n            onClick={() => {\n              // Redirect to login with return URL\n              const returnUrl = encodeURIComponent(window.location.href);\n              router.push(`/login?returnUrl=${returnUrl}`);\n            }}\n            size=\"lg\"\n            className=\"w-full\"\n          >\n            Sign In\n          </NeoButton>\n        </div>\n      )}\n    </>\n  );\n}\n```\n\nKey changes:\n\n1. **Simplified the useAuthWithInvites hook**:\n   - Now it only handles authentication state, not invitation processing\n   - Removed all the metadata management logic\n\n2. **Direct tRPC mutation call**:\n   - Added the tRPC mutation directly in the invite-accept-content component\n   - Call the acceptInvitation mutation when the user clicks the button\n   - Handle success/error states properly\n\n3. **Removed unnecessary user metadata updates**:\n   - No longer storing invitation data in auth metadata\n   - Using the proper workflow of calling the server endpoint directly\n\n4. **More comprehensive loading states**:\n   - Added isAcceptingInvitation to track the mutation status\n\nThis approach is much cleaner and follows the correct separation of concerns - the authentication system only handles authentication, and your application's business logic for handling invitations is managed through your tRPC endpoints.\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processingAuth, setProcessingAuth] = useState(false);\n  const router = useRouter();\n\n  // Use the auth hook to handle authentication status\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitation.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // router.push(`/studio/${data.membership.}`);\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n      },\n    });\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !user?.email || !role) return;\n\n    try {\n      setProcessingAuth(true);\n\n      // Accept the invitation - this will update the invitation status\n      // and create the studio membership via the trpc mutation\n      acceptInvitation({\n        studioId: studioId,\n        role: role as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n        email: user.email,\n      });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessingAuth(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (\n    (processingAuth || authLoading || isAcceptingInvitation) &&\n    studioId &&\n    role\n  ) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render just the invitation information and action buttons\n  return (\n    <>\n      {/* Invitation Info */}\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n\n        {user ? (\n          <p className=\"text-center text-gray-700\">\n            You're signed in as{\" \"}\n            <strong className=\"font-bold\">{user.email}</strong>\n          </p>\n        ) : (\n          <p className=\"text-center text-gray-700\">\n            Sign in to accept this invitation\n          </p>\n        )}\n      </NeoCard>\n\n      {/* Action Button */}\n      {user ? (\n        <NeoButton\n          onClick={handleAcceptInvitation}\n          disabled={processingAuth || isAcceptingInvitation}\n          className=\"w-full\"\n          size=\"lg\"\n        >\n          {processingAuth || isAcceptingInvitation ? (\n            <>\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n              Processing...\n            </>\n          ) : (\n            <>Join {studioName}</>\n          )}\n        </NeoButton>\n      ) : (\n        <div className=\"text-center\">\n          <NeoButton\n            onClick={() => {\n              // Redirect to login with return URL\n              const returnUrl = encodeURIComponent(window.location.href);\n              router.push(`/login?returnUrl=${returnUrl}`);\n            }}\n            size=\"lg\"\n            className=\"w-full\"\n          >\n            Sign In\n          </NeoButton>\n        </div>\n      )}\n    </>\n  );\n}\n```\n\n```tsx dance-book-app/src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from \"react\";\nimport { createClient } from \"~/lib/supabase/client\";\n\nexport function useAuthWithInvites() {\n  const supabase = createClient();\n  const [loading, setLoading] = useState(true);\n  const [user, setUser] = useState<{ id: string; email: string } | null>(null);\n\n  useEffect(() => {\n    let isMounted = true;\n\n    // Initial auth check\n    const checkAuth = async () => {\n      try {\n        const { data } = await supabase.auth.getSession();\n        if (data.session?.user && isMounted) {\n          setUser({\n            id: data.session.user.id,\n            email: data.session.user.email ?? \"\",\n          });\n        }\n      } catch (error) {\n        console.error(\"Auth session check error:\", error);\n      } finally {\n        if (isMounted) setLoading(false);\n      }\n    };\n\n    void checkAuth();\n\n    // Listen for auth changes\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      // Set user state\n      if (session?.user && isMounted) {\n        setUser({\n          id: session.user.id,\n          email: session.user.email ?? \"\",\n        });\n      } else if (isMounted) {\n        setUser(null);\n      }\n\n      if (isMounted) setLoading(false);\n    });\n\n    return () => {\n      isMounted = false;\n      subscription.unsubscribe();\n    };\n  }, [supabase]);\n\n  return { user, loading };\n}\n```\n\ni think when clicking the signin we should not redirect to the login page but instead call the signin with magic link?\nGreat point! Let's modify the component to directly trigger a magic link sign-in when the user clicks the button, rather than redirecting to a login page. This will create a smoother experience for accepting invitations.\n\n```tsx\n// dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processingAuth, setProcessingAuth] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [sentEmail, setSentEmail] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle authentication status\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitation.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessingAuth(false);\n      },\n    });\n\n  // Handle magic link sign-in\n  const handleMagicLinkSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!email.trim()) {\n      toast.error(\"Please enter your email address\");\n      return;\n    }\n    \n    try {\n      setProcessingAuth(true);\n      \n      // Generate magic link\n      const { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n      \n      if (error) {\n        throw error;\n      }\n      \n      // Show success message\n      toast.success(\"Check your email for a sign-in link!\");\n      setSentEmail(true);\n    } catch (err) {\n      console.error(\"Error sending magic link:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Failed to send sign-in link\"\n      );\n    } finally {\n      setProcessingAuth(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !user?.email || !role) return;\n\n    try {\n      setProcessingAuth(true);\n\n      // Accept the invitation - this will update the invitation status\n      // and create the studio membership via the trpc mutation\n      acceptInvitation({\n        studioId: studioId,\n        role: role as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n        email: user.email,\n      });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\"\n      );\n      setProcessingAuth(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state for auth loading or invitation acceptance\n  if (\n    (processingAuth || authLoading || isAcceptingInvitation) &&\n    studioId &&\n    role\n  ) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render magic link sign-in form if not signed in\n  if (!user) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n\n          {sentEmail ? (\n            <div className=\"text-center\">\n              <p className=\"mb-4 text-gray-700\">\n                Check your email for a sign-in link!\n              </p>\n              <p className=\"text-sm text-gray-500\">\n                After signing in, you'll be able to accept this invitation.\n              </p>\n            </div>\n          ) : (\n            <form onSubmit={handleMagicLinkSignIn} className=\"mt-4 space-y-4\">\n              <p className=\"mb-2 text-center text-gray-700\">\n                Sign in with your email to accept this invitation\n              </p>\n              <Input\n                type=\"email\"\n                placeholder=\"Your email address\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full\"\n              />\n              <NeoButton \n                type=\"submit\" \n                className=\"w-full\" \n                size=\"lg\"\n                disabled={processingAuth}\n              >\n                {processingAuth ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Sign In\"\n                )}\n              </NeoButton>\n            </form>\n          )}\n        </NeoCard>\n      </>\n    );\n  }\n\n  // Render invitation acceptance UI for signed-in users\n  return (\n    <>\n      {/* Invitation Info */}\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n\n        <p className=\"text-center text-gray-700\">\n          You're signed in as{\" \"}\n          <strong className=\"font-bold\">{user.email}</strong>\n        </p>\n      </NeoCard>\n\n      {/* Action Button */}\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processingAuth || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processingAuth || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\nI've made the following improvements:\n\n1. **Added direct magic link sign-in**:\n   - Added an email input field and form for users who aren't signed in\n   - Implemented the `handleMagicLinkSignIn` function to send the magic link\n   - Used Supabase's `signInWithOtp` to send a magic link email\n   - Added a state to track when an email has been sent\n\n2. **Better user feedback**:\n   - Added success toast when the magic link is sent\n   - Show a different message after the email has been sent\n   - Kept the loading indicator for processing states\n\n3. **Fixed the redirection after successful invitation acceptance**:\n   - Added proper navigation to the studio page using the slug\n   - Provided a fallback to the studios listing if slug isn't available\n\n4. **Better error handling**:\n   - Properly handling errors for both magic link sending and invitation acceptance\n   - Providing helpful error messages to the user\n\nThis implementation should provide a much smoother experience for users accepting invitations, allowing them to sign in directly from the invitation page instead of being redirected elsewhere.\n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographer: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // 1. Create the Supabase server client\n        const supabase = await createClient({ isAdmin: true });\n\n        // 2. Check for existing member with this email at this studio\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          return {\n            email: input.email,\n            status: \"already_invited\",\n          };\n        }\n\n        // Store actionLink value\n        let actionLink: string | undefined;\n\n        // 3. Send invitation via Supabase OTP\n        try {\n          const { data, error } = await supabase.auth.admin.generateLink({\n            type: \"magiclink\",\n            email: input.email,\n            options: {\n              data: {\n                studioId: input.studioId,\n                invitedRole: input.role,\n                email: input.email,\n              },\n              redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}`,\n            },\n          });\n\n          if (error) {\n            throw new TRPCError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to send invitation\",\n              cause: error,\n            });\n          }\n\n          // Extract the action_link from the response\n          if (data?.properties?.action_link) {\n            actionLink = data.properties.action_link;\n          }\n        } catch (authError) {\n          console.error(\"Error sending invitation:\", authError);\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to send invitation email\",\n            cause: authError,\n          });\n        }\n\n        // 4. Store the pending invitation in your database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx.profile.id,\n            expiresAt: expirationDate,\n            status: \"PENDING\", // Explicitly set status\n          },\n        });\n\n        return {\n          email: input.email,\n          status: \"invited\",\n          actionLink, // Include the action link in the response\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to invite choreographer\",\n          cause: error,\n        });\n      }\n    }),\n\n  acceptInvitation: publicProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Find the pending invitation\n        const invitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            studioId: input.studioId,\n            email: input.email,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"No valid invitation found\",\n          });\n        }\n\n        // Check if not expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        const supabase = await createClient({ isAdmin: true });\n        // Get user by email using admin API\n        const { data: userData, error: userError } =\n          await supabase.auth.admin.listUsers();\n\n        if (userError) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"User account not found for this email address\",\n          });\n        }\n\n        // Now you have the user's auth ID\n        const authUser = userData.users.find(\n          (user) => user.email === input.email,\n        );\n\n        // Find the corresponding profile\n        const profile = await ctx.db.profile.findUnique({\n          where: { authId: authUser?.id },\n        });\n\n        if (!profile) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"User profile not found\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: profile.id,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: profile.id,\n              studioId: input.studioId,\n              role: invitation.role, // Use role from invitation record\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  listPendingInvitations: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const invitations = await ctx.db.studioInvitation.findMany({\n          where: {\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            invitedBy: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        return invitations;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list invitations\",\n          cause: error,\n        });\n      }\n    }),\n\n  resendInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Get the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: { id: input.invitationId },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found\",\n          });\n        }\n\n        // Check if invitation is still pending\n        if (invitation.status !== \"PENDING\") {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot resend invitation with status: ${invitation.status}`,\n          });\n        }\n\n        // Create Supabase client\n        const supabase = await createClient();\n\n        // Resend invitation\n        const { error } = await supabase.auth.admin.generateLink({\n          type: \"magiclink\",\n          email: invitation.email,\n          options: {\n            data: {\n              studioId: invitation.studioId,\n              invitedRole: invitation.role,\n            },\n            redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${invitation.studioId}&role=${invitation.role}`,\n          },\n        });\n\n        if (error) {\n          throw new TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to resend invitation\",\n            cause: error,\n          });\n        }\n\n        // Update expiration date\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        const updatedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { expiresAt: expirationDate },\n        });\n\n        return {\n          status: \"resent\",\n          invitation: updatedInvitation,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to resend invitation\",\n          cause: error,\n        });\n      }\n    }),\n\n  cancelInvitation: adminProcedure\n    .input(\n      z.object({\n        invitationId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        const deletedInvitation = await ctx.db.studioInvitation.update({\n          where: { id: input.invitationId },\n          data: { status: \"CANCELLED\" },\n        });\n\n        return { status: \"cancelled\", invitation: deletedInvitation };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to cancel invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n```ts dance-book-app/src/server/api/routers/studio.ts:669-680\n// Excerpt from: const studioRouter\nconst { data, error } = await supabase.auth.admin.generateLink({\n            type: \"magiclink\",\n            email: input.email,\n            options: {\n              data: {\n                studioId: input.studioId,\n                invitedRole: input.role,\n                email: input.email,\n              },\n              redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}`,\n            },\n          });\n```\nwhat i mean is that we generate a magic link right?\ni will send the link the choreographer and when they click the link they will be redirected to the invite-accept where they can accept the invitation but how are we gonna implemenet this if the user is not signed in?\nwhat is the best way without implementing a send email feature\nI understand now. You're looking for a simpler workflow for handling invitation acceptance when the user isn't yet signed in, without implementing a separate email sending feature. Here's a better approach:\n\n## The Improved Solution\n\n1. **Use Supabase's Built-in Magic Link Authentication**:\n   - When a user clicks the magic link from their email, Supabase automatically handles the authentication\n   - After authentication, they're redirected to your invite-accept page with the appropriate query parameters\n\n2. **Simplify the Accept Flow**:\n   - For users who are already authenticated, show the \"Accept\" button\n   - For users who are not authenticated, show the Magic Link sign-in form\n\nHere's the implementation:\n\n```tsx\n// dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [sentEmail, setSentEmail] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle authentication status\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitation.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle magic link sign-in\n  const handleMagicLinkSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!email.trim()) {\n      toast.error(\"Please enter your email address\");\n      return;\n    }\n    \n    try {\n      setProcessing(true);\n      \n      // Generate magic link that redirects back to this invitation page\n      const { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n      \n      if (error) {\n        throw error;\n      }\n      \n      // Show success message\n      toast.success(\"Check your email for a sign-in link!\");\n      setSentEmail(true);\n    } catch (err) {\n      console.error(\"Error sending magic link:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Failed to send sign-in link\"\n      );\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !user?.email) return;\n\n    try {\n      setProcessing(true);\n\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({\n        studioId,\n        role: role as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n        email: user.email,\n      });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\"\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if ((processing || authLoading || isAcceptingInvitation) && studioId && role) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render magic link sign-in form if not signed in\n  if (!user) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n\n          {sentEmail ? (\n            <div className=\"text-center\">\n              <p className=\"mb-4 text-gray-700\">\n                Check your email for a sign-in link!\n              </p>\n              <p className=\"text-sm text-gray-500\">\n                After signing in, you'll be able to accept this invitation.\n              </p>\n            </div>\n          ) : (\n            <form onSubmit={handleMagicLinkSignIn} className=\"mt-4 space-y-4\">\n              <p className=\"mb-2 text-center text-gray-700\">\n                Sign in with your email to accept this invitation\n              </p>\n              <Input\n                type=\"email\"\n                placeholder=\"Your email address\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full\"\n              />\n              <NeoButton \n                type=\"submit\" \n                className=\"w-full\" \n                size=\"lg\"\n                disabled={processing}\n              >\n                {processing ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Sign In\"\n                )}\n              </NeoButton>\n            </form>\n          )}\n        </NeoCard>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in as{\" \"}\n          <strong className=\"font-bold\">{user.email}</strong>\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\n### The workflow is now:\n\n1. **Admin invites a choreographer**:\n   - Your backend uses `supabase.auth.admin.generateLink()` to create a magic link\n   - This link is sent to the email address via Supabase's built-in email functionality\n\n2. **User clicks the link in their email**:\n   - If not signed in: They're first authenticated by Supabase, then redirected to your invite-accept page\n   - If already signed in: They're directly redirected to your invite-accept page\n\n3. **On the invite-accept page**:\n   - If user is authenticated: Show \"Join Studio\" button that calls your acceptInvitation mutation\n   - If user is not authenticated: Show a form to request a magic link to sign in first\n\nThis approach leverages Supabase's authentication system completely, so you don't need to implement email sending yourself. The magic links handle both authentication and redirecting to the right page.\n\nIf a user is not signed in via the magic link for any reason, they'll still be able to sign in directly from the invitation page using the email sign-in form.\nAuthApiError: Error sending magic link email\n    at handleError (http://localhost:3000/_next/static/chunks/node_modules__pnpm_c1c07da6._.js:6681:11)\n    at async _handleRequest (http://localhost:3000/_next/static/chunks/node_modules__pnpm_c1c07da6._.js:6731:9)\n    at async _request (http://localhost:3000/_next/static/chunks/node_modules__pnpm_c1c07da6._.js:6711:18)\n    at async SupabaseAuthClient.signInWithOtp (http://localhost:3000/_next/static/chunks/node_modules__pnpm_c1c07da6._.js:7954:35)\n    at async handleMagicLinkSignIn (http://localhost:3000/_next/static/chunks/src_ec393910._.js:395:31)\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx:70-76\n// Excerpt from: function InviteAcceptContent( )\nconst { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n\n```\ngot this  error from the signInWithOtp\nThis error is occurring because Supabase can't send the magic link email. There are a few common reasons for this:\n\n1. **Email configuration issues**: Your Supabase project may not have email configured correctly.\n2. **Local development environment**: When working locally, email services might be restricted.\n3. **Rate limiting**: Supabase limits how many emails you can send to prevent abuse.\n\nLet's fix this by:\n\n1. Adding better error handling\n2. Providing a dev workaround for local testing\n\n```tsx\n// dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n// Update the handleMagicLinkSignIn function\n\n// Handle magic link sign-in\nconst handleMagicLinkSignIn = async (e: React.FormEvent) => {\n  e.preventDefault();\n  \n  if (!email.trim()) {\n    toast.error(\"Please enter your email address\");\n    return;\n  }\n  \n  try {\n    setProcessing(true);\n    \n    // Generate magic link that redirects back to this invitation page\n    const { data, error } = await supabase.auth.signInWithOtp({\n      email: email.trim(),\n      options: {\n        emailRedirectTo: window.location.href, // Redirect back to this page\n      },\n    });\n    \n    if (error) {\n      console.error(\"Magic link error:\", error);\n      \n      // Check if we're in development mode\n      if (process.env.NODE_ENV === 'development') {\n        // For development, show a special message with instructions\n        toast.error(\n          \"Email sending is disabled in development mode. Use the Supabase dashboard to view magic links.\",\n          { duration: 10000 }\n        );\n        \n        toast.info(\n          \"For testing, go to your Supabase dashboard → Authentication → Users, and click on 'Sign in as' instead.\",\n          { duration: 10000 }\n        );\n        \n        // Still set sentEmail to true to update the UI\n        setSentEmail(true);\n        return;\n      }\n      \n      throw error;\n    }\n    \n    // Show success message\n    toast.success(\"Check your email for a sign-in link!\");\n    setSentEmail(true);\n  } catch (err) {\n    console.error(\"Error sending magic link:\", err);\n    \n    // More descriptive error message\n    let errorMessage = \"Failed to send sign-in link\";\n    if (err instanceof Error) {\n      errorMessage = err.message;\n      \n      // Add more helpful context for specific errors\n      if (errorMessage.includes(\"rate limit\")) {\n        errorMessage = \"Too many sign-in attempts. Please try again later.\";\n      } else if (errorMessage.includes(\"smtp\")) {\n        errorMessage = \"Email service error. Please contact support.\";\n      }\n    }\n    \n    toast.error(errorMessage);\n  } finally {\n    setProcessing(false);\n  }\n};\n```\n\n### Alternative Login Options for Development\n\nFor local development, you can add some alternative login methods:\n\n```tsx\n// Add this after the form in the \"if (!user)\" section:\n\n{!sentEmail && process.env.NODE_ENV === 'development' && (\n  <div className=\"mt-4 border-t border-gray-200 pt-4\">\n    <p className=\"mb-2 text-center text-sm font-medium\">Development Options</p>\n    <div className=\"grid gap-2\">\n      <NeoButton\n        variant=\"outline\"\n        onClick={async () => {\n          try {\n            const { error } = await supabase.auth.signInWithPassword({\n              email: 'test@example.com',\n              password: 'password',\n            });\n            \n            if (error) throw error;\n          } catch (err) {\n            toast.error(\"Test login failed: \" + (err instanceof Error ? err.message : String(err)));\n          }\n        }}\n      >\n        Sign in as test@example.com\n      </NeoButton>\n      \n      <div className=\"text-center text-xs text-gray-500\">\n        <p>For local development only</p>\n        <p className=\"mt-1\">\n          To create a test user, go to your Supabase dashboard → Authentication → Users\n        </p>\n      </div>\n    </div>\n  </div>\n)}\n```\n\n### Development Recommendations for Supabase Auth\n\n1. **Create test users directly in the Supabase dashboard**:\n   - Go to your Supabase project dashboard\n   - Navigate to Authentication → Users\n   - Create a new user with email/password\n   - Use the \"Sign in as\" feature to authenticate as that user in your app\n\n2. **Use password-based login during development**:\n   - Enable email/password authentication in your Supabase project\n   - Add a password field to your form for development\n   - Use `signInWithPassword` instead of `signInWithOtp` during development\n\n3. **Set up a development SMTP server**:\n   - Tools like [Mailhog](https://github.com/mailhog/MailHog) or [Mailtrap](https://mailtrap.io) can be used\n   - Configure Supabase to use this SMTP server in development\n\nThis improved error handling and development workarounds should help you test the invitation flow without needing production email sending to work locally.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7479}}},{"id":{"replica_id":0,"value":73},"start":34975,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7480}}},{"id":{"replica_id":0,"value":74},"start":36899,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7481}}},{"id":{"replica_id":0,"value":208},"start":50383,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7482}}},{"id":{"replica_id":0,"value":257},"start":50417,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7483}}},{"id":{"replica_id":0,"value":258},"start":54728,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7484}}},{"id":{"replica_id":0,"value":472},"start":63308,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7485}}},{"id":{"replica_id":0,"value":473},"start":73960,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7486}}},{"id":{"replica_id":0,"value":1083},"start":74170,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7487}}},{"id":{"replica_id":0,"value":1182},"start":103337,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7488}}},{"id":{"replica_id":0,"value":1183},"start":113756,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7489}}},{"id":{"replica_id":0,"value":1607},"start":114126,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7490}}},{"id":{"replica_id":0,"value":2040},"start":114238,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7491}}},{"id":{"replica_id":0,"value":2123},"start":142515,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7492}}},{"id":{"replica_id":0,"value":2124},"start":150182,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7493}}},{"id":{"replica_id":0,"value":3349},"start":156599,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7494}}},{"id":{"replica_id":0,"value":3350},"start":165294,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7495}}},{"id":{"replica_id":0,"value":5232},"start":194403,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7496}}},{"id":{"replica_id":0,"value":5827},"start":194466,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7497}}},{"id":{"replica_id":0,"value":5828},"start":203382,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7498}}},{"id":{"replica_id":0,"value":6610},"start":203985,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7499}}},{"id":{"replica_id":0,"value":6993},"start":204365,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":7500}}},{"id":{"replica_id":0,"value":6994},"start":209165,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":7501}}}],"summary":"Here's a solution to query user details by email in the auth schema:","slash_command_output_sections":[{"range":{"start":0,"end":1276},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1275},"icon":"Library","label":"General","metadata":null},{"range":{"start":1277,"end":7005},"icon":"File","label":"dance-book-app/prisma/schema.prisma","metadata":{"path":"dance-book-app/prisma/schema.prisma"}},{"range":{"start":7006,"end":34442},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":34443,"end":34877},"icon":"TextSnippet","label":"dance-book-app/src/server/api/routers/studio.ts, Lines 775 to 785","metadata":null},{"range":{"start":36899,"end":39842},"icon":"File","label":"dance-book-app/src/hooks/use-auth-with-invites.tsx","metadata":{"path":"dance-book-app/src/hooks/use-auth-with-invites.tsx"}},{"range":{"start":39843,"end":50246},"icon":"Folder","label":"dance-book-app/src/app/(public)/studio/[slug]","metadata":null},{"range":{"start":39889,"end":48388},"icon":"File","label":"dance-book-app/src/app/(public)/studio/[slug]/page.tsx","metadata":{"path":"dance-book-app/src/app/(public)/studio/[slug]/page.tsx"}},{"range":{"start":48389,"end":50246},"icon":"Folder","label":"schedules","metadata":null},{"range":{"start":48399,"end":50245},"icon":"File","label":"dance-book-app/src/app/(public)/studio/[slug]/schedules/page.tsx","metadata":{"path":"dance-book-app/src/app/(public)/studio/[slug]/schedules/page.tsx"}},{"range":{"start":54728,"end":59897},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}},{"range":{"start":59898,"end":63236},"icon":"File","label":"dance-book-app/src/hooks/use-auth-with-invites.tsx","metadata":{"path":"dance-book-app/src/hooks/use-auth-with-invites.tsx"}},{"range":{"start":74170,"end":75059},"icon":"TextSnippet","label":"dance-book-app/prisma/schema.prisma, Lines 59 to 90","metadata":null},{"range":{"start":75060,"end":103335},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":113756,"end":114069},"icon":"TextSnippet","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx, Lines 51 to 56","metadata":null},{"range":{"start":114238,"end":142513},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":150182,"end":155018},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}},{"range":{"start":155019,"end":156479},"icon":"File","label":"dance-book-app/src/hooks/use-auth-with-invites.tsx","metadata":{"path":"dance-book-app/src/hooks/use-auth-with-invites.tsx"}},{"range":{"start":165294,"end":193569},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":193570,"end":194133},"icon":"TextSnippet","label":"dance-book-app/src/server/api/routers/studio.ts, Lines 669 to 680","metadata":null},{"range":{"start":203985,"end":204325},"icon":"TextSnippet","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx, Lines 70 to 76","metadata":null}]}
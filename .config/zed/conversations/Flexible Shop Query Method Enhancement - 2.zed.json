{"id":"cddae603-21f7-4c9b-ac92-4fd641dd7259","zed":"context","version":"0.4.0","text":"\nDO NOT GIVE ME HIGH-LEVEL THEORY. IF I ASK FOR A FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT \"Here's how you can blablabla\"\n\nBe casual unless otherwise specified\nBe terse and concise\nSuggest solutions that I didn’t think about—anticipate my needs\nTreat me as an expert\nBe accurate and thorough\nGive the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer\nValue good arguments over authorities, the source is irrelevant\nConsider new technologies and contrarian ideas, not just conventional wisdom\nYou may use high levels of speculation or prediction, just flag it for me\nNo moral lectures\nDiscuss safety only when it's crucial and non-obvious\nIf your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward\nCite sources whenever possible at the end, not inline\nNo need to mention your knowledge cutoff\nNo need to disclose you're an AI\nPlease respect my prettier preferences when you provide code\nSplit into multiple responses if one response isn't enough to answer the question\nFocus on readability over being performant\nFully implement all requested functionality\nLeave NO todos, placeholders, or missing pieces\n\n```ts lokal-link-be/src/features/shops/services/shops.services.ts\nimport { eq } from \"drizzle-orm\";\nimport {\n  shopAddresses,\n  shops,\n  shopSchedules,\n} from \"@/db/schema/shops.schema.ts\";\nimport { db } from \"@/db/index.ts\";\nimport { ShopColumns, ShopInsert } from \"@/features/shops/shops.types.ts\";\n\nexport class ShopsService {\n  static async create(input: ShopInsert, tx = db) {\n    const [shop] = await tx\n      .insert(shops)\n      .values(input)\n      .returning();\n\n    return shop;\n  }\n\n  static async getById(\n    id: string,\n    options: {\n      includeAddresses?: boolean;\n      includeSchedules?: boolean;\n      columns?: ShopColumns[] | \"*\";\n    },\n  ) {\n    const {\n      includeAddresses = false,\n      includeSchedules = false,\n      columns = \"*\",\n    } = options;\n\n    const shop = await db.query.shops.findFirst({\n      where: eq(shops.id, id),\n      columns: columns === \"*\"\n        ? undefined\n        : Object.fromEntries(columns.map((col) => [col, true])),\n      with: {\n        ...(includeAddresses && { shopAddresses: true }),\n        ...(includeSchedules && { schedules: true }),\n      },\n    });\n\n    return shop;\n  }\n}\n```\n\n```ts lokal-link-be/src/features/shops/services/shops.services.ts:20-46\n// Excerpt from: class ShopsService\n static async getById(\n    id: string,\n    options: {\n      includeAddresses?: boolean;\n      includeSchedules?: boolean;\n      columns?: ShopColumns[] | \"*\";\n    },\n  ) {\n    const {\n      includeAddresses = false,\n      includeSchedules = false,\n      columns = \"*\",\n    } = options;\n\n    const shop = await db.query.shops.findFirst({\n      where: eq(shops.id, id),\n      columns: columns === \"*\"\n        ? undefined\n        : Object.fromEntries(columns.map((col) => [col, true])),\n      with: {\n        ...(includeAddresses && { shopAddresses: true }),\n        ...(includeSchedules && { schedules: true }),\n      },\n    });\n\n    return shop;\n  }\n```\n```ts lokal-link-be/src/db/schema/shops.schema.ts\nimport {\n  boolean,\n  index,\n  integer,\n  pgTable,\n  text,\n  time,\n  uniqueIndex,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\nimport { commonColumns } from \"../utils.ts\";\nimport { address } from \"./address.schema.ts\";\nimport { products } from \"./products.schema.ts\";\nimport { profiles } from \"./profiles.schema.ts\";\n\nexport const shops = pgTable(\"shops\", {\n  ...commonColumns,\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  description: text(\"description\"),\n  image: varchar(\"image\", { length: 2048 }),\n  followersCount: integer(\"followers_count\").notNull().default(0),\n  slug: varchar(\"slug\", { length: 255 }).notNull().unique(),\n  ownerProfileId: uuid(\"owner_profile_id\")\n    .references(() => profiles.id)\n    .notNull(),\n}, (table) => [\n  uniqueIndex(\"shops_slug_idx\").on(table.slug),\n  index(\"shops_owner_profile_id_idx\").on(table.ownerProfileId),\n]);\n\nexport const shopsRelations = relations(shops, ({ many, one }) => ({\n  shopAddresses: many(shopAddresses),\n  products: many(products),\n  schedules: many(shopSchedules),\n  followers: many(shopFollowers),\n  profile: one(profiles, {\n    fields: [shops.ownerProfileId],\n    references: [profiles.id],\n  }),\n}));\n\nexport const shopAddresses = pgTable(\"shop_addresses\", {\n  ...commonColumns,\n  shopId: uuid(\"shop_id\")\n    .references(() => shops.id)\n    .notNull(),\n  addressId: uuid(\"address_id\")\n    .references(() => address.id)\n    .notNull(),\n  type: varchar(\"type\", { length: 20 }).notNull(),\n  isMain: boolean(\"is_main\").notNull().default(false),\n});\n\nexport const shopAddressesRelations = relations(shopAddresses, ({ one }) => ({\n  shop: one(shops, {\n    fields: [shopAddresses.shopId],\n    references: [shops.id],\n  }),\n  address: one(address, {\n    fields: [shopAddresses.addressId],\n    references: [address.id],\n  }),\n}));\n\nexport const shopSchedules = pgTable(\"shop_schedules\", {\n  ...commonColumns,\n  shopId: uuid(\"shop_id\")\n    .references(() => shops.id)\n    .notNull(),\n  dayOfWeek: varchar(\"day_of_week\", { length: 10 }).notNull(),\n  openTime: time(\"open_time\").notNull(),\n  closeTime: time(\"close_time\").notNull(),\n  isClosed: boolean(\"is_closed\").notNull().default(false),\n}, (table) => [\n  // Index for quick shop schedule lookups\n  index(\"shop_schedules_shop_id_idx\").on(table.shopId),\n  // Composite index for finding specific day schedules for a shop\n  index(\"shop_schedules_shop_day_idx\").on(table.shopId, table.dayOfWeek),\n  // Composite index for finding open/closed shops on specific days\n  index(\"shop_schedules_shop_status_idx\").on(table.shopId, table.isClosed),\n]);\n\nexport const shopSchedulesRelations = relations(shopSchedules, ({ one }) => ({\n  shop: one(shops, {\n    fields: [shopSchedules.shopId],\n    references: [shops.id],\n  }),\n}));\n\nexport const shopFollowers = pgTable(\"shop_followers\", {\n  ...commonColumns,\n  shopId: uuid(\"shop_id\")\n    .references(() => shops.id)\n    .notNull(),\n  customerId: uuid(\"customer_id\")\n    .references(() => profiles.id)\n    .notNull(),\n}, (table) => [\n  index(\"shop_followers_shop_id_idx\").on(table.shopId),\n  index(\"shop_followers_customer_id_idx\").on(table.customerId),\n  uniqueIndex(\"shop_followers_shop_customer_uniq_idx\").on(\n    table.shopId,\n    table.customerId,\n  ),\n]);\n\n// Add relation for shop followers\nexport const shopFollowersRelations = relations(shopFollowers, ({ one }) => ({\n  shop: one(shops, {\n    fields: [shopFollowers.shopId],\n    references: [shops.id],\n  }),\n  customer: one(profiles, {\n    fields: [shopFollowers.customerId],\n    references: [profiles.id],\n  }),\n}));\n```\n\nbase on the schema there is index for ownerProfileId and slug\ndo you think it's good to make this method more flexible like it can also query by ownerProfileId and slug, ownerProfileId, slug, or a combination of them?\nim thinking of renaming the method to findFirst instead so it is more generic and flexible what do you think?\nif you have suggestion, please let me know\nYes, that's a good idea! Here's the improved version that's more flexible:\n\n```ts\nstatic async findFirst(\n  where: {\n    id?: string;\n    ownerProfileId?: string;\n    slug?: string;\n  },\n  options: {\n    includeAddresses?: boolean;\n    includeSchedules?: boolean;\n    columns?: ShopColumns[] | \"*\";\n  } = {},\n) {\n  const {\n    includeAddresses = false,\n    includeSchedules = false,\n    columns = \"*\",\n  } = options;\n\n  const conditions = [\n    where.id && eq(shops.id, where.id),\n    where.ownerProfileId && eq(shops.ownerProfileId, where.ownerProfileId),\n    where.slug && eq(shops.slug, where.slug),\n  ].filter(Boolean);\n\n  if (conditions.length === 0) {\n    throw new Error(\"At least one where condition is required\");\n  }\n\n  const shop = await db.query.shops.findFirst({\n    where: conditions.length === 1 ? conditions[0] : and(...conditions),\n    columns: columns === \"*\"\n      ? undefined\n      : Object.fromEntries(columns.map((col) => [col, true])),\n    with: {\n      ...(includeAddresses && { shopAddresses: true }),\n      ...(includeSchedules && { schedules: true }),\n    },\n  });\n\n  return shop;\n}\n```\n\nAdditional suggestions:\n1. Add a findMany method with similar flexibility\n2. Consider adding sorting and pagination options\n3. Add a type for the where conditions to make it more maintainable:\n\n```ts\ntype ShopWhereInput = {\n  id?: string;\n  ownerProfileId?: string;\n  slug?: string;\n};\n```\n\nThe renamed method is better because:\n- More consistent with database terminology\n- Better reflects what the method actually does\n- More flexible for future extensions\n- Can be used as building block for other methods\n\nSources:\n- Drizzle ORM documentation\n- Common REST API patterns\n- Database indexing best practices\n```ts lokal-link-be/src/features/shops/services/shops.services.ts:45-45\n// Excerpt from: class ShopsService > static async findFirst( )\n  where: conditions.length === 1 ? conditions[0] : and(...conditions),\n```\ndeno-ts: Argument of type '\"\" | SQL<unknown> | undefined' is not assignable to parameter of type 'SQLWrapper | undefined'.\n  Type 'string' is not assignable to type 'SQLWrapper'.\n  deno-ts: Type '\"\" | SQL<unknown> | undefined' is not assignable to type 'SQL<unknown> | ((fields: { name: PgColumn<{ name: \"name\"; tableName: \"shops\"; dataType: \"string\"; columnType: \"PgVarchar\"; data: string; driverParam: string; notNull: true; hasDefault: false; isPrimaryKey: false; ... 5 more ...; generated: undefined; }, {}, { ...; }>; ... 7 more ...; updatedAt: PgColumn<...>; }, ope...'.\n    Type '\"\"' is not assignable to type 'SQL<unknown> | ((fields: { name: PgColumn<{ name: \"name\"; tableName: \"shops\"; dataType: \"string\"; columnType: \"PgVarchar\"; data: string; driverParam: string; notNull: true; hasDefault: false; isPrimaryKey: false; ... 5 more ...; generated: undefined; }, {}, { \ngot this error can you fix this\n\nYes, here's the fixed version - we need to import `and` from drizzle-orm and ensure conditions only contains SQL expressions:\n\n```ts\nimport { and, eq } from \"drizzle-orm\";\n\nstatic async findFirst(\n  where: {\n    id?: string;\n    ownerProfileId?: string;\n    slug?: string;\n  },\n  options: {\n    includeAddresses?: boolean;\n    includeSchedules?: boolean;\n    columns?: ShopColumns[] | \"*\";\n  } = {},\n) {\n  const {\n    includeAddresses = false,\n    includeSchedules = false,\n    columns = \"*\",\n  } = options;\n\n  const conditions = [\n    where.id ? eq(shops.id, where.id) : null,\n    where.ownerProfileId ? eq(shops.ownerProfileId, where.ownerProfileId) : null,\n    where.slug ? eq(shops.slug, where.slug) : null,\n  ].filter((condition): condition is SQL<unknown> => condition !== null);\n\n  if (conditions.length === 0) {\n    throw new Error(\"At least one where condition is required\");\n  }\n\n  const shop = await db.query.shops.findFirst({\n    where: conditions.length === 1 ? conditions[0] : and(...conditions),\n    columns: columns === \"*\"\n      ? undefined\n      : Object.fromEntries(columns.map((col) => [col, true])),\n    with: {\n      ...(includeAddresses && { shopAddresses: true }),\n      ...(includeSchedules && { schedules: true }),\n    },\n  });\n\n  return shop;\n}\n```\n\nThe key changes:\n1. Added type assertion to filter to ensure only SQL conditions remain\n2. Changed the condition creation to return null instead of undefined\n3. Imported `and` from drizzle-orm\nis that the best practice to query the index?\nFor best practices with indexed queries in Drizzle, we should structure the where conditions to take maximum advantage of the composite indexes. Here's an optimized version:\n\n```ts\nimport { and, eq } from \"drizzle-orm\";\n\nstatic async findFirst(\n  where: {\n    id?: string;\n    ownerProfileId?: string;\n    slug?: string;\n  },\n  options: {\n    includeAddresses?: boolean;\n    includeSchedules?: boolean;\n    columns?: ShopColumns[] | \"*\";\n  } = {},\n) {\n  // First try to use unique indexes (faster lookups)\n  if (where.id) {\n    return this.findByPrimaryKey(where.id, options);\n  }\n  \n  if (where.slug) {\n    return this.findByUniqueIndex(where.slug, options);\n  }\n\n  // Then fall back to regular indexes\n  if (where.ownerProfileId) {\n    return this.findByOwnerProfileId(where.ownerProfileId, options);\n  }\n\n  throw new Error(\"At least one where condition is required\");\n}\n\nprivate static async findByPrimaryKey(id: string, options: QueryOptions) {\n  return db.query.shops.findFirst({\n    where: eq(shops.id, id),\n    ...this.buildQueryOptions(options),\n  });\n}\n\nprivate static async findByUniqueIndex(slug: string, options: QueryOptions) {\n  return db.query.shops.findFirst({\n    where: eq(shops.slug, slug),\n    ...this.buildQueryOptions(options),\n  });\n}\n\nprivate static async findByOwnerProfileId(ownerProfileId: string, options: QueryOptions) {\n  return db.query.shops.findFirst({\n    where: eq(shops.ownerProfileId, ownerProfileId),\n    ...this.buildQueryOptions(options),\n  });\n}\n\nprivate static buildQueryOptions(options: QueryOptions) {\n  const {\n    includeAddresses = false,\n    includeSchedules = false,\n    columns = \"*\",\n  } = options;\n\n  return {\n    columns: columns === \"*\"\n      ? undefined\n      : Object.fromEntries(columns.map((col) => [col, true])),\n    with: {\n      ...(includeAddresses && { shopAddresses: true }),\n      ...(includeSchedules && { schedules: true }),\n    },\n  };\n}\n```\n\nThis approach is better because:\n1. Prioritizes unique indexes (PK and slug) for fastest lookups\n2. Separates different index lookups for better query plan optimization\n3. Easier to maintain and add new indexed queries\n4. DRYer code by extracting common query options\n5. More explicit about which index is being used\n\nFor compound queries (multiple conditions), you might want to add specific methods if they're commonly used together and have corresponding composite indexes.\ncan you generate the QueryOptions type \n```ts\ntype QueryOptions = {\n  includeAddresses?: boolean;\n  includeSchedules?: boolean;\n  columns?: ShopColumns[] | \"*\";\n};\n```\n\nUsage:\n\n```ts\nimport { and, eq } from \"drizzle-orm\";\n\ntype QueryOptions = {\n  includeAddresses?: boolean;\n  includeSchedules?: boolean;\n  columns?: ShopColumns[] | \"*\";\n};\n\nstatic async findFirst(\n  where: {\n    id?: string;\n    ownerProfileId?: string;\n    slug?: string;\n  },\n  options: QueryOptions = {},\n) {\n  // ... rest of the code\n}\n```\n\nSince you're using TypeScript, you might also want to add the return type:\n\n```ts\ntype ShopWithRelations = typeof shops.$inferSelect & {\n  shopAddresses?: typeof shopAddresses.$inferSelect[];\n  schedules?: typeof shopSchedules.$inferSelect[];\n};\n\nstatic async findFirst(\n  where: {\n    id?: string;\n    ownerProfileId?: string;\n    slug?: string;\n  },\n  options: QueryOptions = {},\n): Promise<ShopWithRelations | null> {\n  // ... rest of the code\n}\n```\n```ts lokal-link-be/src/features/shops/services/shops.services.ts:47-52\n// Excerpt from: class ShopsService\n private static async findByPrimaryKey(id: string, options: QueryOptions) {\n    return await db.query.shops.findFirst({\n      where: eq(shops.id, id),\n      ...this.buildQueryOptions(options),\n    });\n  }\n```\ndeno-ts: Argument of type '{ columns: { [k: string]: boolean; } | undefined; with: { schedules?: boolean | undefined; shopAddresses?: boolean | undefined; }; where: SQL<unknown>; }' is not assignable to parameter of type 'KnownKeysOnly<Omit<DBQueryConfig<\"many\", true, ExtractTablesWithRelations<typeof import(\"file:///Users/glendell/projects/personal/lokal-link-be/src/db/schema/index\")>, { ...; }>, \"limit\">, Omit<...>>'.\n  The types of 'with.shopAddresses' are incompatible between these types.\n    Type 'boolean | undefined' is not assignable to type 'true | DBQueryConfig<\"many\", false, ExtractTablesWithRelations<typeof import(\"file:///Users/glendell/projects/personal/lokal-link-be/src/db/schema/index\")>, { ...; }> | undefined'.\n      Type 'false' is not assignable to type 'true | DBQueryConfig<\"many\", false, ExtractTablesWithRelations<typeof import(\"file:///Users/glendell/projects/personal/lokal-link-be/src/db/schema/index\")>, { ...; }> | undefined'.\ngot this error can you fix t his\n\nThe issue is with the `with` type in the query options. For Drizzle, we need to specify the correct type for relations. Here's the fixed version:\n\n```ts\nimport { and, eq } from \"drizzle-orm\";\n\ntype QueryOptions = {\n  includeAddresses?: boolean;\n  includeSchedules?: boolean;\n  columns?: ShopColumns[] | \"*\";\n};\n\nprivate static buildQueryOptions(options: QueryOptions) {\n  const {\n    includeAddresses = false,\n    includeSchedules = false,\n    columns = \"*\",\n  } = options;\n\n  return {\n    columns: columns === \"*\"\n      ? undefined\n      : Object.fromEntries(columns.map((col) => [col, true])),\n    with: {\n      ...(includeAddresses ? { shopAddresses: true as const } : {}),\n      ...(includeSchedules ? { schedules: true as const } : {}),\n    },\n  };\n}\n\nprivate static async findByPrimaryKey(id: string, options: QueryOptions) {\n  return db.query.shops.findFirst({\n    where: eq(shops.id, id),\n    ...this.buildQueryOptions(options),\n  });\n}\n```\n\nThe key fix is using `true as const` instead of just `true` for the relations. This ensures TypeScript knows we're using the correct literal type that Drizzle expects.\n```ts lokal-link-be/src/features/shops/services/shops.services.ts\nimport { eq, Query } from \"drizzle-orm\";\nimport { shops } from \"@/db/schema/shops.schema.ts\";\nimport { db } from \"@/db/index.ts\";\nimport { ShopColumns, ShopInsert } from \"@/features/shops/shops.types.ts\";\n\ntype QueryOptions = {\n  includeAddresses?: boolean;\n  includeSchedules?: boolean;\n  columns?: ShopColumns[] | \"*\";\n};\n\nexport class ShopsService {\n  static async create(input: ShopInsert, tx = db) {\n    const [shop] = await tx\n      .insert(shops)\n      .values(input)\n      .returning();\n\n    return shop;\n  }\n\n  static async findFirst(\n    where: {\n      id?: string;\n      ownerProfileId?: string;\n      slug?: string;\n    },\n    options: QueryOptions = {},\n  ) {\n    // First try to use unique indexes (faster lookups)\n    if (where.id) {\n      return await this.findByPrimaryKey(where.id, options);\n    }\n\n    if (where.slug) {\n      return await this.findByUniqueIndex(where.slug, options);\n    }\n\n    // Then fall back to regular indexes\n    if (where.ownerProfileId) {\n      return await this.findByOwnerProfileId(where.ownerProfileId, options);\n    }\n\n    throw new Error(\"At least one where condition is required\");\n  }\n\n  private static async findByPrimaryKey(id: string, options: QueryOptions) {\n    return await db.query.shops.findFirst({\n      where: eq(shops.id, id),\n      ...this.buildQueryOptions(options),\n    });\n  }\n\n  private static async findByUniqueIndex(slug: string, options: QueryOptions) {\n    return await db.query.shops.findFirst({\n      where: eq(shops.slug, slug),\n      ...this.buildQueryOptions(options),\n    });\n  }\n\n  private static async findByOwnerProfileId(\n    ownerProfileId: string,\n    options: QueryOptions,\n  ) {\n    return await db.query.shops.findFirst({\n      where: eq(shops.ownerProfileId, ownerProfileId),\n      ...this.buildQueryOptions(options),\n    });\n  }\n\n  private static buildQueryOptions(options: QueryOptions) {\n    const {\n      includeAddresses = false,\n      includeSchedules = false,\n      columns = \"*\",\n    } = options;\n\n    return {\n      columns: columns === \"*\"\n        ? undefined\n        : Object.fromEntries(columns.map((col) => [col, true])),\n      with: {\n        ...(includeAddresses ? { shopAddresses: true as const } : {}),\n        ...(includeSchedules ? { schedules: true as const } : {}),\n      },\n    };\n  }\n}\n```\n\nquestion for the findFirst","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1309}}},{"id":{"replica_id":0,"value":72},"start":6882,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1310}}},{"id":{"replica_id":0,"value":147},"start":7038,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1311}}},{"id":{"replica_id":0,"value":247},"start":7148,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1312}}},{"id":{"replica_id":0,"value":276},"start":7191,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1313}}},{"id":{"replica_id":0,"value":277},"start":8915,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1314}}},{"id":{"replica_id":0,"value":362},"start":9305,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1315}}},{"id":{"replica_id":0,"value":383},"start":10005,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1316}}},{"id":{"replica_id":0,"value":473},"start":10038,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1317}}},{"id":{"replica_id":0,"value":474},"start":11508,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1318}}},{"id":{"replica_id":0,"value":706},"start":11554,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1319}}},{"id":{"replica_id":0,"value":707},"start":13942,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1320}}},{"id":{"replica_id":0,"value":889},"start":13982,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1321}}},{"id":{"replica_id":0,"value":890},"start":14909,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1322}}},{"id":{"replica_id":0,"value":966},"start":16190,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1323}}},{"id":{"replica_id":0,"value":1064},"start":16224,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1324}}},{"id":{"replica_id":0,"value":1065},"start":17342,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1325}}}],"summary":"Flexible Shop Query Method Enhancement","slash_command_output_sections":[{"range":{"start":0,"end":1276},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1275},"icon":"Library","label":"General","metadata":null},{"range":{"start":1277,"end":2428},"icon":"File","label":"lokal-link-be/src/features/shops/services/shops.services.ts","metadata":{"path":"lokal-link-be/src/features/shops/services/shops.services.ts"}},{"range":{"start":2429,"end":3189},"icon":"TextSnippet","label":"lokal-link-be/src/features/shops/services/shops.services.ts, Lines 20 to 46","metadata":null},{"range":{"start":3190,"end":6819},"icon":"File","label":"lokal-link-be/src/db/schema/shops.schema.ts","metadata":{"path":"lokal-link-be/src/db/schema/shops.schema.ts"}},{"range":{"start":8915,"end":9125},"icon":"TextSnippet","label":"lokal-link-be/src/features/shops/services/shops.services.ts, Line 45","metadata":null},{"range":{"start":14909,"end":15225},"icon":"TextSnippet","label":"lokal-link-be/src/features/shops/services/shops.services.ts, Lines 47 to 52","metadata":null},{"range":{"start":17342,"end":19708},"icon":"File","label":"lokal-link-be/src/features/shops/services/shops.services.ts","metadata":{"path":"lokal-link-be/src/features/shops/services/shops.services.ts"}}]}
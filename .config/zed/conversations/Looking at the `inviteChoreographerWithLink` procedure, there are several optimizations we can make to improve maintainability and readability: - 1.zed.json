{"id":"f6a6455e-39d8-400e-917b-53fea8bf7c35","zed":"context","version":"0.4.0","text":"\nDO NOT GIVE ME HIGH-LEVEL THEORY. IF I ASK FOR A FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT \"Here's how you can blablabla\"\n\nBe casual unless otherwise specified\nBe terse and concise\nSuggest solutions that I didn’t think about—anticipate my needs\nTreat me as an expert\nBe accurate and thorough\nGive the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer\nValue good arguments over authorities, the source is irrelevant\nConsider new technologies and contrarian ideas, not just conventional wisdom\nYou may use high levels of speculation or prediction, just flag it for me\nNo moral lectures\nDiscuss safety only when it's crucial and non-obvious\nIf your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward\nCite sources whenever possible at the end, not inline\nNo need to mention your knowledge cutoff\nNo need to disclose you're an AI\nPlease respect my prettier preferences when you provide code\nSplit into multiple responses if one response isn't enough to answer the question\nFocus on readability over being performant\nFully implement all requested functionality\nLeave NO todos, placeholders, or missing pieces\n…\n\n\n    You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (e.g., Tailwind CSS, Shadcn UI, Radix UI). Your task is to produce the most optimized and maintainable Next.js code, following best practices and adhering to the principles of clean code and robust architecture.\n    \n        ### Objective\n        - Create a Next.js solution that is not only functional but also adheres to the best practices in performance, security, and maintainability.\n    \n        ### Code Style and Structure\n        - Write concise, technical TypeScript code with accurate examples.\n        - Use functional and declarative programming patterns; avoid classes.\n        - Favor iteration and modularization over code duplication.\n        - Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).\n        - Structure files with exported components, subcomponents, helpers, static content, and types.\n        - Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).\n    \n        ### Optimization and Best Practices\n        - Minimize the use of `'use client'`, `useEffect`, and `setState`; favor React Server Components (RSC) and Next.js SSR features.\n        - Implement dynamic imports for code splitting and optimization.\n        - Use responsive design with a mobile-first approach.\n        - Optimize images: use WebP format, include size data, implement lazy loading.\n    \n        ### Error Handling and Validation\n        - Prioritize error handling and edge cases:\n          - Use early returns for error conditions.\n          - Implement guard clauses to handle preconditions and invalid states early.\n          - Use custom error types for consistent error handling.\n    \n        ### UI and Styling\n        - Use modern UI frameworks (e.g., Tailwind CSS, Shadcn UI, Radix UI) for styling.\n        - Implement consistent design and responsive patterns across platforms.\n    \n        ### State Management and Data Fetching\n        - Use modern state management solutions (e.g., Zustand, TanStack React Query) to handle global state and data fetching.\n        - Implement validation using Zod for schema validation.\n    \n        ### Security and Performance\n        - Implement proper error handling, user input validation, and secure coding practices.\n        - Follow performance optimization techniques, such as reducing load times and improving rendering efficiency.\n    \n        ### Testing and Documentation\n        - Write unit tests for components using Jest and React Testing Library.\n        - Provide clear and concise comments for complex logic.\n        - Use JSDoc comments for functions and components to improve IDE intellisense.\n    \n        ### Methodology\n        1. **System 2 Thinking**: Approach the problem with analytical rigor. Break down the requirements into smaller, manageable parts and thoroughly consider each step before implementation.\n        2. **Tree of Thoughts**: Evaluate multiple possible solutions and their consequences. Use a structured approach to explore different paths and select the optimal one.\n        3. **Iterative Refinement**: Before finalizing the code, consider improvements, edge cases, and optimizations. Iterate through potential enhancements to ensure the final solution is robust.\n    \n        **Process**:\n        1. **Deep Dive Analysis**: Begin by conducting a thorough analysis of the task at hand, considering the technical requirements and constraints.\n        2. **Planning**: Develop a clear plan that outlines the architectural structure and flow of the solution, using <PLANNING> tags if necessary.\n        3. **Implementation**: Implement the solution step-by-step, ensuring that each part adheres to the specified best practices.\n        4. **Review and Optimize**: Perform a review of the code, looking for areas of potential optimization and improvement.\n        5. **Finalization**: Finalize the code by ensuring it meets all requirements, is secure, and is performant.\n        \n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\nimport { createJWT, verifyJWT } from \"~/lib/jwt\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographerWithLink: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Create the Supabase admin client\n        const supabase = await createClient({ isAdmin: true });\n\n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n\n        // Filter users manually to find by email\n        const matchingUsers =\n          data?.users?.filter(\n            (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n          ) || [];\n\n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n\n        // Check for existing member with this email at this studio\n        const existingMember =\n          userIds.length > 0\n            ? await ctx.db.studioMember.findFirst({\n                where: {\n                  studio: {\n                    id: input.studioId,\n                  },\n                  profile: {\n                    authId: {\n                      in: userIds,\n                    },\n                  },\n                },\n              })\n            : null;\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This user is already a member of this studio\",\n          });\n        }\n\n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          // Create a secure JWT token for the existing invitation\n          const token = await createJWT({\n            id: existingInvitation.id,\n            email: input.email,\n            studioId: input.studioId,\n            role: existingInvitation.role,\n            type: \"studio-invitation\",\n          });\n\n          return {\n            status: \"already_invited\",\n            invitation: existingInvitation,\n            inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${existingInvitation.role}&token=${token}`,\n          };\n        }\n\n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        // ctx.profile is guaranteed to exist in adminProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx?.profile?.id ?? \"\", // adminProcedure ensures this exists\n            expiresAt: expirationDate,\n            status: \"PENDING\",\n          },\n        });\n\n        // Create a secure JWT token using the jwt.ts utilities\n        const token = await createJWT({\n          id: invitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role: input.role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"invited\",\n          invitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}&token=${token}`,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to generate invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  validateInvitation: publicProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            studio: true,\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        return {\n          valid: true,\n          invitation: {\n            ...invitation,\n            studio: enhanceStudioWithLocationNames(invitation.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Validate invitation error:\", error);\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Update acceptInvitationWithLink procedure\n  acceptInvitationWithLink: authedProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n              role: invitation.role,\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n```ts dance-book-app/src/server/api/routers/studio.ts:634-754\n// Excerpt from: const studioRouter\n inviteChoreographerWithLink: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Create the Supabase admin client\n        const supabase = await createClient({ isAdmin: true });\n\n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n\n        // Filter users manually to find by email\n        const matchingUsers =\n          data?.users?.filter(\n            (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n          ) || [];\n\n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n\n        // Check for existing member with this email at this studio\n        const existingMember =\n          userIds.length > 0\n            ? await ctx.db.studioMember.findFirst({\n                where: {\n                  studio: {\n                    id: input.studioId,\n                  },\n                  profile: {\n                    authId: {\n                      in: userIds,\n                    },\n                  },\n                },\n              })\n            : null;\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This user is already a member of this studio\",\n          });\n        }\n\n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          // Create a secure JWT token for the existing invitation\n          const token = await createJWT({\n            id: existingInvitation.id,\n            email: input.email,\n            studioId: input.studioId,\n            role: existingInvitation.role,\n            type: \"studio-invitation\",\n          });\n\n          return {\n            status: \"already_invited\",\n            invitation: existingInvitation,\n            inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${existingInvitation.role}&token=${token}`,\n          };\n        }\n\n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        // ctx.profile is guaranteed to exist in adminProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx?.profile?.id ?? \"\", // adminProcedure ensures this exists\n            expiresAt: expirationDate,\n            status: \"PENDING\",\n          },\n        });\n\n        // Create a secure JWT token using the jwt.ts utilities\n        const token = await createJWT({\n          id: invitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role: input.role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"invited\",\n          invitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}&token=${token}`,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to generate invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n```\nthe codes are long so we  will code it in parts\nthis is a working code so please do not broke it\nanalyze the code and logic.\nyour task is to optimize the code and make it more maintainable and readable.\nfirst is lets update the inviteChoreographerWithLink. i think role should not be here since this is invite choreographer the role should be fixed to choreographer. \n2. the inviteLink query params should only be token we should put the data in the token.\nI'll optimize the `inviteChoreographerWithLink` procedure by fixing the role to CHOREOGRAPHER and improving the token handling. Here's the updated code:\n\n```ts\ninviteChoreographerWithLink: authedProcedure\n  .input(\n    z.object({\n      studioId: z.string().uuid(),\n      email: z.string().email(),\n    }),\n  )\n  .mutation(async ({ ctx, input }) => {\n    try {\n      // Create the Supabase admin client\n      const supabase = await createClient({ isAdmin: true });\n\n      // Check if the email belongs to a registered user\n      const { data } = await supabase.auth.admin.listUsers();\n\n      // Filter users manually to find by email\n      const matchingUsers =\n        data?.users?.filter(\n          (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n        ) || [];\n\n      // Get user IDs if they exist\n      const userIds = matchingUsers.map((user) => user.id);\n\n      // Check for existing member with this email at this studio\n      const existingMember =\n        userIds.length > 0\n          ? await ctx.db.studioMember.findFirst({\n              where: {\n                studio: {\n                  id: input.studioId,\n                },\n                profile: {\n                  authId: {\n                    in: userIds,\n                  },\n                },\n              },\n            })\n          : null;\n\n      if (existingMember) {\n        throw new TRPCError({\n          code: \"CONFLICT\",\n          message: \"This user is already a member of this studio\",\n        });\n      }\n\n      // Check for existing pending invitation\n      const existingInvitation = await ctx.db.studioInvitation.findFirst({\n        where: {\n          email: input.email,\n          studioId: input.studioId,\n          status: \"PENDING\",\n        },\n      });\n\n      if (existingInvitation) {\n        // Create a secure JWT token for the existing invitation\n        const token = await createJWT({\n          id: existingInvitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role: existingInvitation.role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"already_invited\",\n          invitation: existingInvitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n        };\n      }\n\n      // Store the invitation in the database with expiration (30 days)\n      const expirationDate = new Date();\n      expirationDate.setDate(expirationDate.getDate() + 30);\n\n      // Fixed role to CHOREOGRAPHER\n      const role = \"CHOREOGRAPHER\";\n\n      // ctx.profile is guaranteed to exist in authedProcedure\n      const invitation = await ctx.db.studioInvitation.create({\n        data: {\n          email: input.email,\n          studioId: input.studioId,\n          role,\n          invitedById: ctx.profile.id,\n          expiresAt: expirationDate,\n          status: \"PENDING\",\n        },\n      });\n\n      // Create a secure JWT token with all needed data\n      const token = await createJWT({\n        id: invitation.id,\n        email: input.email,\n        studioId: input.studioId,\n        role,\n        type: \"studio-invitation\",\n      });\n\n      return {\n        status: \"invited\",\n        invitation,\n        inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Invite choreographer error:\", error);\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to generate invitation link\",\n        cause: error,\n      });\n    }\n  }),\n```\n\nKey changes made:\n1. Removed the role field from the input schema since we're fixing it to CHOREOGRAPHER\n2. Added a constant `role = \"CHOREOGRAPHER\"` for clarity\n3. Simplified the inviteLink URL to only include the token parameter\n4. Ensured all necessary data is included in the JWT token\n5. Fixed ctx.profile.id access (removed unnecessary null check since authedProcedure guarantees it exists)\n\nThis makes the code more focused on its specific purpose (inviting choreographers), removes unnecessary parameters, and improves security by putting all data in the token rather than in URL query parameters.\nnext task is to verify that the validateInvitation is working properly. \n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\nimport { createJWT, verifyJWT } from \"~/lib/jwt\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographerWithLink: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Create the Supabase admin client\n        const supabase = await createClient({ isAdmin: true });\n\n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n\n        // Filter users manually to find by email\n        const matchingUsers =\n          data?.users?.filter(\n            (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n          ) || [];\n\n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n\n        // Check for existing member with this email at this studio\n        const existingMember =\n          userIds.length > 0\n            ? await ctx.db.studioMember.findFirst({\n                where: {\n                  studio: {\n                    id: input.studioId,\n                  },\n                  profile: {\n                    authId: {\n                      in: userIds,\n                    },\n                  },\n                },\n              })\n            : null;\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This user is already a member of this studio\",\n          });\n        }\n\n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          // Create a secure JWT token for the existing invitation\n          const token = await createJWT({\n            id: existingInvitation.id,\n            email: input.email,\n            studioId: input.studioId,\n            role: existingInvitation.role,\n            type: \"studio-invitation\",\n          });\n\n          return {\n            status: \"already_invited\",\n            invitation: existingInvitation,\n            inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n          };\n        }\n\n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        // Fixed role to CHOREOGRAPHER\n        const role = \"CHOREOGRAPHER\";\n\n        // ctx.profile is guaranteed to exist in authedProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role,\n            invitedById: ctx.profile.id,\n            expiresAt: expirationDate,\n            status: \"PENDING\",\n          },\n        });\n\n        // Create a secure JWT token with all needed data\n        const token = await createJWT({\n          id: invitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"invited\",\n          invitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to generate invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  validateInvitation: publicProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            studio: true,\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        return {\n          valid: true,\n          invitation: {\n            ...invitation,\n            studio: enhanceStudioWithLocationNames(invitation.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Validate invitation error:\", error);\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Update acceptInvitationWithLink procedure\n  acceptInvitationWithLink: authedProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n              role: invitation.role,\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n\nLooking at the `validateInvitation` procedure, it appears mostly correct, but could use some improvements in error handling and data validation. Here's my optimized version:\n\n```ts\nvalidateInvitation: publicProcedure\n  .input(\n    z.object({\n      token: z.string().min(1, \"Token is required\"),\n    }),\n  )\n  .query(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      // Early return for invalid token data\n      if (!tokenData) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation token\",\n        });\n      }\n\n      // Validate token contents\n      if (\n        typeof tokenData.id !== \"string\" || \n        typeof tokenData.studioId !== \"string\" || \n        tokenData.type !== \"studio-invitation\"\n      ) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation format\",\n        });\n      }\n\n      // Find the invitation with related studio data\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n          status: \"PENDING\",\n        },\n        include: {\n          studio: true,\n          invitedBy: true, // Include who sent the invitation\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        // Mark as expired in database\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      // Return validated invitation with enhanced studio data\n      return {\n        valid: true,\n        invitation: {\n          ...invitation,\n          studio: enhanceStudioWithLocationNames(invitation.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Validate invitation error:\", error);\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation link\",\n      });\n    }\n  }),\n```\n\nKey improvements:\n1. Added validation for the token input using `min(1)` to ensure it's not empty\n2. Improved type checking with separate validation for each required property\n3. Added more specific error messages for different validation failures\n4. Added `invitedBy` to the query to provide information about who sent the invitation\n5. More robust error handling with specific error codes\n6. Cleaner code structure with early returns for invalid states\n\nThis implementation ensures that the token is properly validated before checking the database, and provides clearer error messages when something goes wrong.\n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\nimport { createJWT, verifyJWT } from \"~/lib/jwt\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographerWithLink: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Create the Supabase admin client\n        const supabase = await createClient({ isAdmin: true });\n\n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n\n        // Filter users manually to find by email\n        const matchingUsers =\n          data?.users?.filter(\n            (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n          ) || [];\n\n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n\n        // Check for existing member with this email at this studio\n        const existingMember =\n          userIds.length > 0\n            ? await ctx.db.studioMember.findFirst({\n                where: {\n                  studio: {\n                    id: input.studioId,\n                  },\n                  profile: {\n                    authId: {\n                      in: userIds,\n                    },\n                  },\n                },\n              })\n            : null;\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This user is already a member of this studio\",\n          });\n        }\n\n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          // Create a secure JWT token for the existing invitation\n          const token = await createJWT({\n            id: existingInvitation.id,\n            email: input.email,\n            studioId: input.studioId,\n            role: existingInvitation.role,\n            type: \"studio-invitation\",\n          });\n\n          return {\n            status: \"already_invited\",\n            invitation: existingInvitation,\n            inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n          };\n        }\n\n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        // Fixed role to CHOREOGRAPHER\n        const role = \"CHOREOGRAPHER\";\n\n        // ctx.profile is guaranteed to exist in authedProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role,\n            invitedById: ctx.profile.id,\n            expiresAt: expirationDate,\n            status: \"PENDING\",\n          },\n        });\n\n        // Create a secure JWT token with all needed data\n        const token = await createJWT({\n          id: invitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"invited\",\n          invitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to generate invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  validateInvitation: publicProcedure\n    .input(\n      z.object({\n        token: z.string().min(1, \"Token is required\"),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        // Early return for invalid token data\n        if (!tokenData) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation token\",\n          });\n        }\n\n        // Validate token contents\n        if (\n          typeof tokenData.id !== \"string\" ||\n          typeof tokenData.studioId !== \"string\" ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation format\",\n          });\n        }\n\n        // Find the invitation with related studio data\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            studio: true,\n            invitedBy: true, // Include who sent the invitation\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          // Mark as expired in database\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        // Return validated invitation with enhanced studio data\n        return {\n          valid: true,\n          invitation: {\n            ...invitation,\n            studio: enhanceStudioWithLocationNames(invitation.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Validate invitation error:\", error);\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n    }),\n\n  // Update acceptInvitationWithLink procedure\n  acceptInvitationWithLink: authedProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n              role: invitation.role,\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\nyou next task is to validate if the acceptInvitationWithLink procedure is implemented correctly.\nLooking at the `acceptInvitationWithLink` procedure, it's generally well-structured but could use some improvements for better error handling, consistency, and maintainability. Here's my analysis and optimized version:\n\n```ts\nacceptInvitationWithLink: authedProcedure\n  .input(\n    z.object({\n      token: z.string().min(1, \"Token is required\"),\n    }),\n  )\n  .mutation(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      // Early return for invalid token data\n      if (!tokenData) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation token\",\n        });\n      }\n\n      // Validate token contents\n      if (\n        typeof tokenData.id !== \"string\" || \n        typeof tokenData.studioId !== \"string\" || \n        tokenData.type !== \"studio-invitation\"\n      ) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation format\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n          status: \"PENDING\",\n        },\n        include: {\n          studio: true,\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      // Check if user is already a member\n      const existingMembership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: invitation.studioId,\n          },\n        },\n        include: {\n          studio: true,\n        },\n      });\n\n      if (existingMembership) {\n        // Update invitation status\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { \n            status: \"ACCEPTED\", \n            acceptedAt: new Date(),\n            acceptedById: ctx.profile.id,\n          },\n        });\n\n        return {\n          status: \"already_member\",\n          membership: {\n            ...existingMembership,\n            studio: enhanceStudioWithLocationNames(existingMembership.studio),\n          },\n        };\n      }\n\n      // Create new membership in a transaction\n      const result = await ctx.db.$transaction(async (tx) => {\n        // Add user to studio\n        const membership = await tx.studioMember.create({\n          data: {\n            profileId: ctx.profile.id,\n            studioId: invitation.studioId,\n            role: invitation.role,\n          },\n          include: {\n            studio: true,\n            profile: true,\n          },\n        });\n\n        // Update invitation status\n        await tx.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { \n            status: \"ACCEPTED\",\n            acceptedAt: new Date(),\n            acceptedById: ctx.profile.id,\n          },\n        });\n\n        return membership;\n      });\n\n      return {\n        status: \"accepted\",\n        membership: {\n          ...result,\n          studio: enhanceStudioWithLocationNames(result.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Accept invitation error:\", error);\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to accept invitation\",\n        cause: error,\n      });\n    }\n  }),\n```\n\nKey improvements:\n\n1. **Better token validation**: Added more robust token validation with separate checks and early returns.\n\n2. **Consistent error handling**: Added early returns for invalid states and improved error messages.\n\n3. **Enhanced tracking**: Added `acceptedAt` and `acceptedById` when updating the invitation status to better track who accepted the invitation and when.\n\n4. **Enhanced result formatting**: Made sure to apply `enhanceStudioWithLocationNames` to the studio data in the existing membership case too.\n\n5. **Error logging**: Added error logging with a descriptive message to help with debugging.\n\n6. **Input validation**: Added `.min(1)` to ensure the token is not empty.\n\n7. **Type checking**: Added more explicit type checking for token data properties.\n\n8. **Consistent structure**: Made the structure more similar to the `validateInvitation` method for maintainability.\n\nThese changes ensure the procedure correctly validates and processes invitation acceptance while maintaining better tracking data and providing more meaningful error responses.\n```tsx dance-book-app/src/app/(private)/profile/choreographers-form.tsx\n\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { z } from \"zod\";\nimport { Loader2, Mail, Plus, Sparkles, Copy, CheckCircle } from \"lucide-react\";\nimport { api } from \"~/trpc/react\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTrigger,\n} from \"~/components/ui/dialog\";\nimport {\n  Drawer,\n  DrawerContent,\n  DrawerTrigger,\n  DrawerHeader,\n  DrawerTitle,\n} from \"~/components/ui/drawer\";\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"~/components/ui/form\";\nimport { Input } from \"~/components/ui/input\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { useIsMobile } from \"~/hooks/use-mobile\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { DialogTitle } from \"@radix-ui/react-dialog\";\n\n// Simplified schema - only email, no role needed\nconst choreographerInviteSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n});\n\ntype ChoreographerInviteValues = z.infer<typeof choreographerInviteSchema>;\n\nconst defaultValues: ChoreographerInviteValues = {\n  email: \"\",\n};\n\ninterface ChoreographerInviteDialogProps {\n  studioId: string;\n  studioSlug: string;\n  buttonLabel?: string;\n  buttonClassName?: string;\n  variant?: \"default\" | \"outline\" | \"secondary\" | \"ghost\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n}\n\nexport function ChoreographerInviteDialog({\n  studioId,\n  studioSlug,\n  buttonLabel = \"Add Choreographer\",\n  buttonClassName = \"\",\n  variant = \"default\",\n  size = \"default\",\n}: ChoreographerInviteDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [formSubmitted, setFormSubmitted] = useState(false);\n  const [inviteLink, setInviteLink] = useState<string | null>(null);\n  const [copied, setCopied] = useState(false);\n  const isMobile = useIsMobile();\n  const isDesktop = !isMobile;\n\n  const form = useForm<ChoreographerInviteValues>({\n    resolver: zodResolver(choreographerInviteSchema),\n    defaultValues,\n    mode: \"onChange\",\n  });\n\n  // Use the inviteChoreographerWithLink mutation\n  const { mutate: inviteChoreographer, isPending } =\n    api.studio.inviteChoreographerWithLink.useMutation({\n      onSuccess: (data) => {\n        setFormSubmitted(true);\n\n        // Store the invitation link if available\n        if (data.inviteLink) {\n          setInviteLink(data.inviteLink);\n        }\n\n        if (data.status === \"invited\") {\n          toast.success(\n            `Invitation link generated for ${data.invitation.email}!`,\n          );\n        } else if (data.status === \"already_invited\") {\n          toast.info(\n            `${data.invitation.email} has already been invited. Here's the link again.`,\n          );\n        }\n      },\n      onError: (error) => {\n        toast.error(`Failed to create invitation: ${error.message}`);\n      },\n    });\n\n  const onSubmit = async (values: ChoreographerInviteValues) => {\n    inviteChoreographer({\n      studioId,\n      email: values.email,\n      role: \"CHOREOGRAPHER\", // Hardcoded role\n    });\n  };\n\n  const handleNewInvite = () => {\n    setFormSubmitted(false);\n    setInviteLink(null);\n    setCopied(false);\n    form.reset(defaultValues);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    // Reset form after a short delay to avoid visual glitches\n    setTimeout(() => {\n      setFormSubmitted(false);\n      setInviteLink(null);\n      setCopied(false);\n      form.reset(defaultValues);\n    }, 200);\n  };\n\n  const copyToClipboard = async () => {\n    if (!inviteLink) return;\n\n    try {\n      await navigator.clipboard.writeText(inviteLink);\n      setCopied(true);\n      toast.success(\"Link copied to clipboard!\");\n\n      // Reset copied state after 3 seconds\n      setTimeout(() => setCopied(false), 3000);\n    } catch (err) {\n      toast.error(\"Failed to copy link to clipboard\");\n    }\n  };\n\n  // Memoize the TriggerButton to prevent unnecessary re-renders\n  const TriggerButton = useMemo(\n    () => (\n      <NeoButton\n        variant={variant === \"ghost\" ? \"secondary\" : variant}\n        size={size}\n        className={buttonClassName}\n      >\n        <Plus className=\"mr-2 h-4 w-4\" />\n        {buttonLabel}\n      </NeoButton>\n    ),\n    [variant, size, buttonClassName, buttonLabel],\n  );\n\n  // Render the success card with invitation link\n  const SuccessCard = () => (\n    <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n      <div className=\"neo-border mb-5 flex h-14 w-14 items-center justify-center rounded-full bg-green-200 text-black shadow-neo-sm\">\n        <Mail className=\"h-7 w-7\" strokeWidth={2} />\n      </div>\n      <h2 className=\"mb-2 text-xl font-bold\">Invitation Link Generated!</h2>\n      <p className=\"mb-5 text-sm text-muted-foreground\">\n        Copy and share this link with the choreographer to invite them to your\n        studio.\n      </p>\n\n      {/* Display invitation link */}\n      {inviteLink && (\n        <div className=\"mb-5 w-full\">\n          <p className=\"mb-2 text-sm font-medium\">Invitation Link:</p>\n          <div className=\"flex flex-col gap-2\">\n            <div className=\"relative\">\n              <div className=\"neo-border break-all rounded-md bg-muted p-3 pr-12 text-left text-xs shadow-neo-sm\">\n                {inviteLink}\n              </div>\n              <button\n                onClick={copyToClipboard}\n                className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-md border border-black bg-white p-1 active:shadow-none\"\n                aria-label=\"Copy link\"\n              >\n                {copied ? (\n                  <CheckCircle\n                    className=\"h-4 w-4 text-green-500\"\n                    strokeWidth={2.5}\n                  />\n                ) : (\n                  <Copy className=\"h-4 w-4\" strokeWidth={2.5} />\n                )}\n              </button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              This link is valid for 30 days.\n            </p>\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col gap-3 sm:flex-row\">\n        <NeoButton onClick={handleNewInvite} variant=\"secondary\" size=\"sm\">\n          Create Another Invitation\n        </NeoButton>\n        <NeoButton onClick={handleClose} size=\"sm\">\n          Close\n        </NeoButton>\n      </div>\n    </div>\n  );\n\n  // Render the invite form\n  const InviteForm = () => (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-5\">\n        {/* Invitation Section Header */}\n        <div className=\"flex items-center gap-3\">\n          <div className=\"neo-border flex h-9 w-9 items-center justify-center rounded-full bg-blue-200 text-black shadow-neo-sm\">\n            <Mail className=\"h-4 w-4\" strokeWidth={2.5} />\n          </div>\n          <h3 className=\"text-base font-bold\">Invite a Choreographer</h3>\n        </div>\n\n        {/* Explanation Card */}\n        <NeoCard>\n          <p className=\"text-xs\">\n            Create an invitation link to share with a choreographer to join your\n            studio. The link will allow them to sign in and join your studio as\n            a choreographer.\n          </p>\n        </NeoCard>\n\n        {/* Email Field */}\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"font-bold\">\n                Email Address <span className=\"text-red-500\">*</span>\n              </FormLabel>\n              <FormControl>\n                <Input\n                  type=\"email\"\n                  placeholder=\"choreographer@example.com\"\n                  {...field}\n                  className=\"neo-border bg-white p-3 shadow-neo-sm transition-all focus:translate-x-0.5 focus:translate-y-0.5 focus:shadow-none dark:bg-black\"\n                />\n              </FormControl>\n              <FormDescription className=\"text-xs\">\n                Enter the email address of the choreographer you want to invite.\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        {/* Form Actions */}\n        <div className=\"mt-6 flex justify-end gap-3\">\n          <NeoButton type=\"button\" variant=\"secondary\" onClick={handleClose}>\n            Cancel\n          </NeoButton>\n          <NeoButton type=\"submit\" disabled={isPending}>\n            {isPending ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Generating...\n              </>\n            ) : (\n              <>\n                <Sparkles className=\"mr-2 h-4 w-4\" strokeWidth={2.5} />\n                Generate Invitation Link\n              </>\n            )}\n          </NeoButton>\n        </div>\n      </form>\n    </Form>\n  );\n\n  // Render either Dialog or Drawer based on screen size\n  if (isDesktop) {\n    return (\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogTrigger asChild>{TriggerButton}</DialogTrigger>\n        <DialogContent\n          className=\"sm:max-w-[500px]\"\n          onInteractOutside={(e) => e.preventDefault()}\n          onEscapeKeyDown={(e) => {\n            e.stopPropagation();\n            handleClose();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle></DialogTitle>\n          </DialogHeader>\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  return (\n    <Drawer open={open} onOpenChange={setOpen}>\n      <DrawerTrigger asChild>{TriggerButton}</DrawerTrigger>\n      <DrawerContent\n        onInteractOutside={(e) => e.preventDefault()}\n        onEscapeKeyDown={(e) => {\n          e.stopPropagation();\n          handleClose();\n        }}\n      >\n        <DrawerHeader>\n          <DrawerTitle></DrawerTitle>\n        </DrawerHeader>\n        <div className=\"px-4 pb-6\">\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </div>\n      </DrawerContent>\n    </Drawer>\n  );\n}\n```\n\nyour next task is to validate if the choreographers-form.tsx file is implemented correctly.\ndiagnostics\ndance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n```tsx\n    studio: {\n      slug: string;\n      [key: string]: any;\n// error: Unexpected any. Specify a different type.\n    };\n    [key: string]: any;\n```\n```tsx\n      [key: string]: any;\n    };\n    [key: string]: any;\n// error: Unexpected any. Specify a different type.\n  };\n}\n```\n```tsx\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n//          Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n```\n```tsx\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data: InvitationData) => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: str...'.\n//          Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; };...'.\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n```\n```tsx\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data: MembershipData) => {\n// error: Type '(data: MembershipData) => void' is not assignable to type '(data: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }, v...'.\n//          Types of parameters 'data' and 'data' are incompatible.\n//            Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }' is not assignable to type 'MembershipData'.\n//              Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: $Enums.StudioRole; }; }' is not assignable to type 'MembershipData'.\n//                The types of 'membership.studio' are incompatible between these types.\n//                  Type '({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; openingHours: JsonValue; isActive: boolean; id: string; createdAt: Date; updatedAt: Date; } & { ...; }) | null' is not assignable to type '{ slug?: string | undefined; } | undefined'.\n//                    Type 'null' is not assignable to type '{ slug?: string | undefined; } | undefined'.\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n```\n```tsx\n        }\n      },\n      onError: (error: Error) => {\n// error: Type '(error: Error) => void' is not assignable to type '(error: TRPCClientErrorLike<{ input: { token: string; }; output: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole...'.\n//          Types of parameters 'error' and 'error' are incompatible.\n//            Property 'name' is missing in type 'TRPCClientErrorBase<{ data: { zodError: typeToFlattenedError<any, string> | null; code: \"PARSE_ERROR\" | \"BAD_REQUEST\" | \"INTERNAL_SERVER_ERROR\" | \"NOT_IMPLEMENTED\" | \"BAD_GATEWAY\" | ... 13 more ... | \"CLIENT_CLOSED_REQUEST\"; httpStatus: number; path?: string | undefined; stack?: string | undefined; }; message: strin...' but required in type 'Error'.\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n```\ndance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n```tsx\n    studio: {\n      slug: string;\n      [key: string]: any;\n// error: Unexpected any. Specify a different type.\n    };\n    [key: string]: any;\n```\n```tsx\n      [key: string]: any;\n    };\n    [key: string]: any;\n// error: Unexpected any. Specify a different type.\n  };\n}\n```\n```tsx\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n//          Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n```\n```tsx\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data: InvitationData) => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: str...'.\n//          Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; };...'.\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n```\n```tsx\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data: MembershipData) => {\n// error: Type '(data: MembershipData) => void' is not assignable to type '(data: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }, v...'.\n//          Types of parameters 'data' and 'data' are incompatible.\n//            Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }' is not assignable to type 'MembershipData'.\n//              Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: $Enums.StudioRole; }; }' is not assignable to type 'MembershipData'.\n//                The types of 'membership.studio' are incompatible between these types.\n//                  Type '({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; openingHours: JsonValue; isActive: boolean; id: string; createdAt: Date; updatedAt: Date; } & { ...; }) | null' is not assignable to type '{ slug?: string | undefined; } | undefined'.\n//                    Type 'null' is not assignable to type '{ slug?: string | undefined; } | undefined'.\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n```\n```tsx\n        }\n      },\n      onError: (error: Error) => {\n// error: Type '(error: Error) => void' is not assignable to type '(error: TRPCClientErrorLike<{ input: { token: string; }; output: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole...'.\n//          Types of parameters 'error' and 'error' are incompatible.\n//            Property 'name' is missing in type 'TRPCClientErrorBase<{ data: { zodError: typeToFlattenedError<any, string> | null; code: \"PARSE_ERROR\" | \"BAD_REQUEST\" | \"INTERNAL_SERVER_ERROR\" | \"NOT_IMPLEMENTED\" | \"BAD_GATEWAY\" | ... 13 more ... | \"CLIENT_CLOSED_REQUEST\"; httpStatus: number; path?: string | undefined; stack?: string | undefined; }; message: strin...' but required in type 'Error'.\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n```\ndance-book-app/src/app/(private)/profile/choreographers-form.tsx\n```tsx\n      studioId,\n      email: values.email,\n      role: \"CHOREOGRAPHER\", // Hardcoded role\n// error: Object literal may only specify known properties, and 'role' does not exist in type '{ studioId: string; email: string; }'.\n    });\n  };\n```\ndance-book-app/src/server/api/routers/studio.ts\n```typescript\n            data: {\n              status: \"ACCEPTED\",\n              acceptedAt: new Date(),\n// error: Object literal may only specify known properties, and 'acceptedAt' does not exist in type '(Without<StudioInvitationUpdateInput, StudioInvitationUncheckedUpdateInput> & StudioInvitationUncheckedUpdateInput) | (Without<...> & StudioInvitationUpdateInput)'.\n              acceptedById: ctx.profile.id,\n            },\n```\n```typescript\n            data: {\n              status: \"ACCEPTED\",\n              acceptedAt: new Date(),\n// error: Object literal may only specify known properties, and 'acceptedAt' does not exist in type '(Without<StudioInvitationUpdateInput, StudioInvitationUncheckedUpdateInput> & StudioInvitationUncheckedUpdateInput) | (Without<...> & StudioInvitationUpdateInput)'.\n              acceptedById: ctx.profile.id,\n            },\n```\n\nfix the errors in the code\nI'll address the issues in both files, focusing on fixing the TypeScript errors and making the code more maintainable.\n\nFirst, let's fix the `choreographers-form.tsx` file:\n\n```tsx\n\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { z } from \"zod\";\nimport { Loader2, Mail, Plus, Sparkles, Copy, CheckCircle } from \"lucide-react\";\nimport { api } from \"~/trpc/react\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTrigger,\n} from \"~/components/ui/dialog\";\nimport {\n  Drawer,\n  DrawerContent,\n  DrawerTrigger,\n  DrawerHeader,\n  DrawerTitle,\n} from \"~/components/ui/drawer\";\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"~/components/ui/form\";\nimport { Input } from \"~/components/ui/input\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { useIsMobile } from \"~/hooks/use-mobile\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { DialogTitle } from \"@radix-ui/react-dialog\";\n\n// Simplified schema - only email, no role needed\nconst choreographerInviteSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n});\n\ntype ChoreographerInviteValues = z.infer<typeof choreographerInviteSchema>;\n\nconst defaultValues: ChoreographerInviteValues = {\n  email: \"\",\n};\n\ninterface ChoreographerInviteDialogProps {\n  studioId: string;\n  studioSlug: string;\n  buttonLabel?: string;\n  buttonClassName?: string;\n  variant?: \"default\" | \"outline\" | \"secondary\" | \"ghost\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n}\n\nexport function ChoreographerInviteDialog({\n  studioId,\n  studioSlug,\n  buttonLabel = \"Add Choreographer\",\n  buttonClassName = \"\",\n  variant = \"default\",\n  size = \"default\",\n}: ChoreographerInviteDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [formSubmitted, setFormSubmitted] = useState(false);\n  const [inviteLink, setInviteLink] = useState<string | null>(null);\n  const [copied, setCopied] = useState(false);\n  const isMobile = useIsMobile();\n  const isDesktop = !isMobile;\n\n  const form = useForm<ChoreographerInviteValues>({\n    resolver: zodResolver(choreographerInviteSchema),\n    defaultValues,\n    mode: \"onChange\",\n  });\n\n  // Use the inviteChoreographerWithLink mutation\n  const { mutate: inviteChoreographer, isPending } =\n    api.studio.inviteChoreographerWithLink.useMutation({\n      onSuccess: (data) => {\n        setFormSubmitted(true);\n\n        // Store the invitation link if available\n        if (data.inviteLink) {\n          setInviteLink(data.inviteLink);\n        }\n\n        if (data.status === \"invited\") {\n          toast.success(\n            `Invitation link generated for ${data.invitation.email}!`,\n          );\n        } else if (data.status === \"already_invited\") {\n          toast.info(\n            `${data.invitation.email} has already been invited. Here's the link again.`,\n          );\n        }\n      },\n      onError: (error) => {\n        toast.error(`Failed to create invitation: ${error.message}`);\n      },\n    });\n\n  const onSubmit = async (values: ChoreographerInviteValues) => {\n    inviteChoreographer({\n      studioId,\n      email: values.email,\n      // Remove the \"role\" parameter since it's now handled on the server side\n    });\n  };\n\n  const handleNewInvite = () => {\n    setFormSubmitted(false);\n    setInviteLink(null);\n    setCopied(false);\n    form.reset(defaultValues);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    // Reset form after a short delay to avoid visual glitches\n    setTimeout(() => {\n      setFormSubmitted(false);\n      setInviteLink(null);\n      setCopied(false);\n      form.reset(defaultValues);\n    }, 200);\n  };\n\n  const copyToClipboard = async () => {\n    if (!inviteLink) return;\n\n    try {\n      await navigator.clipboard.writeText(inviteLink);\n      setCopied(true);\n      toast.success(\"Link copied to clipboard!\");\n\n      // Reset copied state after 3 seconds\n      setTimeout(() => setCopied(false), 3000);\n    } catch (err) {\n      toast.error(\"Failed to copy link to clipboard\");\n    }\n  };\n\n  // Memoize the TriggerButton to prevent unnecessary re-renders\n  const TriggerButton = useMemo(\n    () => (\n      <NeoButton\n        variant={variant === \"ghost\" ? \"secondary\" : variant}\n        size={size}\n        className={buttonClassName}\n      >\n        <Plus className=\"mr-2 h-4 w-4\" />\n        {buttonLabel}\n      </NeoButton>\n    ),\n    [variant, size, buttonClassName, buttonLabel],\n  );\n\n  // Render the success card with invitation link\n  const SuccessCard = () => (\n    <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n      <div className=\"neo-border mb-5 flex h-14 w-14 items-center justify-center rounded-full bg-green-200 text-black shadow-neo-sm\">\n        <Mail className=\"h-7 w-7\" strokeWidth={2} />\n      </div>\n      <h2 className=\"mb-2 text-xl font-bold\">Invitation Link Generated!</h2>\n      <p className=\"mb-5 text-sm text-muted-foreground\">\n        Copy and share this link with the choreographer to invite them to your\n        studio.\n      </p>\n\n      {/* Display invitation link */}\n      {inviteLink && (\n        <div className=\"mb-5 w-full\">\n          <p className=\"mb-2 text-sm font-medium\">Invitation Link:</p>\n          <div className=\"flex flex-col gap-2\">\n            <div className=\"relative\">\n              <div className=\"neo-border break-all rounded-md bg-muted p-3 pr-12 text-left text-xs shadow-neo-sm\">\n                {inviteLink}\n              </div>\n              <button\n                onClick={copyToClipboard}\n                className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-md border border-black bg-white p-1 active:shadow-none\"\n                aria-label=\"Copy link\"\n              >\n                {copied ? (\n                  <CheckCircle\n                    className=\"h-4 w-4 text-green-500\"\n                    strokeWidth={2.5}\n                  />\n                ) : (\n                  <Copy className=\"h-4 w-4\" strokeWidth={2.5} />\n                )}\n              </button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              This link is valid for 30 days.\n            </p>\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col gap-3 sm:flex-row\">\n        <NeoButton onClick={handleNewInvite} variant=\"secondary\" size=\"sm\">\n          Create Another Invitation\n        </NeoButton>\n        <NeoButton onClick={handleClose} size=\"sm\">\n          Close\n        </NeoButton>\n      </div>\n    </div>\n  );\n\n  // Render the invite form\n  const InviteForm = () => (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-5\">\n        {/* Invitation Section Header */}\n        <div className=\"flex items-center gap-3\">\n          <div className=\"neo-border flex h-9 w-9 items-center justify-center rounded-full bg-blue-200 text-black shadow-neo-sm\">\n            <Mail className=\"h-4 w-4\" strokeWidth={2.5} />\n          </div>\n          <h3 className=\"text-base font-bold\">Invite a Choreographer</h3>\n        </div>\n\n        {/* Explanation Card */}\n        <NeoCard>\n          <p className=\"text-xs\">\n            Create an invitation link to share with a choreographer to join your\n            studio. The link will allow them to sign in and join your studio as\n            a choreographer.\n          </p>\n        </NeoCard>\n\n        {/* Email Field */}\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"font-bold\">\n                Email Address <span className=\"text-red-500\">*</span>\n              </FormLabel>\n              <FormControl>\n                <Input\n                  type=\"email\"\n                  placeholder=\"choreographer@example.com\"\n                  {...field}\n                  className=\"neo-border bg-white p-3 shadow-neo-sm transition-all focus:translate-x-0.5 focus:translate-y-0.5 focus:shadow-none dark:bg-black\"\n                />\n              </FormControl>\n              <FormDescription className=\"text-xs\">\n                Enter the email address of the choreographer you want to invite.\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        {/* Form Actions */}\n        <div className=\"mt-6 flex justify-end gap-3\">\n          <NeoButton type=\"button\" variant=\"secondary\" onClick={handleClose}>\n            Cancel\n          </NeoButton>\n          <NeoButton type=\"submit\" disabled={isPending}>\n            {isPending ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Generating...\n              </>\n            ) : (\n              <>\n                <Sparkles className=\"mr-2 h-4 w-4\" strokeWidth={2.5} />\n                Generate Invitation Link\n              </>\n            )}\n          </NeoButton>\n        </div>\n      </form>\n    </Form>\n  );\n\n  // Render either Dialog or Drawer based on screen size\n  if (isDesktop) {\n    return (\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogTrigger asChild>{TriggerButton}</DialogTrigger>\n        <DialogContent\n          className=\"sm:max-w-[500px]\"\n          onInteractOutside={(e) => e.preventDefault()}\n          onEscapeKeyDown={(e) => {\n            e.stopPropagation();\n            handleClose();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle></DialogTitle>\n          </DialogHeader>\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  return (\n    <Drawer open={open} onOpenChange={setOpen}>\n      <DrawerTrigger asChild>{TriggerButton}</DrawerTrigger>\n      <DrawerContent\n        onInteractOutside={(e) => e.preventDefault()}\n        onEscapeKeyDown={(e) => {\n          e.stopPropagation();\n          handleClose();\n        }}\n      >\n        <DrawerHeader>\n          <DrawerTitle></DrawerTitle>\n        </DrawerHeader>\n        <div className=\"px-4 pb-6\">\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </div>\n      </DrawerContent>\n    </Drawer>\n  );\n}\n```\n\nNow, let's fix the `studio.ts` router to remove errors related to `acceptedAt` and `acceptedById`:\n\n```typescript\n// Update the acceptInvitationWithLink procedure in studio.ts\n\n// Inside the acceptInvitationWithLink procedure, update the update statements:\n\n// In the existing membership case:\n// Update invitation status\nawait ctx.db.studioInvitation.update({\n  where: { id: invitation.id },\n  data: { \n    status: \"ACCEPTED\",\n    // Remove these fields if they don't exist in your Prisma schema\n    // acceptedAt: new Date(),\n    // acceptedById: ctx.profile.id,\n  },\n});\n\n// And in the transaction:\n// Update invitation status\nawait tx.studioInvitation.update({\n  where: { id: invitation.id },\n  data: { \n    status: \"ACCEPTED\", \n    // Remove these fields if they don't exist in your Prisma schema\n    // acceptedAt: new Date(),\n    // acceptedById: ctx.profile.id,\n  },\n});\n```\n\nFor the invite-accept-content.tsx file, I need to fix the type errors related to the API calls. Here's how I would update those parts:\n\n```tsx\n// For the getCurrent query:\n} = api.profile.getCurrent.useQuery(undefined, {\n  retry: 0, // Don't retry if the user is not authenticated\n  // Remove the onError callback if it's causing type errors\n});\n\n// For validateInvitation:\nconst { data: invitationData, isLoading: isValidatingInvitation } = \n  api.studio.validateInvitation.useQuery(\n    { token },\n    {\n      enabled: !!token,\n      retry: 1,\n      // Remove onSuccess callback if it's causing type errors\n    }\n  );\n\n// When you need to access the data, do it directly:\nuseEffect(() => {\n  if (invitationData?.invitation?.email && !email) {\n    setEmail(invitationData.invitation.email);\n  }\n}, [invitationData, email]);\n\n// For the acceptInvitation mutation:\nconst { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n  api.studio.acceptInvitationWithLink.useMutation({\n    onSuccess: (data) => {\n      toast.success(\"Successfully joined studio!\");\n      // Navigate to the studio page\n      if (data.status === \"accepted\" && data.membership?.studio?.slug) {\n        router.push(`/studio/${data.membership.studio.slug}`);\n      } else if (data.status === \"already_member\" && data.membership?.studio?.slug) {\n        router.push(`/studio/${data.membership.studio.slug}`);\n      }\n    },\n    onError: (error) => {\n      console.error(\"Error accepting invitation:\", error);\n      toast.error(\"Failed to join studio: \" + error.message);\n    },\n  });\n```\n\nFor the type issues in the invite-accept-content.tsx file regarding `any` types:\n\n```tsx\n// Replace any with more specific types\ninterface Studio {\n  slug: string;\n  name: string;\n  logo?: string | null;\n  description?: string | null;\n  // Add other properties as needed\n}\n\ninterface Invitation {\n  studio: Studio | null;\n  email: string;\n  role: string;\n  id: string;\n  status: string;\n  // Add other properties as needed\n}\n\ninterface InvitationData {\n  valid: boolean;\n  invitation: Invitation;\n}\n\ninterface Membership {\n  studio: Studio | null;\n  role: string;\n  // Add other properties as needed\n}\n\ninterface MembershipResponse {\n  status: string;\n  membership: Membership;\n}\n```\n\nThese changes should address the TypeScript errors in your code. The main issues were:\n\n1. In choreographers-form.tsx: Removed the hardcoded role parameter that doesn't exist in the API\n2. In studio.ts: Removed the acceptedAt and acceptedById fields that don't exist in your Prisma schema\n3. For invite-accept-content.tsx: Fixed type issues with the API callbacks and removed any types with more specific ones\n\nLet me know if you\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2, Mail, Lock } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"~/components/ui/tabs\";\nimport { Label } from \"~/components/ui/label\";\n\ninterface InviteAcceptContentProps {\n  token: string;\n  studioName?: string;\n  role?: string;\n}\n\nexport function InviteAcceptContent({\n  token,\n  studioName = \"Studio\",\n  role\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [signUpMode, setSignUpMode] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    refetch: refetchProfile,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n  });\n\n  // Validate the invitation token\n  const { data: invitationData, isLoading: isValidating } =\n    api.studio.validateInvitation.useQuery(\n      { token },\n      {\n        enabled: !!token,\n        retry: 1,\n      },\n    );\n\n  // When you need to access the data, do it directly:\n  useEffect(() => {\n    if (invitationData?.invitation?.email && !email) {\n      setEmail(invitationData.invitation.email);\n    }\n  }, [invitationData, email]);\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.status === \"accepted\" && data.membership?.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else if (\n          data.status === \"already_member\" &&\n          data.membership?.studio?.slug\n        ) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n      },\n    });\n\n  // Handle email/password sign in\n  const handleEmailSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim() || !password.trim()) {\n      toast.error(\"Please enter both email and password\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      if (signUpMode) {\n        // Handle sign up\n        if (password !== confirmPassword) {\n          toast.error(\"Passwords do not match\");\n          setProcessing(false);\n          return;\n        }\n\n        const { error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: {\n            emailRedirectTo: callbackURL.toString(),\n          },\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1500);\n      } else {\n        // Handle sign in\n        const { error } = await supabase.auth.signInWithPassword({\n          email,\n          password,\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1000);\n      }\n    } catch (err) {\n      console.error(\"Auth error:\", err);\n      toast.error(err instanceof Error ? err.message : \"Authentication failed\");\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // Handle Google sign in\n  const handleGoogleSignIn = async () => {\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      const { error } = await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: {\n          redirectTo: callbackURL.toString(),\n        },\n      });\n\n      if (error) throw error;\n    } catch (err) {\n      console.error(\"Google auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Google authentication failed\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render auth form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You&apos;ve been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n          <p className=\"text-center text-sm text-muted-foreground\">\n            Sign in or create an account to accept this invitation\n          </p>\n        </NeoCard>\n\n        <div className=\"space-y-4\">\n          {/* Google Sign In */}\n          <NeoButton\n            className=\"w-full justify-center\"\n            variant=\"outline\"\n            size=\"lg\"\n            onClick={handleGoogleSignIn}\n            disabled={processing}\n          >\n            {processing && <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />}\n            Continue with Google\n          </NeoButton>\n\n          <div className=\"relative my-4\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <span className=\"w-full border-t border-gray-300\" />\n            </div>\n            <div className=\"relative flex justify-center text-xs uppercase\">\n              <span className=\"bg-white px-2 text-muted-foreground\">\n                Or continue with\n              </span>\n            </div>\n          </div>\n\n          {/* Email/Password Auth */}\n          <Tabs\n            defaultValue=\"signin\"\n            className=\"w-full\"\n            onValueChange={(value) => setSignUpMode(value === \"signup\")}\n          >\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"signin\">Sign In</TabsTrigger>\n              <TabsTrigger value=\"signup\">Sign Up</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"signin\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Signing in...\n                    </>\n                  ) : (\n                    \"Sign In\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n\n            <TabsContent value=\"signup\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"confirm-password\"\n                      type=\"password\"\n                      value={confirmPassword}\n                      onChange={(e) => setConfirmPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Creating account...\n                    </>\n                  ) : (\n                    \"Create Account\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You&apos;ve been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You&apos;re signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\n{\n    \"shape\": {\n        \"message\": \"Invitation not found or already used\",\n        \"code\": -32004,\n        \"data\": {\n            \"code\": \"NOT_FOUND\",\n            \"httpStatus\": 404,\n            \"stack\": \"TRPCError: Invitation not found or already used\\n    at /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/[root of the server]__e5735231._.js:1360:23\\n    at async resolveMiddleware (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4432:30)\\n    at async callRecursive (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4473:24)\\n    at async callRecursive (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4473:24)\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/[root of the server]__e5735231._.js:324:20\\n    at async callRecursive (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4473:24)\\n    at async procedure (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4506:24)\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:3686:30\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:3861:45\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:1736:30\",\n            \"path\": \"studio.validateInvitation\",\n            \"zodError\": null\n        }\n    },\n    \"data\": {\n        \"code\": \"NOT_FOUND\",\n        \"httpStatus\": 404,\n        \"stack\": \"TRPCError: Invitation not found or already used\\n    at /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/[root of the server]__e5735231._.js:1360:23\\n    at async resolveMiddleware (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4432:30)\\n    at async callRecursive (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4473:24)\\n    at async callRecursive (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4473:24)\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/[root of the server]__e5735231._.js:324:20\\n    at async callRecursive (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4473:24)\\n    at async procedure (/Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:4506:24)\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:3686:30\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:3861:45\\n    at async /Users/glendell/projects/personal/dance-book-app/.next/server/chunks/a76e2_@trpc_server_dist_98da0fe1._.js:1736:30\",\n        \"path\": \"studio.validateInvitation\",\n        \"zodError\": null\n    },\n    \"meta\": {\n        \"response\": {}\n    },\n    \"name\": \"TRPCClientError\"\n}\ncan we handle this error\nso the choreographer is already a member of the studio\n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\ncreateTRPCRouter,\npublicProcedure,\nauthedProcedure,\nadminProcedure,\nownerProcedure,\nstaffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\nimport { createJWT, verifyJWT } from \"~/lib/jwt\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\nname: z.string().min(2).max(100),\nslug: z.string().min(3).max(100),\ndescription: z.string().optional(),\naddress: z.string().min(5).max(255),\ncity: z.string().min(2).max(100),\nstate: z.string().min(2).max(100),\npostalCode: z.string().min(3).max(20),\ncountry: z.string().length(2),\nlogo: z.string().url().optional(),\nopeningHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\nstudioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\nname: z.string().min(2).max(100).optional(),\nslug: z.string().min(3).max(100).optional(),\ndescription: z.string().optional().nullable(),\naddress: z.string().min(5).max(255).optional(),\ncity: z.string().min(2).max(100).optional(),\nstate: z.string().min(2).max(100).optional(),\npostalCode: z.string().min(3).max(20).optional(),\ncountry: z.string().length(2).optional(),\nlogo: z.string().url().optional().nullable(),\nopeningHours: z.record(z.string(), z.array(z.string())).optional(),\nisActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\nid: z.string().uuid().optional(),\nslug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\npage: z.number().min(1).default(1),\norderBy: z\n.enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n.default(\"createdAt\"),\norder: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\nsearch: z.string().optional(),\ncity: z.string().optional(),\ncountry: z.string().optional(),\nisActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\nstudio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\nif (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n  countryName?: string;\n  stateName?: string;\n  };\n  \n  if (studio.country) {\n  const countryData = Country.getCountryByCode(studio.country);\n  enhancedStudio.countryName = countryData?.name;\n  }\n  \n  if (studio.state && studio.country) {\n  const stateData = State.getStateByCodeAndCountry(\n  studio.state,\n  studio.country,\n  );\n  enhancedStudio.stateName = stateData?.name;\n  }\n  \n  return enhancedStudio;\n  };\n  \n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\nstudios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\nreturn studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\ntypeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n// Create a new studio\ncreate: authedProcedure\n.input(studioCreateSchema)\n.mutation(async ({ ctx, input }) => {\ntry {\n// Use a transaction to create the studio and add the creator as owner\nreturn await ctx.db.$transaction(async (tx) => {\n// Create the studio first\nconst studio = await tx.studio.create({\ndata: {\nname: input.name,\nslug: input.slug,\ndescription: input.description,\naddress: input.address,\ncity: input.city,\nstate: input.state,\npostalCode: input.postalCode,\ncountry: input.country,\nlogo: input.logo,\nopeningHours: input.openingHours as object,\n},\n});\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n          data: {\n          profileId: ctx.profile.id,\n          studioId: studio.id,\n          role: \"OWNER\",\n          },\n          });\n          \n          return enhanceStudioWithLocationNames(studio);\n          });\n          } catch (error) {\n          throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n          });\n          }\n          }),\n          \n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n  .input(studioFindSchema)\n  .query(async ({ ctx, input }) => {\n  const studio = await ctx.db.studio.findUnique({\n  where: { id: input.id, slug: input.slug },\n  include: {\n  members: {\n  include: {\n  profile: true,\n  },\n  },\n  },\n  });\n  \n      if (!studio) {\n      throw new TRPCError({\n      code: \"NOT_FOUND\",\n      message: \"Studio not found\",\n      });\n      }\n      \n      return enhanceStudioWithLocationNames(studio);\n      }),\n      \n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n  .input(studioUpdateSchema)\n  .mutation(async ({ ctx, input }) => {\n  try {\n  // Extract the studioId and remove it from the data to be updated\n  const { studioId, ...updateData } = input;\n  \n        const updatedStudio = await ctx.db.studio.update({\n        where: { id: studioId },\n        data: {\n        ...updateData,\n        openingHours: updateData.openingHours as object | undefined,\n        updatedAt: new Date(),\n        },\n        });\n        \n        return enhanceStudioWithLocationNames(updatedStudio);\n        } catch (error) {\n        if (\n        error instanceof Error &&\n        error.message.includes(\"Record to update not found\")\n        ) {\n        throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Studio not found\",\n        });\n        }\n        \n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to update studio\",\n        cause: error,\n        });\n        }\n        }),\n        \n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n  .input(z.object({ studioId: z.string().uuid() }))\n  .mutation(async ({ ctx, input }) => {\n  try {\n  // Use a transaction to delete all related data\n  return await ctx.db.$transaction(async (tx) => {\n  // First delete all studio memberships\n  await tx.studioMember.deleteMany({\n  where: { studioId: input.studioId },\n  });\n  \n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n          where: { id: input.studioId },\n          });\n          \n          return enhanceStudioWithLocationNames(deletedStudio);\n          });\n          } catch (error) {\n          if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n          ) {\n          throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n          });\n          }\n          \n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to delete studio\",\n        cause: error,\n        });\n        }\n        }),\n        \n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n  .input(studioQuerySchema)\n  .query(async ({ ctx, input }) => {\n  try {\n  const { page, orderBy, order, search, city, country, isActive } = input;\n  \n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n        orderBy: {\n        [orderBy]: order,\n        },\n        };\n        \n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n        \n        if (search) {\n        whereConditions.OR = [\n        {\n        name: {\n        contains: search,\n        mode: \"insensitive\" as Prisma.QueryMode,\n        },\n        },\n        {\n        description: {\n        contains: search,\n        mode: \"insensitive\" as Prisma.QueryMode,\n        },\n        },\n        {\n        address: {\n        contains: search,\n        mode: \"insensitive\" as Prisma.QueryMode,\n        },\n        },\n        ];\n        }\n        \n        if (city) {\n        whereConditions.city = {\n        contains: city,\n        mode: \"insensitive\" as Prisma.QueryMode,\n        };\n        }\n        \n        if (country) {\n        whereConditions.country = country;\n        }\n        \n        if (isActive !== undefined) {\n        whereConditions.isActive = isActive;\n        }\n        \n        if (Object.keys(whereConditions).length > 0) {\n        paginationOptions.where = whereConditions;\n        }\n        \n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n        .paginate(paginationOptions)\n        .withPages({\n        page,\n        });\n        \n        return {\n        studios: enhanceStudiosWithLocationNames(studios),\n        meta,\n        };\n        } catch (error) {\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to list studios\",\n        cause: error,\n        });\n        }\n        }),\n        \n  // Get studios managed by the current user\n  myStudios: authedProcedure\n  .input(\n  z\n  .object({\n  role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n  })\n  .optional(),\n  )\n  .query(async ({ ctx, input }) => {\n  try {\n  const whereConditions: Prisma.StudioMemberWhereInput = {\n  profileId: ctx.profile.id,\n  };\n  \n        if (input?.role) {\n        whereConditions.role = input.role;\n        }\n        \n        const memberships = await ctx.db.studioMember.findMany({\n        where: whereConditions,\n        include: {\n        studio: true,\n        },\n        orderBy: {\n        createdAt: \"desc\",\n        },\n        });\n        \n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n        ...membership,\n        studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n        } catch (error) {\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to retrieve your studios\",\n        cause: error,\n        });\n        }\n        }),\n        \n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n  .input(\n  z.object({\n  studioId: z.string().uuid(), // Already required by adminProcedure\n  profileId: z.string().uuid(),\n  role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n  }),\n  )\n  .mutation(async ({ ctx, input }) => {\n  try {\n  // Check if the member already exists\n  const existingMember = await ctx.db.studioMember.findUnique({\n  where: {\n  profileId_studioId: {\n  profileId: input.profileId,\n  studioId: input.studioId,\n  },\n  },\n  });\n  \n        if (existingMember) {\n        throw new TRPCError({\n        code: \"CONFLICT\",\n        message: \"This person is already a member of this studio\",\n        });\n        }\n        \n        // Create the member\n        const member = await ctx.db.studioMember.create({\n        data: {\n        profileId: input.profileId,\n        studioId: input.studioId,\n        role: input.role,\n        },\n        include: {\n        profile: true,\n        studio: true,\n        },\n        });\n        \n        // Enhance studio data in the response\n        return {\n        ...member,\n        studio: enhanceStudioWithLocationNames(member.studio),\n        };\n        } catch (error) {\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to add member to studio\",\n        cause: error,\n        });\n        }\n        }),\n        \n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n  .input(\n  z.object({\n  studioId: z.string().uuid(), // Required by adminProcedure\n  memberId: z.string().uuid(),\n  role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n  }),\n  )\n  .mutation(async ({ ctx, input }) => {\n  // Get the member to update\n  const memberToUpdate = await ctx.db.studioMember.findUnique({\n  where: { id: input.memberId },\n  });\n  \n      if (!memberToUpdate) {\n      throw new TRPCError({\n      code: \"NOT_FOUND\",\n      message: \"Member not found\",\n      });\n      }\n      \n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n      throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"Member does not belong to specified studio\",\n      });\n      }\n      \n      // Check if trying to update someone with a higher role\n      if (\n      memberToUpdate.role === \"OWNER\" ||\n      (ctx.studioMembership.role === \"ADMIN\" &&\n      memberToUpdate.role === \"ADMIN\")\n      ) {\n      throw new TRPCError({\n      code: \"FORBIDDEN\",\n      message: \"You cannot modify members with equal or higher roles\",\n      });\n      }\n      \n      try {\n      // Update the member\n      const updatedMember = await ctx.db.studioMember.update({\n      where: { id: input.memberId },\n      data: {\n      role: input.role,\n      updatedAt: new Date(),\n      },\n      include: {\n      profile: true,\n      studio: true,\n      },\n      });\n      \n        // Enhance studio data in the response\n        return {\n        ...updatedMember,\n        studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n        } catch (error) {\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to update studio member\",\n        cause: error,\n        });\n        }\n        }),\n        \n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n  .input(\n  z.object({\n  studioId: z.string().uuid(), // Required by adminProcedure\n  memberId: z.string().uuid(),\n  }),\n  )\n  .mutation(async ({ ctx, input }) => {\n  // Get the member to remove\n  const memberToRemove = await ctx.db.studioMember.findUnique({\n  where: { id: input.memberId },\n  });\n  \n      if (!memberToRemove) {\n      throw new TRPCError({\n      code: \"NOT_FOUND\",\n      message: \"Member not found\",\n      });\n      }\n      \n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n      throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"Member does not belong to specified studio\",\n      });\n      }\n      \n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n      \n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n      throw new TRPCError({\n      code: \"FORBIDDEN\",\n      message: \"Studio owners cannot be removed by others\",\n      });\n      }\n      \n      try {\n      return await ctx.db.studioMember.delete({\n      where: { id: input.memberId },\n      });\n      } catch (error) {\n      throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to remove studio member\",\n      cause: error,\n      });\n      }\n      }),\n      \n  leaveStudio: authedProcedure\n  .input(\n  z.object({\n  studioId: z.string().uuid(),\n  }),\n  )\n  .mutation(async ({ ctx, input }) => {\n  // Find the user's membership\n  const membership = await ctx.db.studioMember.findUnique({\n  where: {\n  profileId_studioId: {\n  profileId: ctx.profile.id,\n  studioId: input.studioId,\n  },\n  },\n  });\n  \n      if (!membership) {\n      throw new TRPCError({\n      code: \"NOT_FOUND\",\n      message: \"You are not a member of this studio\",\n      });\n      }\n      \n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n      const ownersCount = await ctx.db.studioMember.count({\n      where: {\n      studioId: input.studioId,\n      role: \"OWNER\",\n      },\n      });\n      \n        if (ownersCount <= 1) {\n        throw new TRPCError({\n        code: \"FORBIDDEN\",\n        message:\n        \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n        });\n        }\n        }\n        \n      try {\n      return await ctx.db.studioMember.delete({\n      where: { id: membership.id },\n      });\n      } catch (error) {\n      throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to leave studio\",\n      cause: error,\n      });\n      }\n      }),\n      \n  getMembers: authedProcedure\n  .input(\n  z.object({\n  studioId: z.string().uuid(), // Already required by staffProcedure\n  role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n  }),\n  )\n  .query(async ({ ctx, input }) => {\n  const whereConditions: Prisma.StudioMemberWhereInput = {\n  studioId: input.studioId,\n  };\n  \n      if (input.role) {\n      whereConditions.role = input.role;\n      }\n      \n      try {\n      const members = await ctx.db.studioMember.findMany({\n      where: whereConditions,\n      include: {\n      profile: true,\n      },\n      orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n      });\n      \n        return members;\n        } catch (error) {\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to retrieve studio members\",\n        cause: error,\n        });\n        }\n        }),\n        \n  inviteChoreographerWithLink: authedProcedure\n  .input(\n  z.object({\n  studioId: z.string().uuid(),\n  email: z.string().email(),\n  }),\n  )\n  .mutation(async ({ ctx, input }) => {\n  try {\n  // Create the Supabase admin client\n  const supabase = await createClient({ isAdmin: true });\n  \n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n        \n        // Filter users manually to find by email\n        const matchingUsers =\n        data?.users?.filter(\n        (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n        ) || [];\n        \n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n        \n        // Check for existing member with this email at this studio\n        const existingMember =\n        userIds.length > 0\n        ? await ctx.db.studioMember.findFirst({\n        where: {\n        studio: {\n        id: input.studioId,\n        },\n        profile: {\n        authId: {\n        in: userIds,\n        },\n        },\n        },\n        })\n        : null;\n        \n        if (existingMember) {\n        throw new TRPCError({\n        code: \"CONFLICT\",\n        message: \"This user is already a member of this studio\",\n        });\n        }\n        \n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n        where: {\n        email: input.email,\n        studioId: input.studioId,\n        status: \"PENDING\",\n        },\n        });\n        \n        if (existingInvitation) {\n        // Create a secure JWT token for the existing invitation\n        const token = await createJWT({\n        id: existingInvitation.id,\n        email: input.email,\n        studioId: input.studioId,\n        role: existingInvitation.role,\n        type: \"studio-invitation\",\n        });\n        \n          return {\n          status: \"already_invited\",\n          invitation: existingInvitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}&studioId=${input.studioId}&role=${existingInvitation.role}`,\n          };\n          }\n          \n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n        \n        // Fixed role to CHOREOGRAPHER\n        const role = \"CHOREOGRAPHER\";\n        \n        // ctx.profile is guaranteed to exist in authedProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n        data: {\n        email: input.email,\n        studioId: input.studioId,\n        role,\n        invitedById: ctx.profile.id,\n        expiresAt: expirationDate,\n        status: \"PENDING\",\n        },\n        });\n        \n        // Create a secure JWT token with all needed data\n        const token = await createJWT({\n        id: invitation.id,\n        email: input.email,\n        studioId: input.studioId,\n        role,\n        type: \"studio-invitation\",\n        });\n        \n        return {\n        status: \"invited\",\n        invitation,\n        inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}&studioId=${input.studioId}&role=${role}`,\n        };\n        } catch (error) {\n        if (error instanceof TRPCError) {\n        throw error;\n        }\n        \n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to generate invitation link\",\n        cause: error,\n        });\n        }\n        }),\n        \n  validateInvitation: publicProcedure\n  .input(\n  z.object({\n  token: z.string().min(1, \"Token is required\"),\n  }),\n  )\n  .query(async ({ ctx, input }) => {\n  try {\n  // Verify JWT token\n  const tokenData = await verifyJWT(input.token);\n  \n        // Early return for invalid token data\n        if (!tokenData) {\n        throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation token\",\n        });\n        }\n        \n        // Validate token contents\n        if (\n        typeof tokenData.id !== \"string\" ||\n        typeof tokenData.studioId !== \"string\" ||\n        tokenData.type !== \"studio-invitation\"\n        ) {\n        throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation format\",\n        });\n        }\n        \n        // Find the invitation with related studio data\n        const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n        id: tokenData.id,\n        studioId: tokenData.studioId,\n        status: \"PENDING\",\n        },\n        include: {\n        studio: true,\n        invitedBy: true, // Include who sent the invitation\n        },\n        });\n        \n        if (!invitation) {\n        throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Invitation not found or already used\",\n        });\n        }\n        \n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n        // Mark as expired in database\n        await ctx.db.studioInvitation.update({\n        where: { id: invitation.id },\n        data: { status: \"EXPIRED\" },\n        });\n        \n          throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n          });\n          }\n          \n        // Return validated invitation with enhanced studio data\n        return {\n        valid: true,\n        invitation: {\n        ...invitation,\n        studio: enhanceStudioWithLocationNames(invitation.studio),\n        },\n        };\n        } catch (error) {\n        if (error instanceof TRPCError) {\n        throw error;\n        }\n        \n        console.error(\"Validate invitation error:\", error);\n        throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation link\",\n        });\n        }\n        }),\n        \n  // Update acceptInvitationWithLink procedure\n  acceptInvitationWithLink: authedProcedure\n  .input(\n  z.object({\n  token: z.string().min(1, \"Token is required\"),\n  }),\n  )\n  .mutation(async ({ ctx, input }) => {\n  try {\n  // Verify JWT token\n  const tokenData = await verifyJWT(input.token);\n  \n        // Early return for invalid token data\n        if (!tokenData) {\n        throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation token\",\n        });\n        }\n        \n        // Validate token contents\n        if (\n        typeof tokenData.id !== \"string\" ||\n        typeof tokenData.studioId !== \"string\" ||\n        tokenData.type !== \"studio-invitation\"\n        ) {\n        throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation format\",\n        });\n        }\n        \n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n        id: tokenData.id,\n        studioId: tokenData.studioId,\n        status: \"PENDING\",\n        },\n        include: {\n        studio: true,\n        },\n        });\n        \n        if (!invitation) {\n        throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Invitation not found or already used\",\n        });\n        }\n        \n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n        where: { id: invitation.id },\n        data: { status: \"EXPIRED\" },\n        });\n        \n          throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n          });\n          }\n          \n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n        where: {\n        profileId_studioId: {\n        profileId: ctx.profile.id,\n        studioId: invitation.studioId,\n        },\n        },\n        include: {\n        studio: true,\n        },\n        });\n        \n        if (existingMembership) {\n        // Update invitation status\n        await ctx.db.studioInvitation.update({\n        where: { id: invitation.id },\n        data: {\n        status: \"ACCEPTED\",\n        },\n        });\n        \n          return {\n          status: \"already_member\",\n          membership: {\n          ...existingMembership,\n          studio: enhanceStudioWithLocationNames(existingMembership.studio),\n          },\n          };\n          }\n          \n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n        // Add user to studio\n        const membership = await tx.studioMember.create({\n        data: {\n        profileId: ctx.profile.id,\n        studioId: invitation.studioId,\n        role: invitation.role,\n        },\n        include: {\n        studio: true,\n        profile: true,\n        },\n        });\n        \n          // Update invitation status\n          await tx.studioInvitation.update({\n          where: { id: invitation.id },\n          data: {\n          status: \"ACCEPTED\",\n          },\n          });\n          \n          return membership;\n          });\n          \n        return {\n        status: \"accepted\",\n        membership: {\n        ...result,\n        studio: enhanceStudioWithLocationNames(result.studio),\n        },\n        };\n        } catch (error) {\n        if (error instanceof TRPCError) {\n        throw error;\n        }\n        \n        console.error(\"Accept invitation error:\", error);\n        throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to accept invitation\",\n        cause: error,\n        });\n        }\n        }),\n        });\n        ```\n        \n\nLooking at the error you're encountering, we need to modify the `validateInvitation` procedure to handle cases where a token is valid but the associated invitation is not found (possibly already used). Let's improve both the server-side validation and client-side error handling:\n\n### Server-side fix for `validateInvitation`:\n\n```typescript\nvalidateInvitation: publicProcedure\n  .input(\n    z.object({\n      token: z.string().min(1, \"Token is required\"),\n    }),\n  )\n  .query(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      // Early return for invalid token data\n      if (!tokenData) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation token\",\n        });\n      }\n\n      // Validate token contents\n      if (\n        typeof tokenData.id !== \"string\" ||\n        typeof tokenData.studioId !== \"string\" ||\n        tokenData.type !== \"studio-invitation\"\n      ) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation format\",\n        });\n      }\n\n      // First check if user is already a member of this studio\n      if (ctx.profile) {\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: tokenData.studioId,\n            },\n          },\n          include: {\n            studio: true,\n          },\n        });\n\n        if (existingMembership) {\n          return {\n            valid: true,\n            alreadyMember: true,\n            membership: {\n              ...existingMembership,\n              studio: enhanceStudioWithLocationNames(existingMembership.studio),\n            },\n            invitation: null,\n          };\n        }\n      }\n\n      // Find the invitation with related studio data\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n        },\n        include: {\n          studio: true,\n          invitedBy: true,\n        },\n      });\n\n      if (!invitation) {\n        // Check if there's any invitation with this email and studioId that's been accepted\n        if (tokenData.email) {\n          const acceptedInvitation = await ctx.db.studioInvitation.findFirst({\n            where: {\n              email: tokenData.email,\n              studioId: tokenData.studioId,\n              status: \"ACCEPTED\",\n            },\n            include: {\n              studio: true,\n            },\n          });\n\n          if (acceptedInvitation) {\n            return {\n              valid: true,\n              alreadyAccepted: true,\n              invitation: {\n                ...acceptedInvitation,\n                studio: enhanceStudioWithLocationNames(acceptedInvitation.studio),\n              },\n            };\n          }\n        }\n\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Handle different invitation statuses\n      if (invitation.status === \"ACCEPTED\") {\n        return {\n          valid: true,\n          alreadyAccepted: true,\n          invitation: {\n            ...invitation,\n            studio: enhanceStudioWithLocationNames(invitation.studio),\n          },\n        };\n      }\n\n      if (invitation.status === \"EXPIRED\" || invitation.expiresAt < new Date()) {\n        // Update status to expired if it's not already\n        if (invitation.status !== \"EXPIRED\") {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n        }\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      // Return validated invitation with enhanced studio data\n      return {\n        valid: true,\n        invitation: {\n          ...invitation,\n          studio: enhanceStudioWithLocationNames(invitation.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Validate invitation error:\", error);\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation link\",\n      });\n    }\n  }),\n```\n\n### Client-side fix for `invite-accept-content.tsx`:\n\nNow let's update the component to handle this improved response:\n\n```tsx\n// Update the component to handle the new response format\nconst { data: invitationData, isLoading: isValidating, error: invitationError } =\n  api.studio.validateInvitation.useQuery(\n    { token },\n    {\n      enabled: !!token,\n      retry: 1,\n      onError: (error) => {\n        setError(error.message);\n      },\n    },\n  );\n\n// Update the component to render differently based on whether the user is already a member\nuseEffect(() => {\n  // Handle already member case\n  if (invitationData?.alreadyMember && invitationData.membership?.studio) {\n    toast.info(\"You are already a member of this studio\");\n    router.push(`/studio/${invitationData.membership.studio.slug}`);\n  }\n  \n  // Handle already accepted invitation\n  if (invitationData?.alreadyAccepted && invitationData.invitation?.studio) {\n    toast.info(\"This invitation has already been accepted\");\n    \n    // If user is logged in, try to redirect to studio\n    if (profile) {\n      router.push(`/studio/${invitationData.invitation.studio.slug}`);\n    }\n  }\n\n  // Pre-fill email if it exists in the invitation\n  if (invitationData?.invitation?.email && !email) {\n    setEmail(invitationData.invitation.email);\n  }\n}, [invitationData, email, profile]);\n```\n\n### Update the `inviteChoreographerWithLink` method:\n\nLet's also update the URL format in `inviteChoreographerWithLink` to only include the token:\n\n```typescript\n// Update the return blocks of inviteChoreographerWithLink\n\n// For existing invitation\nreturn {\n  status: \"already_invited\",\n  invitation: existingInvitation,\n  inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n};\n\n// For new invitation\nreturn {\n  status: \"invited\",\n  invitation,\n  inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?token=${token}`,\n};\n```\n\nThese changes will:\n\n1. Check if the user is already a member of the studio before checking the invitation\n2. Handle cases where the invitation was already accepted\n3. Provide more specific response data\n4. Improve error handling\n5. Remove redundant query parameters from the invite link\n6. Fix the client-side code to handle these improvements\n\nWith these changes, the user will have a much better experience, especially in cases where they might be clicking an old link or are already members of the studio.\n\n\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2, Mail, Lock } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"~/components/ui/tabs\";\nimport { Label } from \"~/components/ui/label\";\n\ninterface InviteAcceptContentProps {\n  token: string;\n  studioName?: string;\n  role?: string;\n}\n\nexport function InviteAcceptContent({\n  token,\n  studioName = \"Studio\",\n  role,\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [signUpMode, setSignUpMode] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    refetch: refetchProfile,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n  });\n\n  // Validate the invitation token\n  const {\n    data: invitationData,\n    isLoading: isValidating,\n    error: invitationError,\n  } = api.studio.validateInvitation.useQuery(\n    { token },\n    {\n      enabled: !!token,\n      retry: 1,\n    },\n  );\n\n  useEffect(() => {\n    if (invitationError) setError(invitationError.message);\n  }, [invitationError]);\n\n  useEffect(() => {\n    // Handle already member case\n    if (invitationData?.alreadyMember && invitationData.membership?.studio) {\n      toast.info(\"You are already a member of this studio\");\n      router.push(`/studio/${invitationData.membership.studio.slug}`);\n    }\n\n    // Handle already accepted invitation\n    if (invitationData?.alreadyAccepted && invitationData.invitation?.studio) {\n      toast.info(\"This invitation has already been accepted\");\n\n      // If user is logged in, try to redirect to studio\n      if (profile) {\n        router.push(`/studio/${invitationData.invitation.studio.slug}`);\n      }\n    }\n\n    // Pre-fill email if it exists in the invitation\n    if (invitationData?.invitation?.email && !email) {\n      setEmail(invitationData.invitation.email);\n    }\n  }, [invitationData, email, profile]);\n\n  // When you need to access the data, do it directly:\n  useEffect(() => {\n    if (invitationData?.invitation?.email && !email) {\n      setEmail(invitationData.invitation.email);\n    }\n  }, [invitationData, email]);\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.status === \"accepted\" && data.membership?.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else if (\n          data.status === \"already_member\" &&\n          data.membership?.studio?.slug\n        ) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n      },\n    });\n\n  // Handle email/password sign in\n  const handleEmailSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim() || !password.trim()) {\n      toast.error(\"Please enter both email and password\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      if (signUpMode) {\n        // Handle sign up\n        if (password !== confirmPassword) {\n          toast.error(\"Passwords do not match\");\n          setProcessing(false);\n          return;\n        }\n\n        const { error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: {\n            emailRedirectTo: callbackURL.toString(),\n          },\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1500);\n      } else {\n        // Handle sign in\n        const { error } = await supabase.auth.signInWithPassword({\n          email,\n          password,\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1000);\n      }\n    } catch (err) {\n      console.error(\"Auth error:\", err);\n      toast.error(err instanceof Error ? err.message : \"Authentication failed\");\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // Handle Google sign in\n  const handleGoogleSignIn = async () => {\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      const { error } = await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: {\n          redirectTo: callbackURL.toString(),\n        },\n      });\n\n      if (error) throw error;\n    } catch (err) {\n      console.error(\"Google auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Google authentication failed\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render auth form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You&apos;ve been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n          <p className=\"text-center text-sm text-muted-foreground\">\n            Sign in or create an account to accept this invitation\n          </p>\n        </NeoCard>\n\n        <div className=\"space-y-4\">\n          {/* Google Sign In */}\n          <NeoButton\n            className=\"w-full justify-center\"\n            variant=\"outline\"\n            size=\"lg\"\n            onClick={handleGoogleSignIn}\n            disabled={processing}\n          >\n            {processing && <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />}\n            Continue with Google\n          </NeoButton>\n\n          <div className=\"relative my-4\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <span className=\"w-full border-t border-gray-300\" />\n            </div>\n            <div className=\"relative flex justify-center text-xs uppercase\">\n              <span className=\"bg-white px-2 text-muted-foreground\">\n                Or continue with\n              </span>\n            </div>\n          </div>\n\n          {/* Email/Password Auth */}\n          <Tabs\n            defaultValue=\"signin\"\n            className=\"w-full\"\n            onValueChange={(value) => setSignUpMode(value === \"signup\")}\n          >\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"signin\">Sign In</TabsTrigger>\n              <TabsTrigger value=\"signup\">Sign Up</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"signin\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Signing in...\n                    </>\n                  ) : (\n                    \"Sign In\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n\n            <TabsContent value=\"signup\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"confirm-password\"\n                      type=\"password\"\n                      value={confirmPassword}\n                      onChange={(e) => setConfirmPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Creating account...\n                    </>\n                  ) : (\n                    \"Create Account\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You&apos;ve been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You&apos;re signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\nStream closed\ni am getting this error when i try to run the code\nThe error you're encountering is because we've added new return types to the `validateInvitation` procedure in our server-side code, but we haven't updated the TypeScript interfaces in the client. Let's fix this by updating the interface for the response type in the `invite-accept-content.tsx` file:\n\n```tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2, Mail, Lock } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"~/components/ui/tabs\";\nimport { Label } from \"~/components/ui/label\";\n\n// Add type definitions for the API responses\ninterface Studio {\n  slug: string;\n  name: string;\n  logo?: string | null;\n  description?: string | null;\n  id: string;\n  // Add other studio properties as needed\n}\n\ninterface Invitation {\n  id: string;\n  email: string;\n  role: string;\n  status: string;\n  studio: Studio | null;\n  // Add other invitation properties as needed\n}\n\ninterface Membership {\n  id: string;\n  role: string;\n  studio: Studio | null;\n  // Add other membership properties as needed\n}\n\ninterface InvitationResponse {\n  valid: boolean;\n  invitation?: Invitation;\n  alreadyMember?: boolean;\n  alreadyAccepted?: boolean;\n  membership?: Membership;\n}\n\ninterface InviteAcceptContentProps {\n  token: string;\n  studioName?: string;\n  role?: string;\n}\n\nexport function InviteAcceptContent({\n  token,\n  studioName = \"Studio\",\n  role,\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [signUpMode, setSignUpMode] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    refetch: refetchProfile,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n  });\n\n  // Validate the invitation token\n  const {\n    data: invitationData,\n    isLoading: isValidating,\n    error: invitationError,\n  } = api.studio.validateInvitation.useQuery(\n    { token },\n    {\n      enabled: !!token,\n      retry: 1,\n    },\n  ) as { \n    data: InvitationResponse | undefined; \n    isLoading: boolean; \n    error: Error | null \n  };\n\n  useEffect(() => {\n    if (invitationError) setError(invitationError.message);\n  }, [invitationError]);\n\n  useEffect(() => {\n    // Handle already member case\n    if (invitationData?.alreadyMember && invitationData.membership?.studio) {\n      toast.info(\"You are already a member of this studio\");\n      router.push(`/studio/${invitationData.membership.studio.slug}`);\n    }\n\n    // Handle already accepted invitation\n    if (invitationData?.alreadyAccepted && invitationData.invitation?.studio) {\n      toast.info(\"This invitation has already been accepted\");\n\n      // If user is logged in, try to redirect to studio\n      if (profile) {\n        router.push(`/studio/${invitationData.invitation.studio.slug}`);\n      }\n    }\n\n    // Pre-fill email if it exists in the invitation\n    if (invitationData?.invitation?.email && !email) {\n      setEmail(invitationData.invitation.email);\n    }\n  }, [invitationData, email, profile, router]);\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.status === \"accepted\" && data.membership?.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else if (\n          data.status === \"already_member\" &&\n          data.membership?.studio?.slug\n        ) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n      },\n    });\n\n  // Handle email/password sign in\n  const handleEmailSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim() || !password.trim()) {\n      toast.error(\"Please enter both email and password\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      if (signUpMode) {\n        // Handle sign up\n        if (password !== confirmPassword) {\n          toast.error(\"Passwords do not match\");\n          setProcessing(false);\n          return;\n        }\n\n        const { error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: {\n            emailRedirectTo: callbackURL.toString(),\n          },\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1500);\n      } else {\n        // Handle sign in\n        const { error } = await supabase.auth.signInWithPassword({\n          email,\n          password,\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1000);\n      }\n    } catch (err) {\n      console.error(\"Auth error:\", err);\n      toast.error(err instanceof Error ? err.message : \"Authentication failed\");\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // Handle Google sign in\n  const handleGoogleSignIn = async () => {\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      const { error } = await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: {\n          redirectTo: callbackURL.toString(),\n        },\n      });\n\n      if (error) throw error;\n    } catch (err) {\n      console.error(\"Google auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Google authentication failed\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Get role and studio name from invitationData if available\n  const displayRole = role || invitationData?.invitation?.role || \"Choreographer\";\n  const displayStudioName = studioName || invitationData?.invitation?.studio?.name || \"Studio\";\n\n  // Render auth form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You&apos;ve been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {displayRole.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n          <p className=\"text-center text-sm text-muted-foreground\">\n            Sign in or create an account to accept this invitation\n          </p>\n        </NeoCard>\n\n        <div className=\"space-y-4\">\n          {/* Google Sign In */}\n          <NeoButton\n            className=\"w-full justify-center\"\n            variant=\"outline\"\n            size=\"lg\"\n            onClick={handleGoogleSignIn}\n            disabled={processing}\n          >\n            {processing && <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />}\n            Continue with Google\n          </NeoButton>\n\n          <div className=\"relative my-4\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <span className=\"w-full border-t border-gray-300\" />\n            </div>\n            <div className=\"relative flex justify-center text-xs uppercase\">\n              <span className=\"bg-white px-2 text-muted-foreground\">\n                Or continue with\n              </span>\n            </div>\n          </div>\n\n          {/* Email/Password Auth */}\n          <Tabs\n            defaultValue=\"signin\"\n            className=\"w-full\"\n            onValueChange={(value) => setSignUpMode(value === \"signup\")}\n          >\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"signin\">Sign In</TabsTrigger>\n              <TabsTrigger value=\"signup\">Sign Up</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"signin\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Signing in...\n                    </>\n                  ) : (\n                    \"Sign In\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n\n            <TabsContent value=\"signup\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"confirm-password\"\n                      type=\"password\"\n                      value={confirmPassword}\n                      onChange={(e) => setConfirmPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w\ncontinue","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4388}}},{"id":{"replica_id":0,"value":44},"start":36540,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4389}}},{"id":{"replica_id":0,"value":127},"start":36705,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4390}}},{"id":{"replica_id":0,"value":421},"start":36794,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4391}}},{"id":{"replica_id":0,"value":422},"start":41029,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4392}}},{"id":{"replica_id":0,"value":522},"start":41102,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4393}}},{"id":{"replica_id":0,"value":557},"start":67916,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4394}}},{"id":{"replica_id":0,"value":558},"start":70919,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4395}}},{"id":{"replica_id":0,"value":724},"start":98303,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4396}}},{"id":{"replica_id":0,"value":725},"start":103297,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4397}}},{"id":{"replica_id":0,"value":1001},"start":113539,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4398}}},{"id":{"replica_id":0,"value":1173},"start":129772,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4399}}},{"id":{"replica_id":0,"value":1174},"start":143630,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4400}}},{"id":{"replica_id":0,"value":1713},"start":161439,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4401}}},{"id":{"replica_id":0,"value":1812},"start":161464,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4402}}},{"id":{"replica_id":0,"value":1993},"start":161519,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4403}}},{"id":{"replica_id":0,"value":2094},"start":188158,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4404}}},{"id":{"replica_id":0,"value":2778},"start":194965,"metadata":{"role":"assistant","status":{"Error":"The final message must be from the user. To provide a system prompt, you must provide the system prompt followed by a user prompt."},"timestamp":{"replica_id":0,"value":4405}}},{"id":{"replica_id":0,"value":2779},"start":194966,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4406}}},{"id":{"replica_id":0,"value":3032},"start":210388,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4407}}},{"id":{"replica_id":0,"value":3153},"start":210439,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4408}}},{"id":{"replica_id":0,"value":3154},"start":225592,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4409}}}],"summary":"Looking at the `inviteChoreographerWithLink` procedure, there are several optimizations we can make to improve maintainability and readability:","slash_command_output_sections":[{"range":{"start":0,"end":1280},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1275},"icon":"Library","label":"General","metadata":null},{"range":{"start":1281,"end":5329},"icon":"Library","label":"next-tw-zod-zustand-shad","metadata":null},{"range":{"start":5330,"end":32350},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":32351,"end":36336},"icon":"TextSnippet","label":"dance-book-app/src/server/api/routers/studio.ts, Lines 634 to 754","metadata":null},{"range":{"start":41102,"end":67914},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":70919,"end":98205},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":103297,"end":113446},"icon":"File","label":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx","metadata":{"path":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx"}},{"range":{"start":113539,"end":129744},"icon":"Warning","label":"Diagnostics: 9 errors","metadata":null},{"range":{"start":113551,"end":121031},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":null},{"range":{"start":113623,"end":113776},"icon":"XCircle","label":"Unexpected any. Specify a different type.","metadata":null},{"range":{"start":113777,"end":113903},"icon":"XCircle","label":"Unexpected any. Specify a different type.","metadata":null},{"range":{"start":113904,"end":115930},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n  Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.","metadata":null},{"range":{"start":115931,"end":117925},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: str...'.\n  Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; };...'.","metadata":null},{"range":{"start":117926,"end":119979},"icon":"XCircle","label":"Type '(data: MembershipData) => void' is not assignable to type '(data: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }, v...'.\n  Types of parameters 'data' and 'data' are incompatible.\n    Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }' is not assignable to type 'MembershipData'.\n      Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: $Enums.StudioRole; }; }' is not assignable to type 'MembershipData'.\n        The types of 'membership.studio' are incompatible between these types.\n          Type '({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; openingHours: JsonValue; isActive: boolean; id: string; createdAt: Date; updatedAt: Date; } & { ...; }) | null' is not assignable to type '{ slug?: string | undefined; } | undefined'.\n            Type 'null' is not assignable to type '{ slug?: string | undefined; } | undefined'.","metadata":null},{"range":{"start":119980,"end":121031},"icon":"XCircle","label":"Type '(error: Error) => void' is not assignable to type '(error: TRPCClientErrorLike<{ input: { token: string; }; output: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole...'.\n  Types of parameters 'error' and 'error' are incompatible.\n    Property 'name' is missing in type 'TRPCClientErrorBase<{ data: { zodError: typeToFlattenedError<any, string> | null; code: \"PARSE_ERROR\" | \"BAD_REQUEST\" | \"INTERNAL_SERVER_ERROR\" | \"NOT_IMPLEMENTED\" | \"BAD_GATEWAY\" | ... 13 more ... | \"CLIENT_CLOSED_REQUEST\"; httpStatus: number; path?: string | undefined; stack?: string | undefined; }; message: strin...' but required in type 'Error'.","metadata":null},{"range":{"start":121032,"end":128512},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":null},{"range":{"start":121104,"end":121257},"icon":"XCircle","label":"Unexpected any. Specify a different type.","metadata":null},{"range":{"start":121258,"end":121384},"icon":"XCircle","label":"Unexpected any. Specify a different type.","metadata":null},{"range":{"start":121385,"end":123411},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n  Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.","metadata":null},{"range":{"start":123412,"end":125406},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: str...'.\n  Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; ... 8 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 8 more ...; invitedById: string; };...'.","metadata":null},{"range":{"start":125407,"end":127460},"icon":"XCircle","label":"Type '(data: MembershipData) => void' is not assignable to type '(data: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }, v...'.\n  Types of parameters 'data' and 'data' are incompatible.\n    Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole; }; } | { ...; }' is not assignable to type 'MembershipData'.\n      Type '{ status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; ... 4 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: $Enums.StudioRole; }; }' is not assignable to type 'MembershipData'.\n        The types of 'membership.studio' are incompatible between these types.\n          Type '({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; country: string; logo: string | null; openingHours: JsonValue; isActive: boolean; id: string; createdAt: Date; updatedAt: Date; } & { ...; }) | null' is not assignable to type '{ slug?: string | undefined; } | undefined'.\n            Type 'null' is not assignable to type '{ slug?: string | undefined; } | undefined'.","metadata":null},{"range":{"start":127461,"end":128512},"icon":"XCircle","label":"Type '(error: Error) => void' is not assignable to type '(error: TRPCClientErrorLike<{ input: { token: string; }; output: { status: string; membership: { studio: ({ name: string; slug: string; description: string | null; address: string; city: string; state: string; postalCode: string; ... 6 more ...; updatedAt: Date; } & { ...; }) | null; ... 5 more ...; role: StudioRole...'.\n  Types of parameters 'error' and 'error' are incompatible.\n    Property 'name' is missing in type 'TRPCClientErrorBase<{ data: { zodError: typeToFlattenedError<any, string> | null; code: \"PARSE_ERROR\" | \"BAD_REQUEST\" | \"INTERNAL_SERVER_ERROR\" | \"NOT_IMPLEMENTED\" | \"BAD_GATEWAY\" | ... 13 more ... | \"CLIENT_CLOSED_REQUEST\"; httpStatus: number; path?: string | undefined; stack?: string | undefined; }; message: strin...' but required in type 'Error'.","metadata":null},{"range":{"start":128513,"end":128825},"icon":"File","label":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx","metadata":null},{"range":{"start":128578,"end":128825},"icon":"XCircle","label":"Object literal may only specify known properties, and 'role' does not exist in type '{ studioId: string; email: string; }'.","metadata":null},{"range":{"start":128826,"end":129743},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":null},{"range":{"start":128874,"end":129308},"icon":"XCircle","label":"Object literal may only specify known properties, and 'acceptedAt' does not exist in type '(Without<StudioInvitationUpdateInput, StudioInvitationUncheckedUpdateInput> & StudioInvitationUncheckedUpdateInput) | (Without<...> & StudioInvitationUpdateInput)'.","metadata":null},{"range":{"start":129309,"end":129743},"icon":"XCircle","label":"Object literal may only specify known properties, and 'acceptedAt' does not exist in type '(Without<StudioInvitationUpdateInput, StudioInvitationUncheckedUpdateInput> & StudioInvitationUncheckedUpdateInput) | (Without<...> & StudioInvitationUpdateInput)'.","metadata":null},{"range":{"start":143630,"end":158080},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}},{"range":{"start":161519,"end":188148},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":194966,"end":210373},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}}]}
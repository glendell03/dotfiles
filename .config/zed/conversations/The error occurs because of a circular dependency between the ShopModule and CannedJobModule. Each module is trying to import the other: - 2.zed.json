{"id":"cb507d01-5327-44d4-bbe2-3f6f67cf2ef1","zed":"context","version":"0.4.0","text":"\nDO NOT GIVE ME HIGH-LEVEL THEORY. IF I ASK FOR A FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT \"Here's how you can blablabla\"\n\nBe casual unless otherwise specified\nBe terse and concise\nSuggest solutions that I didn’t think about—anticipate my needs\nTreat me as an expert\nBe accurate and thorough\nGive the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer\nValue good arguments over authorities, the source is irrelevant\nConsider new technologies and contrarian ideas, not just conventional wisdom\nYou may use high levels of speculation or prediction, just flag it for me\nNo moral lectures\nDiscuss safety only when it's crucial and non-obvious\nIf your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward\nCite sources whenever possible at the end, not inline\nNo need to mention your knowledge cutoff\nNo need to disclose you're an AI\nPlease respect my prettier preferences when you provide code\nSplit into multiple responses if one response isn't enough to answer the question\nFocus on readability over being performant\nFully implement all requested functionality\nLeave NO todos, placeholders, or missing pieces\n\nYou are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns. Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.\n\n## TypeScript General Guidelines\n\n### Basic Principles\n\n- Use English for all code and documentation.\n- Always declare the type of each variable and function (parameters and return value).\n- Avoid using any.\n- Create necessary types.\n- Use JSDoc to document public classes and methods.\n- Don't leave blank lines within a function.\n- One export per file.\n\n### Nomenclature\n\n- Use PascalCase for classes.\n- Use camelCase for variables, functions, and methods.\n- Use kebab-case for file and directory names.\n- Use UPPERCASE for environment variables.\n- Avoid magic numbers and define constants.\n- Start each function with a verb.\n- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.\n- Use complete words instead of abbreviations and correct spelling.\n- Except for standard abbreviations like API, URL, etc.\n- Except for well-known abbreviations:\n  - i, j for loops\n  - err for errors\n  - ctx for contexts\n  - req, res, next for middleware function parameters\n\n### Functions\n\n- In this context, what is understood as a function will also apply to a method.\n- Write short functions with a single purpose. Less than 20 instructions.\n- Name functions with a verb and something else.\n- If it returns a boolean, use isX or hasX, canX, etc.\n- If it doesn't return anything, use executeX or saveX, etc.\n- Avoid nesting blocks by:\n  - Early checks and returns.\n  - Extraction to utility functions.\n- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.\n- Use arrow functions for simple functions (less than 3 instructions).\n- Use named functions for non-simple functions.\n- Use default parameter values instead of checking for null or undefined.\n- Reduce function parameters using RO-RO\n  - Use an object to pass multiple parameters.\n  - Use an object to return results.\n  - Declare necessary types for input arguments and output.\n- Use a single level of abstraction.\n\n### Data\n\n- Don't abuse primitive types and encapsulate data in composite types.\n- Avoid data validations in functions and use classes with internal validation.\n- Prefer immutability for data.\n- Use readonly for data that doesn't change.\n- Use as const for literals that don't change.\n\n### Classes\n\n- Follow SOLID principles.\n- Prefer composition over inheritance.\n- Declare interfaces to define contracts.\n- Write small classes with a single purpose.\n  - Less than 200 instructions.\n  - Less than 10 public methods.\n  - Less than 10 properties.\n\n### Exceptions\n\n- Use exceptions to handle errors you don't expect.\n- If you catch an exception, it should be to:\n  - Fix an expected problem.\n  - Add context.\n  - Otherwise, use a global handler.\n\n### Testing\n\n- Follow the Arrange-Act-Assert convention for tests.\n- Name test variables clearly.\n- Follow the convention: inputX, mockX, actualX, expectedX, etc.\n- Write unit tests for each public function.\n- Use test doubles to simulate dependencies.\n  - Except for third-party dependencies that are not expensive to execute.\n- Write acceptance tests for each module.\n- Follow the Given-When-Then convention.\n\n## Specific to NestJS\n\n### Basic Principles\n\n- Use modular architecture\n- Encapsulate the API in modules.\n  - One module per main domain/route.\n  - One controller for its route.\n  - And other controllers for secondary routes.\n  - A models folder with data types.\n  - DTOs validated with class-validator for inputs.\n  - Declare simple types for outputs.\n  - A services module with business logic and persistence.\n  - Entities with MikroORM for data persistence.\n  - One service per entity.\n- A core module for nest artifacts\n  - Global filters for exception handling.\n  - Global middlewares for request management.\n  - Guards for permission management.\n  - Interceptors for request management.\n- A shared module for services shared between modules.\n  - Utilities\n  - Shared business logic\n\n### Testing\n\n- Use the standard Jest framework for testing.\n- Write tests for each controller and service.\n- Write end to end tests for each api module.\n- Add a admin/test method to each controller as a smoke test.\ncarsu-be/src/shop\n__mocks__\n```ts carsu-be/src/shop/__mocks__/shop.mock.ts\nimport { Decimal } from '@prisma/client/runtime/library';\nimport { ShopCreateDto } from '../dto/shop-create.dto';\n\nexport const CREATE_SHOP: ShopCreateDto = {\n  name: 'Test Shop',\n  vatNumber: 'GB123456789',\n  contact: {\n    email: 'test@example.com',\n    phone: '+44123456789',\n  },\n  address: {\n    addressLine1: '123 Test St',\n    addressLine2: 'Suite 1',\n    zipcode: '12345',\n    city: 'London',\n    country: 'UK',\n  },\n  logo: 'https://example.com/logo.png',\n  hourlyRate: new Decimal(75.0),\n  vat: {\n    vat: new Decimal(20.0),\n    countryCode: 'GB',\n  },\n};\n```\n\n\ndto\n```ts carsu-be/src/shop/dto/shop-create.dto.ts\nimport {\n  IsString,\n  IsNumber,\n  IsBoolean,\n  IsUrl,\n  IsOptional,\n  ValidateNested\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { Decimal } from '@prisma/client/runtime/library';\nimport { ContactCreateDto } from '@contact/dto/contact-create.dto';\nimport { AddressCreateDto } from '@address/dto/address-create.dto';\nimport { VatCreateDto } from '@vat/dto/vat-create.dto';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class ShopCreateDto {\n  @ApiProperty({ example: 'Test Shop', type: 'string' })\n  @IsString()\n  name: string;\n\n  @ApiProperty({ example: 'GB123456789', type: 'string' })\n  @IsString()\n  vatNumber: string;\n\n  @ApiProperty({\n    example: { email: 'test@example.com', phone: '+44123456789' },\n  })\n  @ValidateNested()\n  @Type(() => ContactCreateDto)\n  contact: ContactCreateDto;\n\n  @ApiProperty({\n    example: {\n      addressLine1: '123 Test St',\n      addressLine2: 'Suite 1',\n      zipcode: '12345',\n      city: 'London',\n      country: 'UK',\n    },\n  })\n  @ValidateNested()\n  @Type(() => AddressCreateDto)\n  address: AddressCreateDto;\n\n  @ApiProperty({ example: 'https://example.com/logo.png', type: 'string' })\n  @IsUrl()\n  logo: string;\n\n  @ApiProperty({ example: true, required: false, type: 'boolean' })\n  @IsBoolean()\n  @IsOptional()\n  enabled?: boolean;\n\n  @ApiProperty({ example: 75.0, type: 'number' })\n  @IsNumber()\n  @Type(() => Number)\n  hourlyRate: Decimal;\n\n  @ApiProperty({\n    example: { vat: 20.0, countryCode: 'GB' },\n  })\n  @ValidateNested()\n  @Type(() => VatCreateDto)\n  vat: VatCreateDto;\n}\n```\n\n```ts carsu-be/src/shop/dto/shop-update.dto.ts\nimport { OmitType, PartialType } from '@nestjs/mapped-types';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { ShopCreateDto } from './shop-create.dto';\nimport { Type } from 'class-transformer';\nimport { ValidateNested } from 'class-validator';\nimport { ContactUpdateDto } from '@app/contact/dto/contact-update.dto';\nimport { AddressUpdateDto } from '@app/address/dto/address-update.dto';\nimport { VatUpdateDto } from '@app/vat/dto/vat-update.dto';\n\nexport class ShopUpdateDto extends PartialType(\n  OmitType(ShopCreateDto, ['contact', 'address', 'vat'] as const),\n) {\n  @ApiProperty({\n    example: { email: 'test@example.com', phone: '+44123456789' },\n  })\n  @ValidateNested()\n  @Type(() => ContactUpdateDto)\n  contact?: ContactUpdateDto;\n\n  @ApiProperty({\n    example: {\n      addressLine1: '123 Test St',\n      addressLine2: 'Suite 1',\n      zipcode: '12345',\n      city: 'London',\n      country: 'UK',\n    },\n  })\n  @ValidateNested()\n  @Type(() => AddressUpdateDto)\n  address?: AddressUpdateDto;\n\n  @ApiProperty({\n    example: { vat: 20.0, countryCode: 'GB' },\n  })\n  @ValidateNested()\n  @Type(() => VatUpdateDto)\n  vat?: VatUpdateDto;\n}\n```\n\n\ninterfaces\n```ts carsu-be/src/shop/interfaces/shop.interface.ts\n```\n\n\n```ts carsu-be/src/shop/shop.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ShopController } from './shop.controller';\nimport { ShopService } from './shop.service';\nimport { BadRequestException } from '@nestjs/common';\nimport { CREATE_SHOP } from './__mocks__/shop.mock';\nimport { ShopCreateDto } from './dto/shop-create.dto';\n\ndescribe('ShopController', () => {\n  let controller: ShopController;\n  let service: ShopService;\n\n  const mockCreateShopDto: ShopCreateDto = CREATE_SHOP;\n\n  const mockCreatedShop = {\n    id: '123e4567-e89b-12d3-a456-426614174000',\n    ...mockCreateShopDto,\n    enabled: true,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n\n  const mockShopService = {\n    create: jest.fn(),\n    update: jest.fn(),\n    getShop: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [ShopController],\n      providers: [\n        {\n          provide: ShopService,\n          useValue: mockShopService,\n        },\n      ],\n    }).compile();\n\n    controller = module.get<ShopController>(ShopController);\n    service = module.get<ShopService>(ShopService);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('constructor', () => {\n    it('should be defined', () => {\n      expect(controller).toBeDefined();\n    });\n  });\n\n  describe('createShop', () => {\n    it('should successfully create a shop', async () => {\n      mockShopService.create.mockResolvedValue(mockCreatedShop);\n\n      const result = await controller.create(mockCreateShopDto);\n\n      expect(result).toEqual(mockCreatedShop);\n      expect(service.create).toHaveBeenCalledWith(mockCreateShopDto);\n      expect(service.create).toHaveBeenCalledTimes(1);\n    });\n\n    it('should throw BadRequestException when service fails', async () => {\n      const errorMessage = 'Failed to create shop';\n      mockShopService.create.mockRejectedValue(\n        new BadRequestException(errorMessage),\n      );\n\n      await expect(controller.create(mockCreateShopDto)).rejects.toThrow(\n        BadRequestException,\n      );\n\n      expect(service.create).toHaveBeenCalledWith(mockCreateShopDto);\n      expect(service.create).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle missing optional fields', async () => {\n      const dtoWithoutOptionals = {\n        ...mockCreateShopDto,\n        address: {\n          ...mockCreateShopDto.address,\n          addressLine2: undefined,\n        },\n      };\n      mockShopService.create.mockResolvedValue({\n        ...mockCreatedShop,\n        address: {\n          ...mockCreatedShop.address,\n          addressLine2: undefined,\n        },\n      });\n\n      const result = await controller.create(dtoWithoutOptionals);\n\n      expect(result.address.addressLine2).toBeUndefined();\n      expect(service.create).toHaveBeenCalledWith(dtoWithoutOptionals);\n    });\n  });\n\n  describe('updateShop', () => {\n    const shopId = mockCreatedShop.id;\n    const updateDto = {\n      name: 'Updated Shop Name',\n      address: {\n        addressLine1: 'New Address Line 1',\n        city: 'New City',\n        country: 'New Country',\n        postalCode: '12345',\n      },\n    };\n\n    it('should successfully update a shop', async () => {\n      const updatedShop = { ...mockCreatedShop, ...updateDto };\n      mockShopService.update.mockResolvedValue(updatedShop);\n\n      const result = await controller.update(shopId, updateDto);\n\n      expect(result).toEqual(updatedShop);\n      expect(service.update).toHaveBeenCalledWith(shopId, updateDto);\n      expect(service.update).toHaveBeenCalledTimes(1);\n    });\n\n    it('should throw BadRequestException when update fails', async () => {\n      mockShopService.update.mockRejectedValue(\n        new BadRequestException('Failed to update shop'),\n      );\n\n      await expect(controller.update(shopId, updateDto)).rejects.toThrow(\n        BadRequestException,\n      );\n      expect(service.update).toHaveBeenCalledWith(shopId, updateDto);\n      expect(service.update).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('getShop', () => {\n    const shopId = mockCreatedShop.id;\n\n    it('should successfully get a shop', async () => {\n      mockShopService.getShop.mockResolvedValue(mockCreatedShop);\n\n      const result = await controller.getShop(shopId);\n\n      expect(result).toEqual(mockCreatedShop);\n      expect(service.getShop).toHaveBeenCalledWith(shopId);\n      expect(service.getShop).toHaveBeenCalledTimes(1);\n    });\n\n    it('should throw BadRequestException when shop is not found', async () => {\n      mockShopService.getShop.mockRejectedValue(\n        new BadRequestException('Shop not found'),\n      );\n\n      await expect(controller.getShop(shopId)).rejects.toThrow(\n        BadRequestException,\n      );\n      expect(service.getShop).toHaveBeenCalledWith(shopId);\n      expect(service.getShop).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n```\n\n```ts carsu-be/src/shop/shop.controller.ts\nimport {\n  Controller,\n  Post,\n  Body,\n  Put,\n  Param,\n  Get,\n  UseGuards,\n  Request,\n} from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopCreateDto } from './dto/shop-create.dto';\nimport { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';\nimport { ShopUpdateDto } from './dto/shop-update.dto';\nimport { IAuthRequest } from '@auth/interfaces';\n\n@ApiTags('Shops')\n@Controller('shop')\nexport class ShopController {\n  constructor(private readonly shopService: ShopService) {}\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a shop by ID' })\n  @ApiResponse({ status: 200, description: 'Shop successfully retrieved.' })\n  @ApiResponse({ status: 404, description: 'Shop not found.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  async getShop(@Param('id') id: string) {\n    return await this.shopService.getShop({ id });\n  }\n\n  @Post('create')\n  @ApiOperation({ summary: 'Create a new shop' })\n  @ApiResponse({ status: 201, description: 'Shop successfully created.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  async create(@Body() data: ShopCreateDto, @Request() req: IAuthRequest) {\n    return await this.shopService.create(req?.auth?.userId, data);\n  }\n\n  @Put('update/:id')\n  @ApiOperation({ summary: 'Update a shop' })\n  @ApiResponse({ status: 200, description: 'Shop successfully updated.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  async update(@Param('id') id: string, @Body() payload: ShopUpdateDto) {\n    return await this.shopService.update({\n      where: { id },\n      payload,\n    });\n  }\n}\n```\n\n```ts carsu-be/src/shop/shop.module.ts\nimport { Module } from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopController } from './shop.controller';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { AuthModule } from '@auth/auth.module';\nimport { UserModule } from '@user/user.module';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\nimport { WorkManagementModule } from '@app/work-management/work-management.module';\n\n@Module({\n  imports: [PrismaModule, AuthModule, UserModule, CannedJobModule, ,],\n  providers: [ShopService],\n  controllers: [ShopController],\n  exports: [ShopService],\n})\nexport class ShopModule {}\n```\n\n```ts carsu-be/src/shop/shop.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ShopService } from './shop.service';\n\ndescribe('ShopService', () => {\n  let service: ShopService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [ShopService],\n    }).compile();\n\n    service = module.get<ShopService>(ShopService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/shop/shop.service.ts\nimport {\n  Injectable,\n  Logger,\n  BadRequestException,\n  NotFoundException,\n} from '@nestjs/common';\n\nimport { Employee, Prisma } from '@prisma/client';\nimport { PrismaService } from '@prisma/prisma.service';\nimport { ShopCreateDto } from './dto/shop-create.dto';\nimport { ContactService } from '@contact/contact.service';\nimport { ErrorHandler } from '@exceptions/handlers';\nimport { ShopNotFoundException } from '@exceptions/shop/shop-not-found.exception';\nimport { ShopCreateException } from '@exceptions/shop/shop-create.exception';\nimport { ShopUpdateException } from '@exceptions/shop/shop-update.exception';\nimport { ShopUpdateDto } from './dto/shop-update.dto';\nimport { AuthService } from '@auth/auth.service';\nimport { UserService } from '@user/user.service';\nimport { UserNotFoundException } from '@exceptions/user';\nimport { CannedJobService } from '@app/canned-job/canned-job.service';\nimport { preDefinedCannedJobs } from '@app/constants/pre-defined-canned-jobs';\n\n@Injectable()\nexport class ShopService {\n  private readonly logger = new Logger(ShopService.name);\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly authService: AuthService,\n    private readonly userService: UserService,\n    private readonly cannedJobService: CannedJobService,\n  ) {}\n\n  async isEmployee(\n    employeeWhereUniqueInput: Prisma.EmployeeWhereUniqueInput,\n  ): Promise<boolean> {\n    try {\n      const employee: Employee = await this.prisma.employee.findUnique({\n        where: employeeWhereUniqueInput,\n      });\n      if (!employee) return false;\n      return true;\n    } catch (err) {\n      this.logger.log(err);\n      return false;\n    }\n  }\n\n  async getShop(shopWhereUniqueInput: Prisma.ShopWhereUniqueInput) {\n    try {\n      const shop = await this.prisma.shop.findUnique({\n        where: shopWhereUniqueInput,\n        include: {\n          contact: true,\n          address: true,\n          vat: true,\n        },\n      });\n\n      if (!shop)\n        throw new NotFoundException(JSON.stringify(shopWhereUniqueInput));\n      return shop;\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ShopNotFoundException,\n      );\n    }\n  }\n\n  async create(authId: string, payload: ShopCreateDto) {\n    const {\n      name,\n      vatNumber,\n      logo,\n      enabled = true,\n      hourlyRate,\n      address,\n      vat,\n      contact: rawContact,\n    } = payload;\n\n    const { addressLine1, city, country, zipcode } = address;\n    address.addressLine2 = address.addressLine2?.trim() || '';\n    const { addressLine2 } = address;\n\n    const contact = {\n      ...rawContact,\n      phone: ContactService.cleanPhoneNumber(rawContact.phone),\n    };\n\n    // TODO: Auth id should be get from authorization header\n    const user = await this.userService.getUserByAuthId({ authId });\n    if (!user) {\n      throw new UserNotFoundException(JSON.stringify(payload));\n    }\n\n    try {\n      const shopData: Prisma.ShopCreateInput = {\n        name,\n        vatNumber,\n        logo,\n        enabled,\n        hourlyRate,\n        contact: { create: contact },\n        address: {\n          connectOrCreate: {\n            where: {\n              addressLine1_city_country_zipcode_addressLine2: {\n                addressLine1,\n                city,\n                country,\n                zipcode,\n                addressLine2,\n              },\n            },\n            create: address,\n          },\n        },\n        vat: { create: vat },\n        employees: {\n          create: {\n            userId: user.id,\n            gdprConfirmedAt: new Date(),\n            tcConfirmedAt: new Date(),\n          },\n        },\n      };\n\n      return await this.prisma.$transaction(async (tx) => {\n        const shop = await tx.shop.create({\n          data: shopData,\n          include: {\n            contact: true,\n            address: true,\n            vat: true,\n          },\n        });\n\n        const formattedCannedJobs = preDefinedCannedJobs.map((jobGroup) => {\n          return {\n            serviceGroups: jobGroup.map((item, index) => ({\n              description: item.description,\n              category: item.category,\n              macroCategory: null, // Add this if needed\n              position: index + 1, // Add a default position\n              shopId: shop.id,\n              services: item.services\n                ? item.services.map((service, index) => ({\n                    ...service,\n                    position: index + 1, // Add position to each service\n                  }))\n                : [],\n            })),\n          };\n        });\n\n        // Create canned jobs within the same transaction\n        await this.cannedJobService.createMany(\n          shop.id,\n          formattedCannedJobs,\n          tx,\n        );\n\n        await this.authService.updateUserPublicMetadata(authId, {\n          shopId: shop.id,\n        });\n\n        return shop;\n      });\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ShopCreateException,\n      );\n    }\n  }\n\n  async update(params: {\n    where: Prisma.ShopWhereUniqueInput;\n    payload: ShopUpdateDto;\n  }) {\n    try {\n      const { where, payload } = params;\n      const { name, vatNumber, logo, enabled, hourlyRate, address, vat } =\n        payload;\n      let { contact } = payload;\n      contact.phone = ContactService.cleanPhoneNumber(contact.phone);\n\n      return await this.prisma.shop.update({\n        where,\n        data: {\n          name,\n          vatNumber,\n          logo,\n          enabled,\n          hourlyRate,\n          contact: {\n            update: contact,\n          },\n          address: {\n            update: address,\n          },\n          vat: {\n            update: vat,\n          },\n        },\n      });\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ShopUpdateException,\n      );\n    }\n  }\n}\n```\n\ntypes\n```ts carsu-be/src/shop/types/shop.type.ts\n```\n\n\ncarsu-be/src/canned-job\n```ts carsu-be/src/canned-job/canned-job.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { CannedJobController } from './canned-job.controller';\n\ndescribe('CannedJobController', () => {\n  let controller: CannedJobController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [CannedJobController],\n    }).compile();\n\n    controller = module.get<CannedJobController>(CannedJobController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/canned-job/canned-job.controller.ts\nimport { Controller, Post, Body, Param, Get, Put } from '@nestjs/common';\nimport { CannedJobCreateDto } from './dto/canned-job-create.dto';\nimport { CannedJobService } from './canned-job.service';\nimport { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\nimport { CannedJobUpdateDto } from './dto/canned-job-update.dto';\n\n@ApiTags('Canned Jobs')\n@Controller('canned-job')\nexport class CannedJobController {\n  constructor(private readonly cannedJobService: CannedJobService) {}\n\n  @Post('create')\n  @ApiOperation({ summary: 'Create a new canned job' })\n  @ApiResponse({ status: 201, description: 'Canned job successfully created.' })\n  @ApiResponse({\n    status: 400,\n    description: 'Bad request.',\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Failed to create canned job.',\n  })\n  create(@Body() data: CannedJobCreateDto) {\n    return this.cannedJobService.create(data);\n  }\n\n  @Put('update/:id')\n  @ApiOperation({ summary: 'Update a canned job by id' })\n  @ApiResponse({ status: 200, description: 'Canned job successfully updated.' })\n  @ApiResponse({ status: 404, description: 'Canned job not found.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  update(@Param('id') id: string, @Body() data: CannedJobUpdateDto) {\n    return this.cannedJobService.update({ where: { id }, data });\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a canned job by id' })\n  @ApiResponse({\n    status: 200,\n    description: 'Canned job successfully retrieved.',\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Canned job not found.',\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Bad request.',\n  })\n  getCannedJob(@Param('id') id: string) {\n    return this.cannedJobService.getCannedJob({ id });\n  }\n}\n```\n\n```ts carsu-be/src/canned-job/canned-job.module.ts\nimport { Module } from '@nestjs/common';\nimport { CannedJobService } from './canned-job.service';\nimport { WorkManagementModule } from '@work-management/work-management.module';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { CannedJobController } from './canned-job.controller';\n\n@Module({\n  imports: [PrismaModule, WorkManagementModule],\n  providers: [CannedJobService],\n  exports: [CannedJobService],\n  controllers: [CannedJobController],\n})\nexport class CannedJobModule {}\n```\n\n```ts carsu-be/src/canned-job/canned-job.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { CannedJobService } from './canned-job.service';\n\ndescribe('CannedJobService', () => {\n  let service: CannedJobService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [CannedJobService],\n    }).compile();\n\n    service = module.get<CannedJobService>(CannedJobService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/canned-job/canned-job.service.ts\nimport { PrismaService } from '@prisma/prisma.service';\nimport { BadRequestException, Injectable, Logger } from '@nestjs/common';\nimport { CannedJobCreateDto } from './dto/canned-job-create.dto';\nimport { WorkManagementService } from '@work-management/work-management.service';\nimport { Prisma } from '@prisma/client';\nimport { ErrorHandler } from '@exceptions/handlers/error.handler';\nimport { CannedJobCreateException } from '@exceptions/canned-job';\nimport { CannedJobNotFoundException } from '@exceptions/canned-job/canned-job-not-found.exception';\nimport { CannedJobUpdateException } from '@exceptions/canned-job/canned-job-update.exception';\nimport { CannedJobUpdateDto } from './dto/canned-job-update.dto';\nimport { PrismaTransactionService } from '@prisma/prisma-transaction.service';\nimport pMap from 'p-map';\nimport { CannedJobCreateManyDto } from './dto/canned-job-create-many.dto';\n\n@Injectable()\nexport class CannedJobService {\n  private readonly logger = new Logger(CannedJobService.name);\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly prismaTransactionService: PrismaTransactionService,\n    private readonly workManagementService: WorkManagementService,\n  ) {}\n\n  async createMany(\n    shopId: string,\n    jobGroups: CannedJobCreateManyDto[],\n    tx?: Prisma.TransactionClient,\n  ) {\n    const serviceGroupsToCreate = [];\n    const servicesToCreate = [];\n    const cannedJobsToCreate = [];\n\n    // Generate all required IDs and prepare data for batch creation\n    for (const jobGroup of jobGroups) {\n      const { serviceGroups } = jobGroup;\n      if (!serviceGroups.length) continue;\n\n      // Generate ID for canned job\n      const cannedJobId = crypto.randomUUID();\n\n      // Prepare canned job data - with null serviceGroupId for multiple service groups\n      cannedJobsToCreate.push({\n        id: cannedJobId,\n        shopId,\n        serviceGroupId: null, // We'll set this as null and only use cannedJobId relationships\n      });\n\n      // Prepare service groups and services data\n      for (let i = 0; i < serviceGroups.length; i++) {\n        const groupId = crypto.randomUUID();\n        const groupData = serviceGroups[i];\n\n        serviceGroupsToCreate.push({\n          id: groupId,\n          description: groupData.description,\n          category: groupData.category,\n          macroCategory: groupData.macroCategory || null,\n          position: groupData.position || i + 1,\n          cannedJobId: cannedJobId, // All groups link to the canned job\n        });\n\n        // Prepare services for this group\n        if (groupData.services?.length) {\n          groupData.services.forEach((service, index) => {\n            servicesToCreate.push({\n              ...service,\n              estimateServiceGroupId: groupId,\n              position: service.position || index + 1,\n            });\n          });\n        }\n      }\n    }\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          // 3. Execute batch creation operations\n          // First create canned jobs\n          await prisma.cannedJob.createMany({\n            data: cannedJobsToCreate,\n          });\n\n          // Then create all service groups\n          await prisma.estimateServiceGroup.createMany({\n            data: serviceGroupsToCreate,\n          });\n\n          // Finally create all services\n          if (servicesToCreate.length > 0) {\n            await prisma.estimateService.createMany({\n              data: servicesToCreate,\n            });\n          }\n\n          // 4. Fetch all created canned jobs with their relationships\n          const createdJobs = await prisma.cannedJob.findMany({\n            where: {\n              id: {\n                in: cannedJobsToCreate.map((job) => job.id),\n              },\n            },\n            include: {\n              estimateServiceGroups: {\n                include: {\n                  estimateServices: true,\n                },\n              },\n            },\n          });\n\n          return createdJobs;\n        } catch (error) {\n          this.logger.error('Error creating canned jobs', error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobCreateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async create(data: CannedJobCreateDto, tx?: Prisma.TransactionClient) {\n    const { description, category, macroCategory, services, shopId, position } =\n      data;\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          return await prisma.cannedJob.create({\n            data: {\n              shopId,\n              estimateServiceGroups: {\n                create: {\n                  description,\n                  category,\n                  macroCategory,\n                  position,\n                  estimateServices: {\n                    create: services,\n                  },\n                },\n              },\n            },\n            include: {\n              estimateServiceGroups: {\n                include: {\n                  estimateServices: true,\n                },\n              },\n            },\n          });\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobCreateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async update(\n    {\n      where,\n      data,\n    }: { where: Prisma.CannedJobWhereUniqueInput; data: CannedJobUpdateDto },\n    tx?: Prisma.TransactionClient,\n  ) {\n    const {\n      shopId,\n      serviceGroupId,\n      description,\n      category,\n      macroCategory,\n      position,\n      services,\n    } = data;\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          await prisma.cannedJob.update({\n            where,\n            data: {\n              shopId,\n              serviceGroupId,\n            },\n          });\n\n          await this.workManagementService.updateServiceGroup(\n            {\n              where: { id: serviceGroupId },\n              data: {\n                description,\n                category,\n                macroCategory,\n                position,\n              },\n            },\n            prisma,\n          );\n\n          if (services?.length) {\n            await pMap(\n              services,\n              ({ id, ...data }) =>\n                this.workManagementService.updateService(\n                  { where: { id }, data },\n                  prisma,\n                ),\n              { concurrency: 10 },\n            );\n          }\n\n          return await this.getCannedJob({ id: where.id }, prisma);\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobUpdateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async getCannedJob(\n    cannedJobWhereUniqueInput: Prisma.CannedJobWhereUniqueInput,\n    tx?: Prisma.TransactionClient,\n  ) {\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          const cannedJob = await prisma.cannedJob.findUnique({\n            where: cannedJobWhereUniqueInput,\n            include: {\n              estimateServiceGroups: {\n                include: {\n                  estimateServices: true,\n                },\n              },\n            },\n          });\n\n          if (!cannedJob) {\n            throw new CannedJobNotFoundException(\n              JSON.stringify(cannedJobWhereUniqueInput),\n            );\n          }\n\n          return cannedJob;\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobNotFoundException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n}\n```\n\ndto\n```ts carsu-be/src/canned-job/dto/canned-job-create-many.dto.ts\nimport { Type } from 'class-transformer';\nimport { IsArray, ValidateNested } from 'class-validator';\nimport { CannedJobCreateDto } from './canned-job-create.dto';\n\nexport class CannedJobCreateManyDto {\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => CannedJobCreateDto)\n  serviceGroups: CannedJobCreateDto[];\n}\n```\n\n```ts carsu-be/src/canned-job/dto/canned-job-create.dto.ts\nimport { PickType } from '@nestjs/mapped-types';\nimport { ServiceGroupCreateDto } from '@work-management/dto/service-group-create.dto';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { IsUUID } from 'class-validator';\n\nexport class CannedJobCreateDto extends PickType(ServiceGroupCreateDto, [\n  'description',\n  'category',\n  'macroCategory',\n  'services',\n  'position',\n] as const) {\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsUUID()\n  shopId: string;\n}\n```\n\n```ts carsu-be/src/canned-job/dto/canned-job-update.dto.ts\nimport { PartialType, PickType } from '@nestjs/mapped-types';\nimport { CannedJobCreateDto } from './canned-job-create.dto';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { IsArray, IsOptional, IsUUID, ValidateNested } from 'class-validator';\nimport { ServiceUpdateDto } from '@work-management/dto/service-update.dto';\nimport { Type } from 'class-transformer';\n\nexport class CannedJobUpdateDto extends PartialType(\n  PickType(CannedJobCreateDto, [\n    'description',\n    'category',\n    'macroCategory',\n    'position',\n  ] as const),\n) {\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsUUID()\n  shopId: string;\n\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsUUID()\n  serviceGroupId: string;\n\n  @ApiProperty({\n    example: [\n      {\n        description: 'Dismounting + Mounting of tires - 10\" to 14\"',\n        internalId: 'SMP0000001',\n        manHours: '0.25',\n        price: 1025,\n        total: 1025,\n      },\n      {\n        internalId: 'SEQ0000001',\n        description: 'Balancing',\n        manHours: '1.00',\n        price: 0,\n        total: 0,\n      },\n      {\n        internalId: 'SPFU000001',\n        description: 'Disposal of end-of-life tyres',\n        manHours: '1.00',\n        price: 0,\n        total: 0,\n      },\n    ],\n    required: false,\n  })\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => ServiceUpdateDto)\n  @IsOptional()\n  services?: ServiceUpdateDto[];\n}\n```\n\n\ncarsu-be/src/work-management\ndto\n```ts carsu-be/src/work-management/dto/service-create.dto.ts\nimport {\n  IsString,\n  IsNumber,\n  IsUUID,\n  IsBoolean,\n  IsOptional,\n} from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class ServiceCreateDto {\n  @ApiProperty({\n    example: 'SERVICE-001',\n    type: 'string',\n  })\n  @IsString()\n  internalId: string;\n\n  @ApiProperty({\n    example: 'Basic maintenance service',\n    type: 'string',\n  })\n  @IsString()\n  description: string;\n\n  @ApiProperty({\n    type: 'number',\n    example: 2.5,\n  })\n  @IsNumber()\n  manHours: number;\n\n  @ApiProperty({\n    type: 'number',\n    example: 150.0,\n  })\n  @IsNumber()\n  price: number;\n\n  @ApiProperty({\n    type: 'string',\n    example: '123e4567-e89b-12d3-a456-426614174000',\n  })\n  @IsUUID()\n  @IsOptional()\n  estimateServiceGroupId?: string;\n\n  @ApiProperty({\n    type: 'boolean',\n    example: false,\n    default: false,\n  })\n  @IsBoolean()\n  @IsOptional()\n  checked?: boolean;\n\n  @ApiProperty({\n    type: 'number',\n    example: 375.0,\n  })\n  @IsNumber()\n  total: number;\n\n  @ApiProperty({\n    type: 'number',\n    example: 0,\n  })\n  @IsNumber()\n  position: number;\n}\n```\n\n```ts carsu-be/src/work-management/dto/service-group-create.dto.ts\nimport {\n  IsString,\n  IsUUID,\n  Length,\n  IsNotEmpty,\n  IsOptional,\n  IsArray,\n  IsNumber,\n} from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { ServiceCreateDto } from './service-create.dto';\nimport { Type } from 'class-transformer';\nimport { ValidateNested } from 'class-validator';\n\nexport class ServiceGroupCreateDto {\n  @ApiProperty({\n    type: 'string',\n    example: 'Oil Change Service Package',\n  })\n  @IsString()\n  @IsNotEmpty()\n  description: string;\n\n  @ApiProperty({\n    type: 'string',\n    example: '123e4567-e89b-12d3-a456-426614174000',\n    required: false,\n    nullable: true,\n  })\n  @IsUUID()\n  @IsOptional()\n  estimateId?: string;\n\n  @ApiProperty({\n    type: 'string',\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: false,\n    nullable: true,\n  })\n  @IsUUID()\n  @IsOptional()\n  cannedJobId?: string;\n\n  @ApiProperty({\n    type: 'string',\n    example: 'Services',\n    required: false,\n    nullable: true,\n  })\n  @IsString()\n  @IsOptional()\n  category?: string;\n\n  @ApiProperty({\n    type: String,\n    example: 'Regular Service',\n    required: false,\n    nullable: true,\n  })\n  @IsString()\n  @IsOptional()\n  macroCategory?: string;\n\n  @ApiProperty({\n    type: 'string',\n    example: '1',\n  })\n  @IsNumber()\n  position: number;\n\n  @ApiProperty({\n    example: [\n      {\n        description: 'Dismounting + Mounting of tires - 10\" to 14\"',\n        internalId: 'SMP0000001',\n        manHours: '0.25',\n        price: 1025,\n        total: 1025,\n      },\n      {\n        internalId: 'SEQ0000001',\n        description: 'Balancing',\n        manHours: '1.00',\n        price: 0,\n        total: 0,\n      },\n      {\n        internalId: 'SPFU000001',\n        description: 'Disposal of end-of-life tyres',\n        manHours: '1.00',\n        price: 0,\n        total: 0,\n      },\n    ],\n  })\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => ServiceCreateDto)\n  services: ServiceCreateDto[];\n}\n```\n\n```ts carsu-be/src/work-management/dto/service-group-update.dto.ts\nimport { OmitType, PartialType } from '@nestjs/mapped-types';\nimport { ServiceGroupCreateDto } from './service-group-create.dto';\n\nexport class ServiceGroupUpdateDto extends PartialType(\n  OmitType(ServiceGroupCreateDto, [\n    'estimateId',\n    'cannedJobId',\n    'services',\n  ] as const),\n) {}\n```\n\n```ts carsu-be/src/work-management/dto/service-update.dto.ts\nimport { OmitType, PartialType } from '@nestjs/mapped-types';\nimport { ServiceCreateDto } from './service-create.dto';\nimport { IsUUID, IsOptional } from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class ServiceUpdateDto extends PartialType(\n  OmitType(ServiceCreateDto, ['estimateServiceGroupId'] as const),\n) {\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsOptional()\n  @IsUUID()\n  id?: string;\n}\n```\n\n\n```ts carsu-be/src/work-management/work-management.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { WorkManagementController } from './work-management.controller';\n\ndescribe('WorkManagementController', () => {\n  let controller: WorkManagementController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [WorkManagementController],\n    }).compile();\n\n    controller = module.get<WorkManagementController>(WorkManagementController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/work-management/work-management.controller.ts\nimport { Controller } from '@nestjs/common';\n\n@Controller('work-management')\nexport class WorkManagementController {}\n```\n\n```ts carsu-be/src/work-management/work-management.module.ts\nimport { Module } from '@nestjs/common';\nimport { WorkManagementController } from './work-management.controller';\nimport { WorkManagementService } from './work-management.service';\nimport { PrismaModule } from '@prisma/prisma.module';\n\n@Module({\n  imports: [PrismaModule],\n  controllers: [WorkManagementController],\n  providers: [WorkManagementService],\n  exports: [WorkManagementService],\n})\nexport class WorkManagementModule {}\n```\n\n```ts carsu-be/src/work-management/work-management.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { WorkManagementService } from './work-management.service';\n\ndescribe('WorkManagementService', () => {\n  let service: WorkManagementService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [WorkManagementService],\n    }).compile();\n\n    service = module.get<WorkManagementService>(WorkManagementService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/work-management/work-management.service.ts\nimport { BadRequestException, Injectable, Logger } from '@nestjs/common';\nimport { PrismaService } from '@prisma/prisma.service';\nimport { ServiceGroupCreateDto } from './dto/service-group-create.dto';\nimport { Prisma } from '@prisma/client';\nimport { ServiceCreateDto } from './dto/service-create.dto';\nimport {\n  ServiceGroupCreateException,\n  ServiceGroupNotFoundException,\n} from '@exceptions/serviceGroup';\nimport { ErrorHandler } from '@exceptions/handlers';\nimport {\n  ServiceCreateException,\n  ServiceUpdateException,\n} from '@exceptions/service';\nimport { ServiceUpdateDto } from './dto/service-update.dto';\nimport { ServiceGroupUpdateDto } from './dto/service-group-update.dto';\nimport { ServiceGroupUpdateException } from '@exceptions/serviceGroup/service-group-update.exception';\nimport { PrismaTransactionService } from '@prisma/prisma-transaction.service';\n\n@Injectable()\nexport class WorkManagementService {\n  private readonly logger = new Logger(WorkManagementService.name);\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly prismaTransactionService: PrismaTransactionService,\n  ) {}\n\n  async createServices(\n    payload: ServiceCreateDto[],\n    tx?: Prisma.TransactionClient,\n  ) {\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        const data: Prisma.EstimateServiceCreateManyInput[] = payload.map(\n          ({\n            internalId,\n            description,\n            manHours,\n            price,\n            estimateServiceGroupId,\n            checked,\n            total,\n            position,\n          }) => ({\n            internalId,\n            description,\n            manHours,\n            price,\n            estimateServiceGroupId,\n            checked,\n            total,\n            position,\n          }),\n        );\n\n        try {\n          return await prisma.estimateService.createMany({\n            data,\n          });\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            ServiceCreateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async updateService(\n    {\n      where,\n      data,\n    }: {\n      where: Prisma.EstimateServiceWhereUniqueInput;\n      data: ServiceUpdateDto;\n    },\n    tx?: Prisma.TransactionClient,\n  ) {\n    try {\n      const prisma = tx ?? this.prisma;\n      return await prisma.estimateService.update({\n        where,\n        data,\n      });\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ServiceUpdateException,\n      );\n    }\n  }\n\n  async updateServiceGroup(\n    {\n      where,\n      data,\n    }: {\n      where: Prisma.EstimateServiceGroupWhereUniqueInput;\n      data: ServiceGroupUpdateDto;\n    },\n    tx?: Prisma.TransactionClient,\n  ) {\n    try {\n      const prisma = tx ?? this.prisma;\n      return await prisma.estimateServiceGroup.update({\n        where,\n        data,\n      });\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ServiceGroupUpdateException,\n      );\n    }\n  }\n\n  async createServiceGroup(\n    payload: ServiceGroupCreateDto,\n    tx?: Prisma.TransactionClient,\n  ) {\n    const {\n      description,\n      estimateId,\n      cannedJobId,\n      category,\n      macroCategory,\n      services,\n      position,\n    } = payload;\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        const data: Prisma.EstimateServiceGroupCreateInput = {\n          position,\n          description,\n          estimate: estimateId\n            ? {\n                connect: { id: estimateId },\n              }\n            : {},\n          cannedJob: cannedJobId\n            ? {\n                connect: { id: cannedJobId },\n              }\n            : {},\n          category,\n          macroCategory,\n        };\n\n        try {\n          const serviceGroup = await prisma.estimateServiceGroup.create({\n            data,\n          });\n          const servicesWithGroupId = services.map((service) => ({\n            ...service,\n            estimateServiceGroupId: serviceGroup.id,\n          }));\n\n          await this.createServices(servicesWithGroupId, prisma);\n\n          return await this.getServiceGroup({ id: serviceGroup.id }, prisma);\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            ServiceGroupCreateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async getServiceGroup(\n    EstimateServiceGroupWhereUniqueInput: Prisma.EstimateServiceGroupWhereUniqueInput,\n    tx?: Prisma.TransactionClient,\n  ) {\n    try {\n      const prisma = tx ?? this.prisma;\n      const serviceGroup = await prisma.estimateServiceGroup.findUnique({\n        where: EstimateServiceGroupWhereUniqueInput,\n        include: {\n          estimateServices: true,\n        },\n      });\n\n      if (!serviceGroup) {\n        throw new ServiceGroupNotFoundException(\n          JSON.stringify(EstimateServiceGroupWhereUniqueInput),\n        );\n      }\n\n      return serviceGroup;\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ServiceGroupNotFoundException,\n      );\n    }\n  }\n}\n```\n\n\n[Nest] 43290  - 03/17/2025, 1:42:22 PM   ERROR [ExceptionHandler] Nest can't resolve dependencies of the ShopService (PrismaService, AuthService, UserService, ?). Please make sure that the argument CannedJobService at index [3] is available in the AuthModule context.\n\nPotential solutions:\n- Is AuthModule a valid NestJS module?\n- If CannedJobService is a provider, is it part of the current AuthModule?\n- If CannedJobService is exported from a separate @Module, is that module imported within AuthModule?\n  @Module({\n    imports: [ /* the Module containing CannedJobService */ ]\n  })\n\nError: Nest can't resolve dependencies of the ShopService (PrismaService, AuthService, UserService, ?). Please make sure that the argument CannedJobService at index [3] is available in the AuthModule context.\n\nPotential solutions:\n- Is AuthModule a valid NestJS module?\n- If CannedJobService is a provider, is it part of the current AuthModule?\n- If CannedJobService is exported from a separate @Module, is that module imported within AuthModule?\n  @Module({\n    imports: [ /* the Module containing CannedJobService */ ]\n  })\ncan you investigate and why this error is happening? I have already import the CannedJobModule in the ShopModule. can you please fix the error\nLooking at your error, there's a circular dependency issue between your modules. The `ShopModule` imports `CannedJobModule`, but `CannedJobService` also depends on something in the `ShopModule` (directly or indirectly).\n\nHere's the fix:\n\n```typescript\n// Fix for carsu-be/src/shop/shop.module.ts\nimport { Module, forwardRef } from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopController } from './shop.controller';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { AuthModule } from '@auth/auth.module';\nimport { UserModule } from '@user/user.module';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\nimport { WorkManagementModule } from '@app/work-management/work-management.module';\n\n@Module({\n  imports: [\n    PrismaModule, \n    AuthModule, \n    UserModule, \n    forwardRef(() => CannedJobModule), // Use forwardRef to resolve circular dependency\n    WorkManagementModule\n  ],\n  providers: [ShopService],\n  controllers: [ShopController],\n  exports: [ShopService],\n})\nexport class ShopModule {}\n```\n\nAdditionally, you should check the `CannedJobModule` and make sure it's also using `forwardRef`:\n\n```typescript\n// Fix for carsu-be/src/canned-job/canned-job.module.ts\nimport { Module, forwardRef } from '@nestjs/common';\nimport { CannedJobService } from './canned-job.service';\nimport { WorkManagementModule } from '@work-management/work-management.module';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { CannedJobController } from './canned-job.controller';\nimport { ShopModule } from '@app/shop/shop.module';\n\n@Module({\n  imports: [\n    PrismaModule, \n    WorkManagementModule,\n    forwardRef(() => ShopModule) // Use forwardRef for the circular dependency\n  ],\n  providers: [CannedJobService],\n  exports: [CannedJobService],\n  controllers: [CannedJobController],\n})\nexport class CannedJobModule {}\n```\n\nThis `forwardRef()` approach is the standard way to handle circular dependencies in NestJS. It tells the dependency injection system to resolve the dependencies lazily, breaking the circular dependency chain.\nreverting the changes as it is not working\n```ts carsu-be/src/canned-job/canned-job.module.ts\nimport { forwardRef, Module } from '@nestjs/common';\nimport { CannedJobService } from './canned-job.service';\nimport { WorkManagementModule } from '@work-management/work-management.module';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { CannedJobController } from './canned-job.controller';\nimport { ShopModule } from '@app/shop/shop.module';\n\n@Module({\n  imports: [PrismaModule, WorkManagementModule],\n  providers: [CannedJobService],\n  exports: [CannedJobService],\n  controllers: [CannedJobController],\n})\nexport class CannedJobModule {}\n```\n\n```ts carsu-be/src/shop/shop.module.ts\nimport { forwardRef, Module } from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopController } from './shop.controller';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { AuthModule } from '@auth/auth.module';\nimport { UserModule } from '@user/user.module';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\n\n@Module({\n  imports: [PrismaModule, AuthModule, UserModule],\n  providers: [ShopService],\n  controllers: [ShopController],\n  exports: [ShopService],\n})\nexport class ShopModule {}\n```\n\ni did not use the shopmodule in the cannedjobmodule?\nYou're right. Let's try a different approach to fix the circular dependency issue. Looking at the error more carefully, it seems the dependency injection in `ShopService` can't resolve `CannedJobService`.\n\nFirst, let's modify the `ShopModule` to correctly import the `CannedJobModule`:\n\n```typescript\n// Fix for carsu-be/src/shop/shop.module.ts\nimport { Module } from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopController } from './shop.controller';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { AuthModule } from '@auth/auth.module';\nimport { UserModule } from '@user/user.module';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\n\n@Module({\n  imports: [\n    PrismaModule, \n    AuthModule, \n    UserModule, \n    CannedJobModule,\n  ],\n  providers: [ShopService],\n  controllers: [ShopController],\n  exports: [ShopService],\n})\nexport class ShopModule {}\n```\n\nThe issue might be in the import paths. Let's make sure your imports are correct in the service:\n\n```typescript\n// Check the import in ShopService\nimport { CannedJobService } from '../canned-job/canned-job.service';\n// or\nimport { CannedJobService } from '@app/canned-job/canned-job.service';\n```\n\nIf the issue persists, let's try a different approach with the missing `WorkManagementModule` in the shop.module.ts:\n\n```typescript\n// Fix for carsu-be/src/shop/shop.module.ts\nimport { Module } from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopController } from './shop.controller';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { AuthModule } from '@auth/auth.module';\nimport { UserModule } from '@user/user.module';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\nimport { WorkManagementModule } from '@app/work-management/work-management.module';\n\n@Module({\n  imports: [\n    PrismaModule, \n    AuthModule, \n    UserModule, \n    CannedJobModule,\n    WorkManagementModule, // Make sure this is imported\n  ],\n  providers: [ShopService],\n  controllers: [ShopController],\n  exports: [ShopService],\n})\nexport class ShopModule {}\n```\n\nAlso, check if your `AppModule` correctly imports both modules:\n\n```typescript\n// In your app.module.ts\nimport { Module } from '@nestjs/common';\nimport { ShopModule } from './shop/shop.module';\nimport { CannedJobModule } from './canned-job/canned-job.module';\n// other imports...\n\n@Module({\n  imports: [\n    ShopModule,\n    CannedJobModule,\n    // other modules...\n  ],\n})\nexport class AppModule {}\n```\n\n[Nest] 43896  - 03/17/2025, 1:46:51 PM   ERROR [ExceptionHandler] Nest can't resolve dependencies of the ShopService (PrismaService, AuthService, UserService, ?). Please make sure that the argument CannedJobService at index [3] is available in the AuthModule context.\n\nPotential solutions:\n- Is AuthModule a valid NestJS module?\n- If CannedJobService is a provider, is it part of the current AuthModule?\n- If CannedJobService is exported from a separate @Module, is that module imported within AuthModule?\n  @Module({\n    imports: [ /* the Module containing CannedJobService */ ]\n  })\n\nError: Nest can't resolve dependencies of the ShopService (PrismaService, AuthService, UserService, ?). Please make sure that the argument CannedJobService at index [3] is available in the AuthModule context.\n\nPotential solutions:\n- Is AuthModule a valid NestJS module?\n- If CannedJobService is a provider, is it part of the current AuthModule?\n- If CannedJobService is exported from a separate @Module, is that module imported within AuthModule?\n  @Module({\n    imports: [ /* the Module containing CannedJobService */ ]\n  })\nThe error is occurring because NestJS is still trying to resolve the CannedJobService dependency in the context of the AuthModule, which suggests there's a deeper issue with how your modules are structured.\n\nLet's take a more comprehensive approach. The issue appears to be that NestJS is looking for CannedJobService in the AuthModule context, which suggests there's a connection between ShopService and AuthModule that we need to address.\n\nHere's a step-by-step solution:\n\n1. First, let's modify your AuthModule to import the CannedJobModule:\n\n```typescript\n// auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\n// other imports...\n\n@Module({\n  imports: [\n    CannedJobModule,\n    // other imports...\n  ],\n  // rest of your module definition\n})\nexport class AuthModule {}\n```\n\n2. If you can't modify the AuthModule directly, let's try a different approach by injecting the CannedJobService in a different way in the ShopService:\n\n```typescript\n// shop.service.ts\nimport { Injectable, Logger, BadRequestException, NotFoundException, Inject } from '@nestjs/common';\nimport { ModuleRef } from '@nestjs/core';\n// other imports...\n\n@Injectable()\nexport class ShopService {\n  private readonly logger = new Logger(ShopService.name);\n  private cannedJobService: CannedJobService;\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly authService: AuthService,\n    private readonly userService: UserService,\n    private moduleRef: ModuleRef, // Add ModuleRef\n  ) {\n    // Lazy load the CannedJobService to break circular dependency\n    this.cannedJobService = this.moduleRef.get(CannedJobService, { strict: false });\n  }\n\n  // Your service methods...\n}\n```\n\n3. If the above doesn't work, we can try removing the direct dependency and using an event-based approach:\n\n```typescript\n// shop.service.ts - Remove direct dependency on CannedJobService\nimport { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';\n// other imports...\n\n@Injectable()\nexport class ShopService {\n  private readonly logger = new Logger(ShopService.name);\n  \n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly authService: AuthService,\n    private readonly userService: UserService,\n    // Remove CannedJobService dependency\n  ) {}\n\n  // Your service methods...\n  // For the create method, use the prisma service directly instead of CannedJobService\n  async create(authId: string, payload: ShopCreateDto) {\n    // Your existing code...\n    \n    return await this.prisma.$transaction(async (tx) => {\n      const shop = await tx.shop.create({\n        data: shopData,\n        include: {\n          contact: true,\n          address: true,\n          vat: true,\n        },\n      });\n\n      // Instead of using cannedJobService.createMany(), implement the logic directly here\n      // or use a simpler alternative approach\n      \n      // Create service groups\n      const serviceGroupsToCreate = preDefinedCannedJobs.flatMap((jobGroup, i) => {\n        return jobGroup.map((item, j) => {\n          const cannedJobId = crypto.randomUUID();\n          \n          // First create the canned job\n          tx.cannedJob.create({\n            data: {\n              id: cannedJobId,\n              shopId: shop.id,\n            }\n          });\n          \n          // Then create the service group\n          return {\n            id: crypto.randomUUID(),\n            description: item.description,\n            category: item.category,\n            macroCategory: null,\n            position: j + 1,\n            cannedJobId: cannedJobId,\n            shopId: shop.id,\n            services: item.services || [],\n          };\n        });\n      });\n\n      // Create all the service groups and their services\n      for (const group of serviceGroupsToCreate) {\n        const { services, ...groupData } = group;\n        \n        const createdGroup = await tx.estimateServiceGroup.create({\n          data: {\n            id: group.id,\n            description: group.description,\n            category: group.category,\n            macroCategory: group.macroCategory,\n            position: group.position,\n            cannedJobId: group.cannedJobId,\n          }\n        });\n        \n        if (services.length) {\n          await tx.estimateService.createMany({\n            data: services.map((service, index) => ({\n              ...service,\n              estimateServiceGroupId: createdGroup.id,\n              position: index + 1,\n            }))\n          });\n        }\n      }\n\n      await this.authService.updateUserPublicMetadata(authId, {\n        shopId: shop.id,\n      });\n\n      return shop;\n    });\n  }\n}\n```\n\n4. As a last resort, if none of the above solutions work, you can try this approach by completely refactoring your module dependencies:\n\n```typescript\n// Create a new module to contain shared services\n// shared.module.ts\nimport { Module, Global } from '@nestjs/common';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { PrismaService } from '@prisma/prisma.service';\nimport { CannedJobService } from '@canned-job/canned-job.service';\nimport { WorkManagementService } from '@work-management/work-management.service';\n\n@Global() // Make this module global\n@Module({\n  imports: [PrismaModule],\n  providers: [CannedJobService, WorkManagementService],\n  exports: [CannedJobService, WorkManagementService, PrismaModule],\n})\nexport class SharedModule {}\n```\n\nThen update your app.module.ts to import this module first:\n\n```typescript\n// app.module.ts\nimport { Module } from '@nestjs/common';\nimport { SharedModule } from './shared/shared.module';\nimport { ShopModule } from './shop/shop.module';\nimport { AuthModule } from './auth/auth.module';\n// other imports...\n\n@Module({\n  imports: [\n    SharedModule, // Import the shared module first\n    ShopModule,\n    AuthModule,\n    // other modules...\n  ],\n})\nexport class AppModule {}\n```\n\nThis creates a global module that provides both services, breaking the circular dependency.\nthe only thing we need to check is the canned-job and the shop\ncarsu-be/src/canned-job\n```ts carsu-be/src/canned-job/canned-job.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { CannedJobController } from './canned-job.controller';\n\ndescribe('CannedJobController', () => {\n  let controller: CannedJobController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [CannedJobController],\n    }).compile();\n\n    controller = module.get<CannedJobController>(CannedJobController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/canned-job/canned-job.controller.ts\nimport { Controller, Post, Body, Param, Get, Put } from '@nestjs/common';\nimport { CannedJobCreateDto } from './dto/canned-job-create.dto';\nimport { CannedJobService } from './canned-job.service';\nimport { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\nimport { CannedJobUpdateDto } from './dto/canned-job-update.dto';\n\n@ApiTags('Canned Jobs')\n@Controller('canned-job')\nexport class CannedJobController {\n  constructor(private readonly cannedJobService: CannedJobService) {}\n\n  @Post('create')\n  @ApiOperation({ summary: 'Create a new canned job' })\n  @ApiResponse({ status: 201, description: 'Canned job successfully created.' })\n  @ApiResponse({\n    status: 400,\n    description: 'Bad request.',\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Failed to create canned job.',\n  })\n  create(@Body() data: CannedJobCreateDto) {\n    return this.cannedJobService.create(data);\n  }\n\n  @Put('update/:id')\n  @ApiOperation({ summary: 'Update a canned job by id' })\n  @ApiResponse({ status: 200, description: 'Canned job successfully updated.' })\n  @ApiResponse({ status: 404, description: 'Canned job not found.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  update(@Param('id') id: string, @Body() data: CannedJobUpdateDto) {\n    return this.cannedJobService.update({ where: { id }, data });\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a canned job by id' })\n  @ApiResponse({\n    status: 200,\n    description: 'Canned job successfully retrieved.',\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Canned job not found.',\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Bad request.',\n  })\n  getCannedJob(@Param('id') id: string) {\n    return this.cannedJobService.getCannedJob({ id });\n  }\n}\n```\n\n```ts carsu-be/src/canned-job/canned-job.module.ts\nimport { forwardRef, Module } from '@nestjs/common';\nimport { CannedJobService } from './canned-job.service';\nimport { WorkManagementModule } from '@work-management/work-management.module';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { CannedJobController } from './canned-job.controller';\nimport { ShopModule } from '@app/shop/shop.module';\n\n@Module({\n  imports: [PrismaModule, WorkManagementModule],\n  providers: [CannedJobService],\n  exports: [CannedJobService],\n  controllers: [CannedJobController],\n})\nexport class CannedJobModule {}\n```\n\n```ts carsu-be/src/canned-job/canned-job.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { CannedJobService } from './canned-job.service';\n\ndescribe('CannedJobService', () => {\n  let service: CannedJobService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [CannedJobService],\n    }).compile();\n\n    service = module.get<CannedJobService>(CannedJobService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/canned-job/canned-job.service.ts\nimport { PrismaService } from '@prisma/prisma.service';\nimport { BadRequestException, Injectable, Logger } from '@nestjs/common';\nimport { CannedJobCreateDto } from './dto/canned-job-create.dto';\nimport { WorkManagementService } from '@work-management/work-management.service';\nimport { Prisma } from '@prisma/client';\nimport { ErrorHandler } from '@exceptions/handlers/error.handler';\nimport { CannedJobCreateException } from '@exceptions/canned-job';\nimport { CannedJobNotFoundException } from '@exceptions/canned-job/canned-job-not-found.exception';\nimport { CannedJobUpdateException } from '@exceptions/canned-job/canned-job-update.exception';\nimport { CannedJobUpdateDto } from './dto/canned-job-update.dto';\nimport { PrismaTransactionService } from '@prisma/prisma-transaction.service';\nimport pMap from 'p-map';\nimport { CannedJobCreateManyDto } from './dto/canned-job-create-many.dto';\n\n@Injectable()\nexport class CannedJobService {\n  private readonly logger = new Logger(CannedJobService.name);\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly prismaTransactionService: PrismaTransactionService,\n    private readonly workManagementService: WorkManagementService,\n  ) {}\n\n  async createMany(\n    shopId: string,\n    jobGroups: CannedJobCreateManyDto[],\n    tx?: Prisma.TransactionClient,\n  ) {\n    const serviceGroupsToCreate = [];\n    const servicesToCreate = [];\n    const cannedJobsToCreate = [];\n\n    // Generate all required IDs and prepare data for batch creation\n    for (const jobGroup of jobGroups) {\n      const { serviceGroups } = jobGroup;\n      if (!serviceGroups.length) continue;\n\n      // Generate ID for canned job\n      const cannedJobId = crypto.randomUUID();\n\n      // Prepare canned job data - with null serviceGroupId for multiple service groups\n      cannedJobsToCreate.push({\n        id: cannedJobId,\n        shopId,\n        serviceGroupId: null, // We'll set this as null and only use cannedJobId relationships\n      });\n\n      // Prepare service groups and services data\n      for (let i = 0; i < serviceGroups.length; i++) {\n        const groupId = crypto.randomUUID();\n        const groupData = serviceGroups[i];\n\n        serviceGroupsToCreate.push({\n          id: groupId,\n          description: groupData.description,\n          category: groupData.category,\n          macroCategory: groupData.macroCategory || null,\n          position: groupData.position || i + 1,\n          cannedJobId: cannedJobId, // All groups link to the canned job\n        });\n\n        // Prepare services for this group\n        if (groupData.services?.length) {\n          groupData.services.forEach((service, index) => {\n            servicesToCreate.push({\n              ...service,\n              estimateServiceGroupId: groupId,\n              position: service.position || index + 1,\n            });\n          });\n        }\n      }\n    }\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          // 3. Execute batch creation operations\n          // First create canned jobs\n          await prisma.cannedJob.createMany({\n            data: cannedJobsToCreate,\n          });\n\n          // Then create all service groups\n          await prisma.estimateServiceGroup.createMany({\n            data: serviceGroupsToCreate,\n          });\n\n          // Finally create all services\n          if (servicesToCreate.length > 0) {\n            await prisma.estimateService.createMany({\n              data: servicesToCreate,\n            });\n          }\n\n          // 4. Fetch all created canned jobs with their relationships\n          const createdJobs = await prisma.cannedJob.findMany({\n            where: {\n              id: {\n                in: cannedJobsToCreate.map((job) => job.id),\n              },\n            },\n            include: {\n              estimateServiceGroups: {\n                include: {\n                  estimateServices: true,\n                },\n              },\n            },\n          });\n\n          return createdJobs;\n        } catch (error) {\n          this.logger.error('Error creating canned jobs', error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobCreateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async create(data: CannedJobCreateDto, tx?: Prisma.TransactionClient) {\n    const { description, category, macroCategory, services, shopId, position } =\n      data;\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          return await prisma.cannedJob.create({\n            data: {\n              shopId,\n              estimateServiceGroups: {\n                create: {\n                  description,\n                  category,\n                  macroCategory,\n                  position,\n                  estimateServices: {\n                    create: services,\n                  },\n                },\n              },\n            },\n            include: {\n              estimateServiceGroups: {\n                include: {\n                  estimateServices: true,\n                },\n              },\n            },\n          });\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobCreateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async update(\n    {\n      where,\n      data,\n    }: { where: Prisma.CannedJobWhereUniqueInput; data: CannedJobUpdateDto },\n    tx?: Prisma.TransactionClient,\n  ) {\n    const {\n      shopId,\n      serviceGroupId,\n      description,\n      category,\n      macroCategory,\n      position,\n      services,\n    } = data;\n\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          await prisma.cannedJob.update({\n            where,\n            data: {\n              shopId,\n              serviceGroupId,\n            },\n          });\n\n          await this.workManagementService.updateServiceGroup(\n            {\n              where: { id: serviceGroupId },\n              data: {\n                description,\n                category,\n                macroCategory,\n                position,\n              },\n            },\n            prisma,\n          );\n\n          if (services?.length) {\n            await pMap(\n              services,\n              ({ id, ...data }) =>\n                this.workManagementService.updateService(\n                  { where: { id }, data },\n                  prisma,\n                ),\n              { concurrency: 10 },\n            );\n          }\n\n          return await this.getCannedJob({ id: where.id }, prisma);\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobUpdateException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n\n  async getCannedJob(\n    cannedJobWhereUniqueInput: Prisma.CannedJobWhereUniqueInput,\n    tx?: Prisma.TransactionClient,\n  ) {\n    return this.prismaTransactionService.executeWithTransaction(\n      async (prisma) => {\n        try {\n          const cannedJob = await prisma.cannedJob.findUnique({\n            where: cannedJobWhereUniqueInput,\n            include: {\n              estimateServiceGroups: {\n                include: {\n                  estimateServices: true,\n                },\n              },\n            },\n          });\n\n          if (!cannedJob) {\n            throw new CannedJobNotFoundException(\n              JSON.stringify(cannedJobWhereUniqueInput),\n            );\n          }\n\n          return cannedJob;\n        } catch (error) {\n          this.logger.error(error);\n          ErrorHandler.handleError(\n            error,\n            Prisma.PrismaClientKnownRequestError,\n            BadRequestException,\n            CannedJobNotFoundException,\n          );\n        }\n      },\n      tx,\n    );\n  }\n}\n```\n\ndto\n```ts carsu-be/src/canned-job/dto/canned-job-create-many.dto.ts\nimport { Type } from 'class-transformer';\nimport { IsArray, ValidateNested } from 'class-validator';\nimport { CannedJobCreateDto } from './canned-job-create.dto';\n\nexport class CannedJobCreateManyDto {\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => CannedJobCreateDto)\n  serviceGroups: CannedJobCreateDto[];\n}\n```\n\n```ts carsu-be/src/canned-job/dto/canned-job-create.dto.ts\nimport { PickType } from '@nestjs/mapped-types';\nimport { ServiceGroupCreateDto } from '@work-management/dto/service-group-create.dto';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { IsUUID } from 'class-validator';\n\nexport class CannedJobCreateDto extends PickType(ServiceGroupCreateDto, [\n  'description',\n  'category',\n  'macroCategory',\n  'services',\n  'position',\n] as const) {\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsUUID()\n  shopId: string;\n}\n```\n\n```ts carsu-be/src/canned-job/dto/canned-job-update.dto.ts\nimport { PartialType, PickType } from '@nestjs/mapped-types';\nimport { CannedJobCreateDto } from './canned-job-create.dto';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { IsArray, IsOptional, IsUUID, ValidateNested } from 'class-validator';\nimport { ServiceUpdateDto } from '@work-management/dto/service-update.dto';\nimport { Type } from 'class-transformer';\n\nexport class CannedJobUpdateDto extends PartialType(\n  PickType(CannedJobCreateDto, [\n    'description',\n    'category',\n    'macroCategory',\n    'position',\n  ] as const),\n) {\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsUUID()\n  shopId: string;\n\n  @ApiProperty({\n    type: String,\n    example: '987fcdeb-51a2-12d3-a456-426614174000',\n    required: true,\n  })\n  @IsUUID()\n  serviceGroupId: string;\n\n  @ApiProperty({\n    example: [\n      {\n        description: 'Dismounting + Mounting of tires - 10\" to 14\"',\n        internalId: 'SMP0000001',\n        manHours: '0.25',\n        price: 1025,\n        total: 1025,\n      },\n      {\n        internalId: 'SEQ0000001',\n        description: 'Balancing',\n        manHours: '1.00',\n        price: 0,\n        total: 0,\n      },\n      {\n        internalId: 'SPFU000001',\n        description: 'Disposal of end-of-life tyres',\n        manHours: '1.00',\n        price: 0,\n        total: 0,\n      },\n    ],\n    required: false,\n  })\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => ServiceUpdateDto)\n  @IsOptional()\n  services?: ServiceUpdateDto[];\n}\n```\n\n\ncarsu-be/src/shop\n__mocks__\n```ts carsu-be/src/shop/__mocks__/shop.mock.ts\nimport { Decimal } from '@prisma/client/runtime/library';\nimport { ShopCreateDto } from '../dto/shop-create.dto';\n\nexport const CREATE_SHOP: ShopCreateDto = {\n  name: 'Test Shop',\n  vatNumber: 'GB123456789',\n  contact: {\n    email: 'test@example.com',\n    phone: '+44123456789',\n  },\n  address: {\n    addressLine1: '123 Test St',\n    addressLine2: 'Suite 1',\n    zipcode: '12345',\n    city: 'London',\n    country: 'UK',\n  },\n  logo: 'https://example.com/logo.png',\n  hourlyRate: new Decimal(75.0),\n  vat: {\n    vat: new Decimal(20.0),\n    countryCode: 'GB',\n  },\n};\n```\n\n\ndto\n```ts carsu-be/src/shop/dto/shop-create.dto.ts\nimport {\n  IsString,\n  IsNumber,\n  IsBoolean,\n  IsUrl,\n  IsOptional,\n  ValidateNested\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { Decimal } from '@prisma/client/runtime/library';\nimport { ContactCreateDto } from '@contact/dto/contact-create.dto';\nimport { AddressCreateDto } from '@address/dto/address-create.dto';\nimport { VatCreateDto } from '@vat/dto/vat-create.dto';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class ShopCreateDto {\n  @ApiProperty({ example: 'Test Shop', type: 'string' })\n  @IsString()\n  name: string;\n\n  @ApiProperty({ example: 'GB123456789', type: 'string' })\n  @IsString()\n  vatNumber: string;\n\n  @ApiProperty({\n    example: { email: 'test@example.com', phone: '+44123456789' },\n  })\n  @ValidateNested()\n  @Type(() => ContactCreateDto)\n  contact: ContactCreateDto;\n\n  @ApiProperty({\n    example: {\n      addressLine1: '123 Test St',\n      addressLine2: 'Suite 1',\n      zipcode: '12345',\n      city: 'London',\n      country: 'UK',\n    },\n  })\n  @ValidateNested()\n  @Type(() => AddressCreateDto)\n  address: AddressCreateDto;\n\n  @ApiProperty({ example: 'https://example.com/logo.png', type: 'string' })\n  @IsUrl()\n  logo: string;\n\n  @ApiProperty({ example: true, required: false, type: 'boolean' })\n  @IsBoolean()\n  @IsOptional()\n  enabled?: boolean;\n\n  @ApiProperty({ example: 75.0, type: 'number' })\n  @IsNumber()\n  @Type(() => Number)\n  hourlyRate: Decimal;\n\n  @ApiProperty({\n    example: { vat: 20.0, countryCode: 'GB' },\n  })\n  @ValidateNested()\n  @Type(() => VatCreateDto)\n  vat: VatCreateDto;\n}\n```\n\n```ts carsu-be/src/shop/dto/shop-update.dto.ts\nimport { OmitType, PartialType } from '@nestjs/mapped-types';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { ShopCreateDto } from './shop-create.dto';\nimport { Type } from 'class-transformer';\nimport { ValidateNested } from 'class-validator';\nimport { ContactUpdateDto } from '@app/contact/dto/contact-update.dto';\nimport { AddressUpdateDto } from '@app/address/dto/address-update.dto';\nimport { VatUpdateDto } from '@app/vat/dto/vat-update.dto';\n\nexport class ShopUpdateDto extends PartialType(\n  OmitType(ShopCreateDto, ['contact', 'address', 'vat'] as const),\n) {\n  @ApiProperty({\n    example: { email: 'test@example.com', phone: '+44123456789' },\n  })\n  @ValidateNested()\n  @Type(() => ContactUpdateDto)\n  contact?: ContactUpdateDto;\n\n  @ApiProperty({\n    example: {\n      addressLine1: '123 Test St',\n      addressLine2: 'Suite 1',\n      zipcode: '12345',\n      city: 'London',\n      country: 'UK',\n    },\n  })\n  @ValidateNested()\n  @Type(() => AddressUpdateDto)\n  address?: AddressUpdateDto;\n\n  @ApiProperty({\n    example: { vat: 20.0, countryCode: 'GB' },\n  })\n  @ValidateNested()\n  @Type(() => VatUpdateDto)\n  vat?: VatUpdateDto;\n}\n```\n\n\ninterfaces\n```ts carsu-be/src/shop/interfaces/shop.interface.ts\n```\n\n\n```ts carsu-be/src/shop/shop.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ShopController } from './shop.controller';\nimport { ShopService } from './shop.service';\nimport { BadRequestException } from '@nestjs/common';\nimport { CREATE_SHOP } from './__mocks__/shop.mock';\nimport { ShopCreateDto } from './dto/shop-create.dto';\n\ndescribe('ShopController', () => {\n  let controller: ShopController;\n  let service: ShopService;\n\n  const mockCreateShopDto: ShopCreateDto = CREATE_SHOP;\n\n  const mockCreatedShop = {\n    id: '123e4567-e89b-12d3-a456-426614174000',\n    ...mockCreateShopDto,\n    enabled: true,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n\n  const mockShopService = {\n    create: jest.fn(),\n    update: jest.fn(),\n    getShop: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [ShopController],\n      providers: [\n        {\n          provide: ShopService,\n          useValue: mockShopService,\n        },\n      ],\n    }).compile();\n\n    controller = module.get<ShopController>(ShopController);\n    service = module.get<ShopService>(ShopService);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('constructor', () => {\n    it('should be defined', () => {\n      expect(controller).toBeDefined();\n    });\n  });\n\n  describe('createShop', () => {\n    it('should successfully create a shop', async () => {\n      mockShopService.create.mockResolvedValue(mockCreatedShop);\n\n      const result = await controller.create(mockCreateShopDto);\n\n      expect(result).toEqual(mockCreatedShop);\n      expect(service.create).toHaveBeenCalledWith(mockCreateShopDto);\n      expect(service.create).toHaveBeenCalledTimes(1);\n    });\n\n    it('should throw BadRequestException when service fails', async () => {\n      const errorMessage = 'Failed to create shop';\n      mockShopService.create.mockRejectedValue(\n        new BadRequestException(errorMessage),\n      );\n\n      await expect(controller.create(mockCreateShopDto)).rejects.toThrow(\n        BadRequestException,\n      );\n\n      expect(service.create).toHaveBeenCalledWith(mockCreateShopDto);\n      expect(service.create).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle missing optional fields', async () => {\n      const dtoWithoutOptionals = {\n        ...mockCreateShopDto,\n        address: {\n          ...mockCreateShopDto.address,\n          addressLine2: undefined,\n        },\n      };\n      mockShopService.create.mockResolvedValue({\n        ...mockCreatedShop,\n        address: {\n          ...mockCreatedShop.address,\n          addressLine2: undefined,\n        },\n      });\n\n      const result = await controller.create(dtoWithoutOptionals);\n\n      expect(result.address.addressLine2).toBeUndefined();\n      expect(service.create).toHaveBeenCalledWith(dtoWithoutOptionals);\n    });\n  });\n\n  describe('updateShop', () => {\n    const shopId = mockCreatedShop.id;\n    const updateDto = {\n      name: 'Updated Shop Name',\n      address: {\n        addressLine1: 'New Address Line 1',\n        city: 'New City',\n        country: 'New Country',\n        postalCode: '12345',\n      },\n    };\n\n    it('should successfully update a shop', async () => {\n      const updatedShop = { ...mockCreatedShop, ...updateDto };\n      mockShopService.update.mockResolvedValue(updatedShop);\n\n      const result = await controller.update(shopId, updateDto);\n\n      expect(result).toEqual(updatedShop);\n      expect(service.update).toHaveBeenCalledWith(shopId, updateDto);\n      expect(service.update).toHaveBeenCalledTimes(1);\n    });\n\n    it('should throw BadRequestException when update fails', async () => {\n      mockShopService.update.mockRejectedValue(\n        new BadRequestException('Failed to update shop'),\n      );\n\n      await expect(controller.update(shopId, updateDto)).rejects.toThrow(\n        BadRequestException,\n      );\n      expect(service.update).toHaveBeenCalledWith(shopId, updateDto);\n      expect(service.update).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('getShop', () => {\n    const shopId = mockCreatedShop.id;\n\n    it('should successfully get a shop', async () => {\n      mockShopService.getShop.mockResolvedValue(mockCreatedShop);\n\n      const result = await controller.getShop(shopId);\n\n      expect(result).toEqual(mockCreatedShop);\n      expect(service.getShop).toHaveBeenCalledWith(shopId);\n      expect(service.getShop).toHaveBeenCalledTimes(1);\n    });\n\n    it('should throw BadRequestException when shop is not found', async () => {\n      mockShopService.getShop.mockRejectedValue(\n        new BadRequestException('Shop not found'),\n      );\n\n      await expect(controller.getShop(shopId)).rejects.toThrow(\n        BadRequestException,\n      );\n      expect(service.getShop).toHaveBeenCalledWith(shopId);\n      expect(service.getShop).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n```\n\n```ts carsu-be/src/shop/shop.controller.ts\nimport {\n  Controller,\n  Post,\n  Body,\n  Put,\n  Param,\n  Get,\n  UseGuards,\n  Request,\n} from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopCreateDto } from './dto/shop-create.dto';\nimport { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';\nimport { ShopUpdateDto } from './dto/shop-update.dto';\nimport { IAuthRequest } from '@auth/interfaces';\n\n@ApiTags('Shops')\n@Controller('shop')\nexport class ShopController {\n  constructor(private readonly shopService: ShopService) {}\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a shop by ID' })\n  @ApiResponse({ status: 200, description: 'Shop successfully retrieved.' })\n  @ApiResponse({ status: 404, description: 'Shop not found.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  async getShop(@Param('id') id: string) {\n    return await this.shopService.getShop({ id });\n  }\n\n  @Post('create')\n  @ApiOperation({ summary: 'Create a new shop' })\n  @ApiResponse({ status: 201, description: 'Shop successfully created.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  async create(@Body() data: ShopCreateDto, @Request() req: IAuthRequest) {\n    return await this.shopService.create(req?.auth?.userId, data);\n  }\n\n  @Put('update/:id')\n  @ApiOperation({ summary: 'Update a shop' })\n  @ApiResponse({ status: 200, description: 'Shop successfully updated.' })\n  @ApiResponse({ status: 400, description: 'Bad request.' })\n  async update(@Param('id') id: string, @Body() payload: ShopUpdateDto) {\n    return await this.shopService.update({\n      where: { id },\n      payload,\n    });\n  }\n}\n```\n\n```ts carsu-be/src/shop/shop.module.ts\nimport { forwardRef, Module } from '@nestjs/common';\nimport { ShopService } from './shop.service';\nimport { ShopController } from './shop.controller';\nimport { PrismaModule } from '@prisma/prisma.module';\nimport { AuthModule } from '@auth/auth.module';\nimport { UserModule } from '@user/user.module';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\n\n@Module({\n  imports: [PrismaModule, AuthModule, UserModule, CannedJobModule],\n  providers: [ShopService],\n  controllers: [ShopController],\n  exports: [ShopService],\n})\nexport class ShopModule {}\n```\n\n```ts carsu-be/src/shop/shop.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ShopService } from './shop.service';\n\ndescribe('ShopService', () => {\n  let service: ShopService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [ShopService],\n    }).compile();\n\n    service = module.get<ShopService>(ShopService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/shop/shop.service.ts\nimport {\n  Injectable,\n  Logger,\n  BadRequestException,\n  NotFoundException,\n} from '@nestjs/common';\n\nimport { Employee, Prisma } from '@prisma/client';\nimport { PrismaService } from '@prisma/prisma.service';\nimport { ShopCreateDto } from './dto/shop-create.dto';\nimport { ContactService } from '@contact/contact.service';\nimport { ErrorHandler } from '@exceptions/handlers';\nimport { ShopNotFoundException } from '@exceptions/shop/shop-not-found.exception';\nimport { ShopCreateException } from '@exceptions/shop/shop-create.exception';\nimport { ShopUpdateException } from '@exceptions/shop/shop-update.exception';\nimport { ShopUpdateDto } from './dto/shop-update.dto';\nimport { AuthService } from '@auth/auth.service';\nimport { UserService } from '@user/user.service';\nimport { UserNotFoundException } from '@exceptions/user';\nimport { CannedJobService } from '@app/canned-job/canned-job.service';\nimport { preDefinedCannedJobs } from '@app/constants/pre-defined-canned-jobs';\n\n@Injectable()\nexport class ShopService {\n  private readonly logger = new Logger(ShopService.name);\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly authService: AuthService,\n    private readonly userService: UserService,\n    private readonly cannedJobService: CannedJobService,\n  ) {}\n\n  async isEmployee(\n    employeeWhereUniqueInput: Prisma.EmployeeWhereUniqueInput,\n  ): Promise<boolean> {\n    try {\n      const employee: Employee = await this.prisma.employee.findUnique({\n        where: employeeWhereUniqueInput,\n      });\n      if (!employee) return false;\n      return true;\n    } catch (err) {\n      this.logger.log(err);\n      return false;\n    }\n  }\n\n  async getShop(shopWhereUniqueInput: Prisma.ShopWhereUniqueInput) {\n    try {\n      const shop = await this.prisma.shop.findUnique({\n        where: shopWhereUniqueInput,\n        include: {\n          contact: true,\n          address: true,\n          vat: true,\n        },\n      });\n\n      if (!shop)\n        throw new NotFoundException(JSON.stringify(shopWhereUniqueInput));\n      return shop;\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ShopNotFoundException,\n      );\n    }\n  }\n\n  async create(authId: string, payload: ShopCreateDto) {\n    const {\n      name,\n      vatNumber,\n      logo,\n      enabled = true,\n      hourlyRate,\n      address,\n      vat,\n      contact: rawContact,\n    } = payload;\n\n    const { addressLine1, city, country, zipcode } = address;\n    address.addressLine2 = address.addressLine2?.trim() || '';\n    const { addressLine2 } = address;\n\n    const contact = {\n      ...rawContact,\n      phone: ContactService.cleanPhoneNumber(rawContact.phone),\n    };\n\n    // TODO: Auth id should be get from authorization header\n    const user = await this.userService.getUserByAuthId({ authId });\n    if (!user) {\n      throw new UserNotFoundException(JSON.stringify(payload));\n    }\n\n    try {\n      const shopData: Prisma.ShopCreateInput = {\n        name,\n        vatNumber,\n        logo,\n        enabled,\n        hourlyRate,\n        contact: { create: contact },\n        address: {\n          connectOrCreate: {\n            where: {\n              addressLine1_city_country_zipcode_addressLine2: {\n                addressLine1,\n                city,\n                country,\n                zipcode,\n                addressLine2,\n              },\n            },\n            create: address,\n          },\n        },\n        vat: { create: vat },\n        employees: {\n          create: {\n            userId: user.id,\n            gdprConfirmedAt: new Date(),\n            tcConfirmedAt: new Date(),\n          },\n        },\n      };\n\n      return await this.prisma.$transaction(async (tx) => {\n        const shop = await tx.shop.create({\n          data: shopData,\n          include: {\n            contact: true,\n            address: true,\n            vat: true,\n          },\n        });\n\n        const formattedCannedJobs = preDefinedCannedJobs.map((jobGroup) => {\n          return {\n            serviceGroups: jobGroup.map((item, index) => ({\n              description: item.description,\n              category: item.category,\n              macroCategory: null, // Add this if needed\n              position: index + 1, // Add a default position\n              shopId: shop.id,\n              services: item.services\n                ? item.services.map((service, index) => ({\n                    ...service,\n                    position: index + 1, // Add position to each service\n                  }))\n                : [],\n            })),\n          };\n        });\n\n        // Create canned jobs within the same transaction\n        await this.cannedJobService.createMany(\n          shop.id,\n          formattedCannedJobs,\n          tx,\n        );\n\n        await this.authService.updateUserPublicMetadata(authId, {\n          shopId: shop.id,\n        });\n\n        return shop;\n      });\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ShopCreateException,\n      );\n    }\n  }\n\n  async update(params: {\n    where: Prisma.ShopWhereUniqueInput;\n    payload: ShopUpdateDto;\n  }) {\n    try {\n      const { where, payload } = params;\n      const { name, vatNumber, logo, enabled, hourlyRate, address, vat } =\n        payload;\n      let { contact } = payload;\n      contact.phone = ContactService.cleanPhoneNumber(contact.phone);\n\n      return await this.prisma.shop.update({\n        where,\n        data: {\n          name,\n          vatNumber,\n          logo,\n          enabled,\n          hourlyRate,\n          contact: {\n            update: contact,\n          },\n          address: {\n            update: address,\n          },\n          vat: {\n            update: vat,\n          },\n        },\n      });\n    } catch (error) {\n      this.logger.error(error);\n      ErrorHandler.handleError(\n        error,\n        Prisma.PrismaClientKnownRequestError,\n        BadRequestException,\n        ShopUpdateException,\n      );\n    }\n  }\n}\n```\n\ntypes\n```ts carsu-be/src/shop/types/shop.type.ts\n```\n\n\ncan you please check it throughly. in the cannedjobmodule i  use prisma and workmanagement and then in the shop.service i use the cannedjob service. \nAfter thoroughly examining your code, I've identified the issue. The problem is that in the `CannedJobService` constructor, you're injecting `PrismaTransactionService` which might not be properly exported from the `PrismaModule`.\n\nHere's what I've found:\n\n1. In `ShopService`, you're correctly injecting and using `CannedJobService`.\n2. In `ShopModule`, you're correctly importing `CannedJobModule`.\n3. In `CannedJobService`, you're injecting `PrismaTransactionService` which may not be properly available.\n\nLet's fix this:\n\n1. First, create or update `PrismaTransactionService` provider in your `PrismaModule`:\n\n```typescript\n// In prisma.module.ts\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from './prisma.service';\nimport { PrismaTransactionService } from './prisma-transaction.service';\n\n@Module({\n  providers: [PrismaService, PrismaTransactionService],\n  exports: [PrismaService, PrismaTransactionService],\n})\nexport class PrismaModule {}\n```\n\n2. Next, check if your auth.module.ts has the CannedJobModule imported:\n\n```typescript\n// In auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { CannedJobModule } from '@canned-job/canned-job.module';\n// other imports...\n\n@Module({\n  imports: [\n    CannedJobModule,\n    // other imports...\n  ],\n  // other properties...\n})\nexport class AuthModule {}\n```\n\n3. Add a check in your CannedJobService to handle the missing dependency more gracefully:\n\n```typescript\n// In canned-job.service.ts\n@Injectable()\nexport class CannedJobService {\n  private readonly logger = new Logger(CannedJobService.name);\n  \n  constructor(\n    private readonly prisma: PrismaService,\n    @Optional() private readonly prismaTransactionService: PrismaTransactionService, // Mark as optional\n    private readonly workManagementService: WorkManagementService,\n  ) {\n    // If prismaTransactionService is not available, create a simple implementation\n    if (!this.prismaTransactionService) {\n      this.prismaTransactionService = {\n        executeWithTransaction: async (callback, tx) => {\n          if (tx) {\n            return await callback(tx);\n          } else {\n            return await callback(this.prisma);\n          }\n        }\n      };\n    }\n  }\n  \n  // Rest of your service...\n}\n```\n\n4. Update the WorkManagementModule to export PrismaTransactionService:\n\n```typescript\n// In work-management.module.ts\n@Module({\n  imports: [PrismaModule],\n  controllers: [WorkManagementController],\n  providers: [WorkManagementService],\n  exports: [WorkManagementService, PrismaTransactionService], // Add PrismaTransactionService\n})\nexport class WorkManagementModule {}\n```\n\n5. An alternative approach is to simplify the CannedJobService by removing the dependency on PrismaTransactionService and implementing the transaction logic directly:\n\n```typescript\n// Alternative fix for canned-job.service.ts\n@Injectable()\nexport class CannedJobService {\n  private readonly logger = new Logger(CannedJobService.name);\n  \n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly workManagementService: WorkManagementService,\n  ) {}\n\n  // Replace the executeWithTransaction methods with direct use of prisma\n  async createMany(\n    shopId: string,\n    jobGroups: CannedJobCreateManyDto[],\n    tx?: Prisma.TransactionClient,\n  ) {\n    // Implementation using direct prisma calls\n    const prisma = tx || this.prisma;\n    const serviceGroupsToCreate = [];\n    const servicesToCreate = [];\n    const cannedJobsToCreate = [];\n\n    // Rest of the implementation...\n    \n    try {\n      // Execute database operations\n      await prisma.cannedJob.createMany({\n        data: cannedJobsToCreate,\n      });\n      \n      // More operations...\n      \n      return result;\n    } catch (error) {\n      // Error handling\n    }\n  }\n  \n  // Update other methods similarly\n}\n```\n\nThe key issue is that you have a dependency chain: `ShopService` → `CannedJobService` → `PrismaTransactionService`, but NestJS is looking for `PrismaTransactionService` in the wrong module context.\n\nChoose one of these approaches based on your preference and project structure. The simplest solution would be the last one - removing the dependency on PrismaTransactionService and using the direct Prisma client.\ncarsu-be/src/prisma\n```ts carsu-be/src/prisma/prisma-transaction.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Prisma, PrismaClient } from '@prisma/client';\n\nimport { PrismaService } from './prisma.service';\n\n@Injectable()\nexport class PrismaTransactionService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async executeWithTransaction<T>(\n    operation: (tx: Prisma.TransactionClient) => Promise<T>,\n    tx?: Prisma.TransactionClient\n  ): Promise<T> {\n    if (tx) {\n      return operation(tx);\n    }\n    return this.prisma.$transaction((tx) => operation(tx));\n  }\n}\n```\n\n```ts carsu-be/src/prisma/prisma.module.ts\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from './prisma.service';\nimport { PrismaTransactionService } from './prisma-transaction.service';\n\n@Module({\n  providers: [PrismaService, PrismaTransactionService],\n  exports: [PrismaService, PrismaTransactionService]\n})\nexport class PrismaModule {}\n```\n\n```ts carsu-be/src/prisma/prisma.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { PrismaService } from './prisma.service';\n\ndescribe('PrismaService', () => {\n  let service: PrismaService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [PrismaService],\n    }).compile();\n\n    service = module.get<PrismaService>(PrismaService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n```\n\n```ts carsu-be/src/prisma/prisma.service.ts\nimport { Injectable, OnModuleInit } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit{\n  async onModuleInit() {\n    await this.$connect();\n  }\n}\n```\n\n\nit","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1516}}},{"id":{"replica_id":0,"value":83},"start":50387,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1517}}},{"id":{"replica_id":0,"value":154},"start":50530,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1518}}},{"id":{"replica_id":0,"value":155},"start":52624,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1519}}},{"id":{"replica_id":0,"value":310},"start":53921,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1520}}},{"id":{"replica_id":0,"value":371},"start":56442,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1521}}},{"id":{"replica_id":0,"value":392},"start":57554,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1522}}},{"id":{"replica_id":0,"value":393},"start":63594,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1523}}},{"id":{"replica_id":0,"value":787},"start":63657,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1524}}},{"id":{"replica_id":0,"value":1296},"start":95687,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1525}}},{"id":{"replica_id":0,"value":1297},"start":99932,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1526}}}],"summary":"The error occurs because of a circular dependency between the ShopModule and CannedJobModule. Each module is trying to import the other:","slash_command_output_sections":[{"range":{"start":0,"end":1276},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1275},"icon":"Library","label":"General","metadata":null},{"range":{"start":1277,"end":5592},"icon":"Library","label":"nest","metadata":null},{"range":{"start":5593,"end":23155},"icon":"Folder","label":"carsu-be/src/shop","metadata":null},{"range":{"start":5611,"end":6239},"icon":"Folder","label":"__mocks__","metadata":null},{"range":{"start":5621,"end":6238},"icon":"File","label":"carsu-be/src/shop/__mocks__/shop.mock.ts","metadata":{"path":"carsu-be/src/shop/__mocks__/shop.mock.ts"}},{"range":{"start":6240,"end":9066},"icon":"Folder","label":"dto","metadata":null},{"range":{"start":6244,"end":7864},"icon":"File","label":"carsu-be/src/shop/dto/shop-create.dto.ts","metadata":{"path":"carsu-be/src/shop/dto/shop-create.dto.ts"}},{"range":{"start":7865,"end":9065},"icon":"File","label":"carsu-be/src/shop/dto/shop-update.dto.ts","metadata":{"path":"carsu-be/src/shop/dto/shop-update.dto.ts"}},{"range":{"start":9067,"end":9136},"icon":"Folder","label":"interfaces","metadata":null},{"range":{"start":9078,"end":9135},"icon":"File","label":"carsu-be/src/shop/interfaces/shop.interface.ts","metadata":{"path":"carsu-be/src/shop/interfaces/shop.interface.ts"}},{"range":{"start":9137,"end":14052},"icon":"File","label":"carsu-be/src/shop/shop.controller.spec.ts","metadata":{"path":"carsu-be/src/shop/shop.controller.spec.ts"}},{"range":{"start":14053,"end":15702},"icon":"File","label":"carsu-be/src/shop/shop.controller.ts","metadata":{"path":"carsu-be/src/shop/shop.controller.ts"}},{"range":{"start":15703,"end":16383},"icon":"File","label":"carsu-be/src/shop/shop.module.ts","metadata":{"path":"carsu-be/src/shop/shop.module.ts"}},{"range":{"start":16384,"end":16879},"icon":"File","label":"carsu-be/src/shop/shop.service.spec.ts","metadata":{"path":"carsu-be/src/shop/shop.service.spec.ts"}},{"range":{"start":16880,"end":23100},"icon":"File","label":"carsu-be/src/shop/shop.service.ts","metadata":{"path":"carsu-be/src/shop/shop.service.ts"}},{"range":{"start":23101,"end":23155},"icon":"Folder","label":"types","metadata":null},{"range":{"start":23107,"end":23154},"icon":"File","label":"carsu-be/src/shop/types/shop.type.ts","metadata":{"path":"carsu-be/src/shop/types/shop.type.ts"}},{"range":{"start":23156,"end":37483},"icon":"Folder","label":"carsu-be/src/canned-job","metadata":null},{"range":{"start":23180,"end":23758},"icon":"File","label":"carsu-be/src/canned-job/canned-job.controller.spec.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.controller.spec.ts"}},{"range":{"start":23759,"end":25571},"icon":"File","label":"carsu-be/src/canned-job/canned-job.controller.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.controller.ts"}},{"range":{"start":25572,"end":26119},"icon":"File","label":"carsu-be/src/canned-job/canned-job.module.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.module.ts"}},{"range":{"start":26120,"end":26663},"icon":"File","label":"carsu-be/src/canned-job/canned-job.service.spec.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.service.spec.ts"}},{"range":{"start":26664,"end":34881},"icon":"File","label":"carsu-be/src/canned-job/canned-job.service.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.service.ts"}},{"range":{"start":34882,"end":37483},"icon":"Folder","label":"dto","metadata":null},{"range":{"start":34886,"end":35278},"icon":"File","label":"carsu-be/src/canned-job/dto/canned-job-create-many.dto.ts","metadata":{"path":"carsu-be/src/canned-job/dto/canned-job-create-many.dto.ts"}},{"range":{"start":35279,"end":35879},"icon":"File","label":"carsu-be/src/canned-job/dto/canned-job-create.dto.ts","metadata":{"path":"carsu-be/src/canned-job/dto/canned-job-create.dto.ts"}},{"range":{"start":35880,"end":37482},"icon":"File","label":"carsu-be/src/canned-job/dto/canned-job-update.dto.ts","metadata":{"path":"carsu-be/src/canned-job/dto/canned-job-update.dto.ts"}},{"range":{"start":37484,"end":49274},"icon":"Folder","label":"carsu-be/src/work-management","metadata":null},{"range":{"start":37513,"end":41619},"icon":"Folder","label":"dto","metadata":null},{"range":{"start":37517,"end":38659},"icon":"File","label":"carsu-be/src/work-management/dto/service-create.dto.ts","metadata":{"path":"carsu-be/src/work-management/dto/service-create.dto.ts"}},{"range":{"start":38660,"end":40683},"icon":"File","label":"carsu-be/src/work-management/dto/service-group-create.dto.ts","metadata":{"path":"carsu-be/src/work-management/dto/service-group-create.dto.ts"}},{"range":{"start":40684,"end":41051},"icon":"File","label":"carsu-be/src/work-management/dto/service-group-update.dto.ts","metadata":{"path":"carsu-be/src/work-management/dto/service-group-update.dto.ts"}},{"range":{"start":41052,"end":41618},"icon":"File","label":"carsu-be/src/work-management/dto/service-update.dto.ts","metadata":{"path":"carsu-be/src/work-management/dto/service-update.dto.ts"}},{"range":{"start":41620,"end":42243},"icon":"File","label":"carsu-be/src/work-management/work-management.controller.spec.ts","metadata":{"path":"carsu-be/src/work-management/work-management.controller.spec.ts"}},{"range":{"start":42244,"end":42431},"icon":"File","label":"carsu-be/src/work-management/work-management.controller.ts","metadata":{"path":"carsu-be/src/work-management/work-management.controller.ts"}},{"range":{"start":42432,"end":42927},"icon":"File","label":"carsu-be/src/work-management/work-management.module.ts","metadata":{"path":"carsu-be/src/work-management/work-management.module.ts"}},{"range":{"start":42928,"end":43516},"icon":"File","label":"carsu-be/src/work-management/work-management.service.spec.ts","metadata":{"path":"carsu-be/src/work-management/work-management.service.spec.ts"}},{"range":{"start":43517,"end":49273},"icon":"File","label":"carsu-be/src/work-management/work-management.service.ts","metadata":{"path":"carsu-be/src/work-management/work-management.service.ts"}},{"range":{"start":52667,"end":53278},"icon":"File","label":"carsu-be/src/canned-job/canned-job.module.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.module.ts"}},{"range":{"start":53279,"end":53867},"icon":"File","label":"carsu-be/src/shop/shop.module.ts","metadata":{"path":"carsu-be/src/shop/shop.module.ts"}},{"range":{"start":63657,"end":78048},"icon":"Folder","label":"carsu-be/src/canned-job","metadata":null},{"range":{"start":63681,"end":64259},"icon":"File","label":"carsu-be/src/canned-job/canned-job.controller.spec.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.controller.spec.ts"}},{"range":{"start":64260,"end":66072},"icon":"File","label":"carsu-be/src/canned-job/canned-job.controller.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.controller.ts"}},{"range":{"start":66073,"end":66684},"icon":"File","label":"carsu-be/src/canned-job/canned-job.module.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.module.ts"}},{"range":{"start":66685,"end":67228},"icon":"File","label":"carsu-be/src/canned-job/canned-job.service.spec.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.service.spec.ts"}},{"range":{"start":67229,"end":75446},"icon":"File","label":"carsu-be/src/canned-job/canned-job.service.ts","metadata":{"path":"carsu-be/src/canned-job/canned-job.service.ts"}},{"range":{"start":75447,"end":78048},"icon":"Folder","label":"dto","metadata":null},{"range":{"start":75451,"end":75843},"icon":"File","label":"carsu-be/src/canned-job/dto/canned-job-create-many.dto.ts","metadata":{"path":"carsu-be/src/canned-job/dto/canned-job-create-many.dto.ts"}},{"range":{"start":75844,"end":76444},"icon":"File","label":"carsu-be/src/canned-job/dto/canned-job-create.dto.ts","metadata":{"path":"carsu-be/src/canned-job/dto/canned-job-create.dto.ts"}},{"range":{"start":76445,"end":78047},"icon":"File","label":"carsu-be/src/canned-job/dto/canned-job-update.dto.ts","metadata":{"path":"carsu-be/src/canned-job/dto/canned-job-update.dto.ts"}},{"range":{"start":78049,"end":95536},"icon":"Folder","label":"carsu-be/src/shop","metadata":null},{"range":{"start":78067,"end":78695},"icon":"Folder","label":"__mocks__","metadata":null},{"range":{"start":78077,"end":78694},"icon":"File","label":"carsu-be/src/shop/__mocks__/shop.mock.ts","metadata":{"path":"carsu-be/src/shop/__mocks__/shop.mock.ts"}},{"range":{"start":78696,"end":81522},"icon":"Folder","label":"dto","metadata":null},{"range":{"start":78700,"end":80320},"icon":"File","label":"carsu-be/src/shop/dto/shop-create.dto.ts","metadata":{"path":"carsu-be/src/shop/dto/shop-create.dto.ts"}},{"range":{"start":80321,"end":81521},"icon":"File","label":"carsu-be/src/shop/dto/shop-update.dto.ts","metadata":{"path":"carsu-be/src/shop/dto/shop-update.dto.ts"}},{"range":{"start":81523,"end":81592},"icon":"Folder","label":"interfaces","metadata":null},{"range":{"start":81534,"end":81591},"icon":"File","label":"carsu-be/src/shop/interfaces/shop.interface.ts","metadata":{"path":"carsu-be/src/shop/interfaces/shop.interface.ts"}},{"range":{"start":81593,"end":86508},"icon":"File","label":"carsu-be/src/shop/shop.controller.spec.ts","metadata":{"path":"carsu-be/src/shop/shop.controller.spec.ts"}},{"range":{"start":86509,"end":88158},"icon":"File","label":"carsu-be/src/shop/shop.controller.ts","metadata":{"path":"carsu-be/src/shop/shop.controller.ts"}},{"range":{"start":88159,"end":88764},"icon":"File","label":"carsu-be/src/shop/shop.module.ts","metadata":{"path":"carsu-be/src/shop/shop.module.ts"}},{"range":{"start":88765,"end":89260},"icon":"File","label":"carsu-be/src/shop/shop.service.spec.ts","metadata":{"path":"carsu-be/src/shop/shop.service.spec.ts"}},{"range":{"start":89261,"end":95481},"icon":"File","label":"carsu-be/src/shop/shop.service.ts","metadata":{"path":"carsu-be/src/shop/shop.service.ts"}},{"range":{"start":95482,"end":95536},"icon":"Folder","label":"types","metadata":null},{"range":{"start":95488,"end":95535},"icon":"File","label":"carsu-be/src/shop/types/shop.type.ts","metadata":{"path":"carsu-be/src/shop/types/shop.type.ts"}},{"range":{"start":99932,"end":101718},"icon":"Folder","label":"carsu-be/src/prisma","metadata":null},{"range":{"start":99952,"end":100538},"icon":"File","label":"carsu-be/src/prisma/prisma-transaction.service.ts","metadata":{"path":"carsu-be/src/prisma/prisma-transaction.service.ts"}},{"range":{"start":100539,"end":100902},"icon":"File","label":"carsu-be/src/prisma/prisma.module.ts","metadata":{"path":"carsu-be/src/prisma/prisma.module.ts"}},{"range":{"start":100903,"end":101416},"icon":"File","label":"carsu-be/src/prisma/prisma.service.spec.ts","metadata":{"path":"carsu-be/src/prisma/prisma.service.spec.ts"}},{"range":{"start":101417,"end":101717},"icon":"File","label":"carsu-be/src/prisma/prisma.service.ts","metadata":{"path":"carsu-be/src/prisma/prisma.service.ts"}}]}
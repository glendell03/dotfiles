{"id":"a08d5a1d-395e-4cfb-b8d2-830460eaccba","zed":"context","version":"0.4.0","text":"\nDO NOT GIVE ME HIGH-LEVEL THEORY. IF I ASK FOR A FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON'T WANT \"Here's how you can blablabla\"\n\nBe casual unless otherwise specified\nBe terse and concise\nSuggest solutions that I didn’t think about—anticipate my needs\nTreat me as an expert\nBe accurate and thorough\nGive the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer\nValue good arguments over authorities, the source is irrelevant\nConsider new technologies and contrarian ideas, not just conventional wisdom\nYou may use high levels of speculation or prediction, just flag it for me\nNo moral lectures\nDiscuss safety only when it's crucial and non-obvious\nIf your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward\nCite sources whenever possible at the end, not inline\nNo need to mention your knowledge cutoff\nNo need to disclose you're an AI\nPlease respect my prettier preferences when you provide code\nSplit into multiple responses if one response isn't enough to answer the question\nFocus on readability over being performant\nFully implement all requested functionality\nLeave NO todos, placeholders, or missing pieces\n\n\nas a senior developer who code with best practices and optimize code\n\nyou are proficient in working in nextjs, supabase, prisma\n\nwe are building a web app were studio can manage the dance class schedules and user can smoothly book and pay for it the studio can invite choreographers and add it as member with a role of \"CHOREOGRAPHERS\"\n\nThese are your task:\n\ncreate an api where we can invite a choreographer without sending an email. as you can see in the studio.ts we have already started coding it but can you make it more functional cause it is not working right now\nthe studio will copy the link and then send it to the choreographer. when open it will be redirected to the \"/invite-accept\" page\nin the page choreographer can accept the invite then upon accepting it will call a trpc api again to update the studioInvitation status and the profile will be added to the studioMember\nwe need to properly handle the unauthenticated user like if the choreographer is not yet registered or logged in the app\nas a senior developer how will you do it.\n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\nimport { createJWT, verifyJWT } from \"~/lib/jwt\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographerWithLink: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Create the Supabase admin client\n        const supabase = await createClient({ isAdmin: true });\n\n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n\n        // Filter users manually to find by email\n        const matchingUsers =\n          data?.users?.filter(\n            (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n          ) || [];\n\n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n\n        // Check for existing member with this email at this studio\n        const existingMember =\n          userIds.length > 0\n            ? await ctx.db.studioMember.findFirst({\n                where: {\n                  studio: {\n                    id: input.studioId,\n                  },\n                  profile: {\n                    authId: {\n                      in: userIds,\n                    },\n                  },\n                },\n              })\n            : null;\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This user is already a member of this studio\",\n          });\n        }\n\n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          // Create a secure JWT token for the existing invitation\n          const token = await createJWT({\n            id: existingInvitation.id,\n            email: input.email,\n            studioId: input.studioId,\n            role: existingInvitation.role,\n            type: \"studio-invitation\",\n          });\n\n          return {\n            status: \"already_invited\",\n            invitation: existingInvitation,\n            inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${existingInvitation.role}&token=${token}`,\n          };\n        }\n\n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        // ctx.profile is guaranteed to exist in adminProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx?.profile?.id ?? \"\", // adminProcedure ensures this exists\n            expiresAt: expirationDate,\n            status: \"PENDING\",\n          },\n        });\n\n        // Create a secure JWT token using the jwt.ts utilities\n        const token = await createJWT({\n          id: invitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role: input.role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"invited\",\n          invitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}&token=${token}`,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to generate invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Update validateInvitation procedure to handle public access\n  validateInvitation: publicProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email().optional(),\n        token: z.string(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (!tokenData?.studioId || !tokenData?.id || !tokenData?.email) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            id: tokenData.id,\n            email: tokenData.email,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            studio: true,\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        return {\n          valid: true,\n          invitation: {\n            ...invitation,\n            studio: enhanceStudioWithLocationNames(invitation.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Validate invitation error:\", error);\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Update acceptInvitationWithLink procedure\n  acceptInvitationWithLink: authedProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            id: tokenData.id,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        // ctx.profile is guaranteed to exist in authedProcedure\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio - ctx.profile is guaranteed in authedProcedure\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n              role: invitation.role,\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\ndance-book-app/src/app/(public)/invite-accept\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token?: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [sentEmail, setSentEmail] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Use the auth hook to handle authentication status\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitation.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle magic link sign-in\n  const handleMagicLinkSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim()) {\n      toast.error(\"Please enter your email address\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n\n      // Generate magic link that redirects back to this invitation page\n      const { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n\n      if (error) {\n        throw error;\n      }\n\n      // Show success message\n      toast.success(\"Check your email for a sign-in link!\");\n      setSentEmail(true);\n    } catch (err) {\n      console.error(\"Error sending magic link:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Failed to send sign-in link\",\n      );\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!studioId || !user?.email) return;\n\n    try {\n      setProcessing(true);\n\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({\n        studioId,\n        role: role as \"ADMIN\" | \"CHOREOGRAPHER\" | \"STAFF\",\n        email: user.email,\n      });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Error state\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (\n    (processing || authLoading || isAcceptingInvitation) &&\n    studioId &&\n    role\n  ) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">Processing your invitation...</p>\n      </NeoCard>\n    );\n  }\n\n  // Render magic link sign-in form if not signed in\n  if (!user) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n\n          {sentEmail ? (\n            <div className=\"text-center\">\n              <p className=\"mb-4 text-gray-700\">\n                Check your email for a sign-in link!\n              </p>\n              <p className=\"text-sm text-gray-500\">\n                After signing in, you'll be able to accept this invitation.\n              </p>\n            </div>\n          ) : (\n            <form onSubmit={handleMagicLinkSignIn} className=\"mt-4 space-y-4\">\n              <p className=\"mb-2 text-center text-gray-700\">\n                Sign in with your email to accept this invitation\n              </p>\n              <Input\n                type=\"email\"\n                placeholder=\"Your email address\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full\"\n              />\n              <NeoButton\n                type=\"submit\"\n                className=\"w-full\"\n                size=\"lg\"\n                disabled={processing}\n              >\n                {processing ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Sign In\"\n                )}\n              </NeoButton>\n            </form>\n          )}\n        </NeoCard>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in as{\" \"}\n          <strong className=\"font-bold\">{user.email}</strong>\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-skeleton.tsx\nimport { Loader2 } from \"lucide-react\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\n\nexport function InviteAcceptSkeleton() {\n  return (\n    <div className=\"flex min-h-screen flex-col items-center justify-center bg-yellow-50 p-4 sm:p-8\">\n      <NeoCard className=\"w-full max-w-md p-0\">\n        {/* Banner Skeleton */}\n        <div className=\"relative h-40 w-full animate-pulse border-b-4 border-black bg-gray-200\" />\n\n        <div className=\"p-6\">\n          {/* Studio Name Skeleton */}\n          <div className=\"mb-6 flex justify-center\">\n            <div className=\"h-8 w-48 animate-pulse rounded-md bg-gray-200\" />\n          </div>\n\n          {/* Location Skeleton */}\n          <div className=\"mb-4 flex items-center gap-2\">\n            <div className=\"h-5 w-5 animate-pulse rounded-full bg-gray-200\" />\n            <div className=\"h-4 w-full animate-pulse rounded-md bg-gray-200\" />\n          </div>\n\n          {/* Description Skeleton */}\n          <div className=\"mb-6 space-y-2\">\n            <div className=\"h-4 w-full animate-pulse rounded-md bg-gray-200\" />\n            <div className=\"h-4 w-5/6 animate-pulse rounded-md bg-gray-200\" />\n          </div>\n\n          {/* Invitation Box Skeleton */}\n          <NeoCard\n            variant=\"colored\"\n            colorClassName=\"bg-gray-100\"\n            className=\"mb-6 p-4\"\n          >\n            <div className=\"mx-auto mb-3 h-6 w-3/4 animate-pulse rounded-md bg-gray-200\" />\n            <div className=\"mx-auto h-5 w-1/2 animate-pulse rounded-md bg-gray-200\" />\n          </NeoCard>\n\n          {/* Button Skeleton */}\n          <div className=\"h-10 w-full animate-pulse rounded-md bg-gray-200\" />\n        </div>\n      </NeoCard>\n    </div>\n  );\n}\n```\n\n```tsx dance-book-app/src/app/(public)/invite-accept/page.tsx\nimport React, { Suspense } from \"react\";\nimport { api, HydrateClient } from \"~/trpc/server\";\nimport { InviteAcceptContent } from \"./invite-accept-content\";\nimport { InviteAcceptSkeleton } from \"./invite-accept-skeleton\";\nimport { MapPin, Building2 } from \"lucide-react\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport Image from \"next/image\";\nimport { notFound } from \"next/navigation\";\n\ninterface InviteAcceptPageProps {\n  searchParams: Promise<{\n    studioId?: string;\n    role?: string;\n    token?: string;\n  }>;\n}\n\n// Server component to display the studio information\nasync function InviteAcceptServer({\n  studioId,\n  role,\n  token,\n}: {\n  studioId?: string;\n  role?: string;\n  token?: string;\n}) {\n  // Return early if no studioId\n  if (!studioId || !role) {\n    return notFound();\n  }\n\n  // Fetch studio data on the server\n  const studioData = await api.studio.findUnique({ id: studioId });\n\n  if (!studioData) {\n    return notFound();\n  }\n\n  return (\n    <div className=\"flex min-h-screen flex-col items-center justify-center p-4 sm:p-8\">\n      <NeoCard className=\"w-full max-w-md overflow-hidden p-0\">\n        {/* Studio Logo/Banner */}\n        <div className=\"neo-border relative h-40 w-full overflow-hidden rounded-xl border-b-4 border-black\">\n          {studioData.logo ? (\n            <Image\n              src={studioData.logo}\n              alt={studioData.name}\n              fill\n              sizes=\"(max-width: 768px) 100vw, 400px\"\n              className=\"object-cover\"\n              unoptimized\n            />\n          ) : (\n            <div className=\"flex h-full w-full items-center justify-center bg-muted\">\n              <Building2 className=\"h-16 w-16 text-muted-foreground\" />\n            </div>\n          )}\n          {/* Fallback Building icon that will show when image errors */}\n          <div className=\"hidden h-full w-full items-center justify-center\">\n            <Building2 className=\"h-16 w-16 text-muted-foreground\" />\n          </div>\n        </div>\n\n        <div className=\"p-6\">\n          {/* Studio Info */}\n          <div className=\"mb-8\">\n            <h1 className=\"mb-3 text-center text-2xl font-black\">\n              {studioData.name || \"Studio\"}\n            </h1>\n\n            <div className=\"mb-4 flex items-start gap-2\">\n              <MapPin className=\"mt-1 h-5 w-5 flex-shrink-0 text-primary\" />\n              <p className=\"text-md\">\n                {studioData.address},{studioData.city},{\" \"}\n                {studioData.stateName || studioData.state}\n                {studioData.postalCode && `, ${studioData.postalCode}`}\n              </p>\n            </div>\n\n            {studioData.description && (\n              <p className=\"mt-3 text-gray-700\">{studioData.description}</p>\n            )}\n          </div>\n\n          {/* Client component handles authentication */}\n          <InviteAcceptContent\n            token={token}\n            studioId={studioId}\n            role={role}\n            studioName={studioData.name}\n          />\n        </div>\n      </NeoCard>\n    </div>\n  );\n}\n\nexport default async function InviteAcceptPage({\n  searchParams,\n}: InviteAcceptPageProps) {\n  const { studioId, role, token } = await searchParams;\n\n  return (\n    <Suspense fallback={<InviteAcceptSkeleton />}>\n      <InviteAcceptServer studioId={studioId} role={role} token={token} />\n    </Suspense>\n  );\n}\n```\n\n\n```prisma dance-book-app/prisma/schema.prisma\n// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider  = \"postgresql\"\n  url       = env(\"DATABASE_URL\")\n  directUrl = env(\"DIRECT_URL\")\n}\n\nmodel Profile {\n  id     String @id @default(uuid()) @db.Uuid\n  authId String @unique @db.Uuid\n\n  // Relationships\n  studioMembers StudioMember[]\n\n  // Timestamps\n  createdAt        DateTime           @default(now()) @db.Timestamp\n  updatedAt        DateTime           @updatedAt @db.Timestamp\n  Booking          Booking[]\n  StudioInvitation StudioInvitation[]\n}\n\nmodel Studio {\n  id          String  @id @default(uuid()) @db.Uuid\n  slug        String  @unique @db.VarChar(100)\n  name        String  @db.VarChar(100)\n  description String? @db.Text\n  address     String  @db.VarChar(255)\n  city        String  @db.VarChar(100)\n  state       String  @db.VarChar(100)\n  postalCode  String  @db.VarChar(20)\n  country     String  @db.Char(2)\n  logo        String? @db.VarChar(255)\n\n  isActive Boolean @default(true)\n\n  openingHours Json? @db.JsonB // Store hours of operation as JSON\n\n  // Relationships\n  members StudioMember[]\n\n  // Timestamps\n  createdAt        DateTime           @default(now()) @db.Timestamp\n  updatedAt        DateTime           @updatedAt @db.Timestamp\n  Schedule         Schedule[]\n  StudioInvitation StudioInvitation[]\n\n  // Indexes\n  @@index([city, country])\n  @@index([isActive])\n  @@index([slug])\n}\n\nenum StudioRole {\n  OWNER\n  ADMIN\n  CHOREOGRAPHER\n  STAFF\n}\n\nmodel StudioMember {\n  id String @id @default(uuid()) @db.Uuid\n\n  // Relationship fields\n  profileId String  @db.Uuid\n  studioId  String  @db.Uuid\n  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)\n  studio    Studio  @relation(fields: [studioId], references: [id], onDelete: Cascade)\n\n  // Role and permissions\n  role StudioRole @default(STAFF)\n\n  choreographerSchedules Schedule[] @relation(\"ChoreographerSchedules\")\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Unique constraint to prevent duplicate memberships\n  @@unique([profileId, studioId])\n  // Indexes for performance\n  @@index([profileId])\n  @@index([studioId])\n  @@index([role])\n}\n\nmodel Schedule {\n  id          String   @id @default(uuid()) @db.Uuid\n  title       String   @db.VarChar(100)\n  description String?  @db.Text\n  startTime   DateTime @db.Timestamp\n  endTime     DateTime @db.Timestamp\n  maxCapacity Int?     @db.Integer\n\n  // Pricing\n  price    Decimal? @db.Decimal(10, 2)\n  currency String?  @db.Char(3) // ISO 4217 currency code\n\n  // Status\n  isActive    Boolean @default(true)\n  isCancelled Boolean @default(false)\n\n  // Location information (room/studio specific)\n  location String? @db.VarChar(100)\n\n  // Relationships\n  studioId        String        @db.Uuid\n  studio          Studio        @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  choreographerId String?       @db.Uuid\n  choreographer   StudioMember? @relation(name: \"ChoreographerSchedules\", fields: [choreographerId], references: [id], onDelete: SetNull)\n\n  // For handling bookings\n  bookings Booking[]\n\n  // Dance style/class type\n  danceStyle String? @db.VarChar(50)\n  level      String? @db.VarChar(50)\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Indexes\n  @@index([studioId])\n  @@index([choreographerId])\n  @@index([startTime])\n  @@index([isActive, isCancelled])\n  @@index([danceStyle])\n}\n\nmodel Booking {\n  id     String        @id @default(uuid()) @db.Uuid\n  status BookingStatus @default(RESERVED)\n  notes  String?       @db.Text\n\n  // Relationships\n  scheduleId String   @db.Uuid\n  schedule   Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)\n  profileId  String   @db.Uuid\n  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)\n\n  // Payment information\n  paymentId String?  @db.Uuid\n  payment   Payment? @relation(fields: [paymentId], references: [id])\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Indexes\n  @@index([scheduleId])\n  @@index([profileId])\n  @@index([status])\n  @@index([createdAt])\n}\n\nenum BookingStatus {\n  RESERVED\n  CONFIRMED\n  CANCELLED\n  ATTENDED\n  NO_SHOW\n}\n\nmodel Payment {\n  id       String        @id @default(uuid()) @db.Uuid\n  amount   Decimal       @db.Decimal(10, 2)\n  currency String        @db.Char(3) // ISO 4217 currency code\n  status   PaymentStatus @default(PENDING)\n\n  // Payment provider details\n  externalId String? @db.VarChar(100) // ID from payment provider\n  provider   String? @db.VarChar(50) // e.g., \"stripe\", \"paypal\"\n\n  // Relationships\n  bookings Booking[]\n\n  // Timestamps\n  createdAt DateTime @default(now()) @db.Timestamp\n  updatedAt DateTime @updatedAt @db.Timestamp\n\n  // Indexes\n  @@index([status])\n  @@index([externalId])\n}\n\nenum PaymentStatus {\n  PENDING\n  COMPLETED\n  FAILED\n  REFUNDED\n}\n\nmodel StudioInvitation {\n  id          String     @id @default(uuid()) @db.Uuid\n  email       String\n  studioId    String     @db.Uuid\n  studio      Studio     @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  role        StudioRole @default(CHOREOGRAPHER)\n  invitedById String     @db.Uuid\n  invitedBy   Profile    @relation(fields: [invitedById], references: [id])\n  status      String     @default(\"PENDING\")\n  createdAt   DateTime   @default(now()) @db.Timestamp\n  expiresAt   DateTime   @db.Timestamp\n\n  @@index([email, studioId])\n  @@index([status])\n}\n```\n\n\nI have now done creating the trpc api \nyour task now is to fix the invite-accept page\nthe choreographer should be able to accept the invitation and join the studio\nI'll implement the necessary changes to make the choreographer invitation system fully functional. Let's fix the existing code and implement the missing pieces:\n\n1. First, let's fix the `studioRouter` by implementing the missing pieces in the invitation process:\n\n```typescript\n// Add this to the studio.ts router\n\n// Update validateInvitation procedure to handle tokens properly\nvalidateInvitation: publicProcedure\n  .input(\n    z.object({\n      token: z.string(),\n    }),\n  )\n  .query(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      if (!tokenData?.id || !tokenData?.studioId || tokenData.type !== \"studio-invitation\") {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n          status: \"PENDING\",\n        },\n        include: {\n          studio: true,\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      return {\n        valid: true,\n        invitation: {\n          ...invitation,\n          studio: enhanceStudioWithLocationNames(invitation.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Validate invitation error:\", error);\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation link\",\n        cause: error,\n      });\n    }\n  }),\n\n// Update acceptInvitationWithLink procedure\nacceptInvitationWithLink: authedProcedure\n  .input(\n    z.object({\n      token: z.string(),\n    }),\n  )\n  .mutation(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      if (\n        !tokenData?.id ||\n        !tokenData?.studioId ||\n        tokenData.type !== \"studio-invitation\"\n      ) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n          status: \"PENDING\",\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      // Check if user is already a member\n      const existingMembership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: invitation.studioId,\n          },\n        },\n      });\n\n      if (existingMembership) {\n        // Update invitation status\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"ACCEPTED\" },\n        });\n\n        return {\n          status: \"already_member\",\n          membership: existingMembership,\n        };\n      }\n\n      // Create new membership in a transaction\n      const result = await ctx.db.$transaction(async (tx) => {\n        // Add user to studio\n        const membership = await tx.studioMember.create({\n          data: {\n            profileId: ctx.profile.id,\n            studioId: invitation.studioId,\n            role: invitation.role,\n          },\n          include: {\n            studio: true,\n            profile: true,\n          },\n        });\n\n        // Update invitation status\n        await tx.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"ACCEPTED\" },\n        });\n\n        return membership;\n      });\n\n      return {\n        status: \"accepted\",\n        membership: {\n          ...result,\n          studio: enhanceStudioWithLocationNames(result.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"Failed to accept invitation\",\n        cause: error,\n      });\n    }\n  }),\n```\n\n2. Now, let's create a hook that will check for auth status with invitation handling:\n\n```typescript\n// src/hooks/use-auth-with-invites.tsx\nimport { useEffect, useState } from 'react';\nimport { createClient } from '~/lib/supabase/client';\nimport { useRouter } from 'next/navigation';\nimport { api } from '~/trpc/react';\n\nexport function useAuthWithInvites() {\n  const [user, setUser] = useState<{ id: string; email: string | null } | null>(null);\n  const [loading, setLoading] = useState(true);\n  const router = useRouter();\n  const supabase = createClient();\n  \n  // Get user profile mutation to create if needed\n  const { mutate: getOrCreateProfile } = api.profile.getOrCreate.useMutation({\n    onSuccess: () => {\n      // Successfully created profile if needed\n    },\n    onError: (error) => {\n      console.error('Failed to get or create user profile:', error);\n    },\n  });\n\n  useEffect(() => {\n    async function checkUser() {\n      setLoading(true);\n      try {\n        // Get session from Supabase\n        const { data: { session } } = await supabase.auth.getSession();\n        \n        if (session?.user) {\n          setUser({\n            id: session.user.id,\n            email: session.user.email,\n          });\n          \n          // Ensure user has a profile\n          getOrCreateProfile();\n        } else {\n          setUser(null);\n        }\n      } catch (error) {\n        console.error('Auth check error:', error);\n        setUser(null);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    // Initial check\n    void checkUser();\n\n    // Subscribe to auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (_event, session) => {\n        if (session?.user) {\n          setUser({\n            id: session.user.id,\n            email: session.user.email,\n          });\n          // Ensure user has a profile\n          getOrCreateProfile();\n        } else {\n          setUser(null);\n        }\n        setLoading(false);\n      }\n    );\n\n    // Cleanup subscription\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [supabase, getOrCreateProfile]);\n\n  return { user, loading };\n}\n```\n\n3. Now, let's fix the invite-accept-content.tsx component to properly handle the invitation:\n\n```tsx\n// src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { useAuthWithInvites } from \"~/hooks/use-auth-with-invites\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [sentEmail, setSentEmail] = useState(false);\n  const [isValidInvitation, setIsValidInvitation] = useState<boolean | null>(null);\n  const router = useRouter();\n  const supabase = createClient();\n  \n  // Use the auth hook to handle authentication status\n  const { user, loading: authLoading } = useAuthWithInvites();\n\n  // Validate the invitation token\n  const { data: validationData, isLoading: isValidating } = api.studio.validateInvitation.useQuery(\n    { token },\n    {\n      enabled: !!token,\n      retry: 1,\n      onSuccess: (data) => {\n        setIsValidInvitation(true);\n      },\n      onError: (error) => {\n        console.error(\"Invalid invitation:\", error);\n        setIsValidInvitation(false);\n        setError(error.message);\n      }\n    }\n  );\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } = \n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle magic link sign-in\n  const handleMagicLinkSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim()) {\n      toast.error(\"Please enter your email address\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n\n      // Generate magic link that redirects back to this invitation page\n      const { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n\n      if (error) {\n        throw error;\n      }\n\n      // Show success message\n      toast.success(\"Check your email for a sign-in link!\");\n      setSentEmail(true);\n    } catch (err) {\n      console.error(\"Error sending magic link:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Failed to send sign-in link\",\n      );\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token || !user?.id) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error || isValidInvitation === false) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error || \"Invalid invitation link\"}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || authLoading || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating ? \"Validating your invitation...\"\n           : isAcceptingInvitation ? \"Accepting your invitation...\"\n           : authLoading ? \"Checking your account...\"\n           : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render magic link sign-in form if not signed in\n  if (!user) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n\n          {sentEmail ? (\n            <div className=\"text-center\">\n              <p className=\"mb-4 text-gray-700\">\n                Check your email for a sign-in link!\n              </p>\n              <p className=\"text-sm text-gray-500\">\n                After signing in, you'll be able to accept this invitation.\n              </p>\n            </div>\n          ) : (\n            <form onSubmit={handleMagicLinkSignIn} className=\"mt-4 space-y-4\">\n              <p className=\"mb-2 text-center text-gray-700\">\n                Sign in with your email to accept this invitation\n              </p>\n              <Input\n                type=\"email\"\n                placeholder=\"Your email address\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full\"\n              />\n              <NeoButton\n                type=\"submit\"\n                className=\"w-full\"\n                size=\"lg\"\n                disabled={processing}\n              >\n                {processing ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Sign In\"\n                )}\n              </NeoButton>\n            </form>\n          )}\n        </NeoCard>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\\nto get the current logged in user we can use profile.getCurrent\n  \n```ts dance-book-app/src/server/api/routers/profile.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport { createTRPCRouter, publicProcedure, authedProcedure } from \"../trpc\";\n\n// Validation schemas\nconst profileCreateSchema = z.object({\n  authId: z.string().uuid(),\n});\n\nconst profileUpdateSchema = z.object({\n  id: z.string().uuid(),\n  // Add any other fields you want to allow updating\n});\n\n// Finder schema with exclusive fields\nconst profileFindSchema = z\n  .object({\n    id: z.string().uuid().optional(),\n    authId: z.string().uuid().optional(),\n  })\n  .refine((data) => data.id ?? data.authId, {\n    message: \"Either id or authId must be provided\",\n  });\n\nexport const profileRouter = createTRPCRouter({\n  // Create a new profile\n  create: publicProcedure\n    .input(profileCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        return await ctx.db.profile.create({\n          data: {\n            authId: input.authId,\n          },\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Unique constraint failed\")\n        )\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"Profile with this auth ID already exists\",\n          });\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create profile\",\n          cause: error,\n        });\n      }\n    }),\n\n  // General purpose find profile\n  findUnique: publicProcedure\n    .input(profileFindSchema)\n    .query(async ({ ctx, input }) => {\n      const where = input.id ? { id: input.id } : { authId: input.authId! };\n\n      const profile = await ctx.db.profile.findUnique({\n        where,\n        include: {\n          studioMembers: {\n            include: {\n              studio: true,\n            },\n          },\n        },\n      });\n\n      if (!profile) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Profile not found\",\n        });\n      }\n\n      return profile;\n    }),\n\n  // Get current user's profile\n  getCurrent: authedProcedure.query(async ({ ctx }) => {\n    // The profile is already loaded in the auth middleware,\n    // so we can return it directly\n    if (!ctx.profile) {\n      throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Current profile not found\",\n      });\n    }\n\n    // Get a fresh copy with all relations\n    const profile = await ctx.db.profile.findUnique({\n      where: { id: ctx.profile.id },\n      include: {\n        studioMembers: {\n          include: {\n            studio: true,\n          },\n        },\n      },\n    });\n\n    if (!profile) {\n      throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Current profile not found\",\n      });\n    }\n\n    return profile;\n  }),\n\n  // Update a profile\n  update: authedProcedure\n    .input(profileUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      // Security check: ensure users can only update their own profile\n      if (ctx.profile?.id !== input.id) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You can only update your own profile\",\n        });\n      }\n\n      try {\n        return await ctx.db.profile.update({\n          where: { id: input.id },\n          data: {\n            // Add fields you want to allow updating here\n            updatedAt: new Date(),\n          },\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Profile not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update profile\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a profile with all related data\n  delete: authedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      // Security check: ensure users can only delete their own profile\n      if (ctx.profile?.id !== input.id) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You can only delete your own profile\",\n        });\n      }\n\n      // Use a transaction to ensure all related data is deleted properly\n      try {\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { profileId: input.id },\n          });\n\n          // Then delete the profile itself\n          return tx.profile.delete({\n            where: { id: input.id },\n          });\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Profile not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete profile\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all profiles (admin only - would need proper authorization)\n  list: publicProcedure\n    .input(\n      z.object({\n        page: z.number().min(1).default(1),\n        orderBy: z.enum([\"createdAt\", \"updatedAt\"]).default(\"createdAt\"),\n        order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n        // Can add filters here if needed\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order } = input;\n\n        const [profiles, meta] = await ctx.db.profile\n          .paginate({\n            orderBy: {\n              [orderBy]: order,\n            },\n          })\n          .withPages({\n            page,\n          });\n\n        return {\n          profiles,\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list profiles\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\ni think we dont need the use hooks \nYou're right! Let's simplify our approach by using the `profile.getCurrent` from the backend directly rather than creating a custom hook. I'll update the code for the invitation acceptance flow:\n\n1. First, let's fix the `invite-accept-content.tsx` component to properly handle the invitation:\n\n```tsx\n// src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [sentEmail, setSentEmail] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const { data: profile, isLoading: isLoadingProfile, isError, error: profileError } = \n    api.profile.getCurrent.useQuery(undefined, {\n      retry: 0, // Don't retry if the user is not authenticated\n      onError: () => {\n        // This is expected if the user is not logged in\n        console.log(\"User not authenticated yet\");\n      }\n    });\n\n  // Validate the invitation token\n  const { data: validationData, isLoading: isValidating } = api.studio.validateInvitation.useQuery(\n    { token },\n    {\n      enabled: !!token,\n      retry: 1,\n      onSuccess: (data) => {\n        // Invitation is valid\n      },\n      onError: (error) => {\n        console.error(\"Invalid invitation:\", error);\n        setError(error.message);\n      }\n    }\n  );\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } = \n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle magic link sign-in\n  const handleMagicLinkSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim()) {\n      toast.error(\"Please enter your email address\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n\n      // Generate magic link that redirects back to this invitation page\n      const { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n\n      if (error) {\n        throw error;\n      }\n\n      // Show success message\n      toast.success(\"Check your email for a sign-in link!\");\n      setSentEmail(true);\n    } catch (err) {\n      console.error(\"Error sending magic link:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Failed to send sign-in link\",\n      );\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">{error || \"Invalid invitation link\"}</p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating ? \"Validating your invitation...\"\n           : isAcceptingInvitation ? \"Accepting your invitation...\"\n           : isLoadingProfile ? \"Checking your account...\"\n           : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render magic link sign-in form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n\n          {sentEmail ? (\n            <div className=\"text-center\">\n              <p className=\"mb-4 text-gray-700\">\n                Check your email for a sign-in link!\n              </p>\n              <p className=\"text-sm text-gray-500\">\n                After signing in, you'll be able to accept this invitation.\n              </p>\n            </div>\n          ) : (\n            <form onSubmit={handleMagicLinkSignIn} className=\"mt-4 space-y-4\">\n              <p className=\"mb-2 text-center text-gray-700\">\n                Sign in with your email to accept this invitation\n              </p>\n              <Input\n                type=\"email\"\n                placeholder=\"Your email address\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full\"\n              />\n              <NeoButton\n                type=\"submit\"\n                className=\"w-full\"\n                size=\"lg\"\n                disabled={processing}\n              >\n                {processing ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Sign In\"\n                )}\n              </NeoButton>\n            </form>\n          )}\n        </NeoCard>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\n2. Now, let's update the `page.tsx` to properly handle the token from the URL:\n\n```tsx\n// src/app/(public)/invite-accept/page.tsx\nimport React, { Suspense } from \"react\";\nimport { api } from \"~/trpc/server\";\nimport { InviteAcceptContent } from \"./invite-accept-content\";\nimport { InviteAcceptSkeleton } from \"./invite-accept-skeleton\";\nimport { MapPin, Building2 } from \"lucide-react\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport Image from \"next/image\";\nimport { notFound } from \"next/navigation\";\n\ninterface InviteAcceptPageProps {\n  searchParams: {\n    studioId?: string;\n    role?: string;\n    token?: string;\n  };\n}\n\nexport default async function InviteAcceptPage({ searchParams }: InviteAcceptPageProps) {\n  const { studioId, role, token } = searchParams;\n\n  // Return early if no studioId, role or token\n  if (!studioId || !role || !token) {\n    return notFound();\n  }\n\n  try {\n    // Fetch studio data on the server\n    const studioData = await api.studio.findUnique({ id: studioId });\n\n    if (!studioData) {\n      return notFound();\n    }\n\n    return (\n      <div className=\"flex min-h-screen flex-col items-center justify-center p-4 sm:p-8\">\n        <NeoCard className=\"w-full max-w-md overflow-hidden p-0\">\n          {/* Studio Logo/Banner */}\n          <div className=\"neo-border relative h-40 w-full overflow-hidden rounded-xl border-b-4 border-black\">\n            {studioData.logo ? (\n              <Image\n                src={studioData.logo}\n                alt={studioData.name}\n                fill\n                sizes=\"(max-width: 768px) 100vw, 400px\"\n                className=\"object-cover\"\n                unoptimized\n              />\n            ) : (\n              <div className=\"flex h-full w-full items-center justify-center bg-muted\">\n                <Building2 className=\"h-16 w-16 text-muted-foreground\" />\n              </div>\n            )}\n          </div>\n\n          <div className=\"p-6\">\n            {/* Studio Info */}\n            <div className=\"mb-8\">\n              <h1 className=\"mb-3 text-center text-2xl font-black\">\n                {studioData.name || \"Studio\"}\n              </h1>\n\n              <div className=\"mb-4 flex items-start gap-2\">\n                <MapPin className=\"mt-1 h-5 w-5 flex-shrink-0 text-primary\" />\n                <p className=\"text-md\">\n                  {studioData.address}, {studioData.city},{\" \"}\n                  {studioData.stateName || studioData.state}\n                  {studioData.postalCode && `, ${studioData.postalCode}`}\n                </p>\n              </div>\n\n              {studioData.description && (\n                <p className=\"mt-3 text-gray-700\">{studioData.description}</p>\n              )}\n            </div>\n\n            <Suspense fallback={<InviteAcceptSkeleton />}>\n              {/* Client component handles authentication */}\n              <InviteAcceptContent\n                token={token}\n                studioId={studioId}\n                role={role}\n                studioName={studioData.name}\n              />\n            </Suspense>\n          </div>\n        </NeoCard>\n      </div>\n    );\n  } catch (error) {\n    console.error(\"Error loading studio:\", error);\n    return notFound();\n  }\n}\n```\n\n3. Now we need to update the `studio.ts` router to have the correct handlers for validating and accepting invitations:\n\n```typescript\n// Add these procedures to the studioRouter in src/server/api/routers/studio.ts\n\n// Validate invitation token\nvalidateInvitation: publicProcedure\n  .input(\n    z.object({\n      token: z.string(),\n    }),\n  )\n  .query(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      if (!tokenData?.studioId || !tokenData?.id || !tokenData?.email || tokenData.type !== \"studio-invitation\") {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findFirst({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n          status: \"PENDING\",\n        },\n        include: {\n          studio: true,\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      return {\n        valid: true,\n        invitation: {\n          ...invitation,\n          studio: enhanceStudioWithLocationNames(invitation.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Validate invitation error:\", error);\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation link\",\n        cause: error,\n      });\n    }\n  }),\n\n// Accept invitation with token (requires authentication)\nacceptInvitationWithLink: authedProcedure\n  .input(\n    z.object({\n      token: z.string(),\n    }),\n  )\n  .mutation(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      if (!tokenData?.id || !tokenData?.studioId || !tokenData?.email || tokenData.type !== \"studio-invitation\") {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          status: \"PENDING\",\n        },\n        include: {\n          studio: true,\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message\n                  \n```tsx dance-book-app/src/app/(private)/profile/choreographers-form.tsx\n\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { z } from \"zod\";\nimport { Loader2, Mail, Plus, Sparkles, Copy, CheckCircle } from \"lucide-react\";\nimport { api } from \"~/trpc/react\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTrigger,\n} from \"~/components/ui/dialog\";\nimport {\n  Drawer,\n  DrawerContent,\n  DrawerTrigger,\n  DrawerHeader,\n  DrawerTitle,\n} from \"~/components/ui/drawer\";\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"~/components/ui/form\";\nimport { Input } from \"~/components/ui/input\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { Card } from \"~/components/ui/card\";\nimport { useIsMobile } from \"~/hooks/use-mobile\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { DialogTitle } from \"@radix-ui/react-dialog\";\n\n// Simplified schema - only email, no role needed\nconst choreographerInviteSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n});\n\ntype ChoreographerInviteValues = z.infer<typeof choreographerInviteSchema>;\n\nconst defaultValues: ChoreographerInviteValues = {\n  email: \"\",\n};\n\ninterface ChoreographerInviteDialogProps {\n  studioId: string;\n  studioSlug: string;\n  buttonLabel?: string;\n  buttonClassName?: string;\n  variant?: \"default\" | \"outline\" | \"secondary\" | \"ghost\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n}\n\nexport function ChoreographerInviteDialog({\n  studioId,\n  studioSlug,\n  buttonLabel = \"Add Choreographer\",\n  buttonClassName = \"\",\n  variant = \"default\",\n  size = \"default\",\n}: ChoreographerInviteDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [formSubmitted, setFormSubmitted] = useState(false);\n  const [inviteLink, setInviteLink] = useState<string | null>(null);\n  const [copied, setCopied] = useState(false);\n  const isMobile = useIsMobile();\n  const isDesktop = !isMobile;\n\n  const form = useForm<ChoreographerInviteValues>({\n    resolver: zodResolver(choreographerInviteSchema),\n    defaultValues,\n    mode: \"onChange\",\n  });\n\n  // Use the inviteChoreographer mutation\n  const { mutate: inviteChoreographer, isPending } =\n    api.studio.inviteChoreographer.useMutation({\n      onSuccess: (data) => {\n        setFormSubmitted(true);\n\n        // Store the invitation link if available\n        if (data.actionLink) {\n          setInviteLink(data.actionLink);\n        }\n\n        if (data.status === \"invited\") {\n          toast.success(`Invitation sent to ${data.email}!`);\n        } else if (data.status === \"added\") {\n          toast.success(`${data.email} was added to your studio!`);\n        } else if (data.status === \"already_member\") {\n          toast.info(`${data.email} is already a member of your studio.`);\n        } else if (data.status === \"role_updated\") {\n          toast.success(`${data.email}'s role was updated.`);\n        } else if (data.status === \"already_invited\") {\n          toast.info(`${data.email} has already been invited.`);\n        }\n      },\n      onError: (error) => {\n        toast.error(`Failed to send invitation: ${error.message}`);\n      },\n    });\n\n  const onSubmit = async (values: ChoreographerInviteValues) => {\n    inviteChoreographer({\n      studioId,\n      email: values.email,\n      role: \"CHOREOGRAPHER\", // Hardcoded role\n    });\n  };\n\n  const handleNewInvite = () => {\n    setFormSubmitted(false);\n    setInviteLink(null);\n    setCopied(false);\n    form.reset(defaultValues);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    // Reset form after a short delay to avoid visual glitches\n    setTimeout(() => {\n      setFormSubmitted(false);\n      setInviteLink(null);\n      setCopied(false);\n      form.reset(defaultValues);\n    }, 200);\n  };\n\n  const copyToClipboard = async () => {\n    if (!inviteLink) return;\n\n    try {\n      await navigator.clipboard.writeText(inviteLink);\n      setCopied(true);\n      toast.success(\"Link copied to clipboard!\");\n\n      // Reset copied state after 3 seconds\n      setTimeout(() => setCopied(false), 3000);\n    } catch (err) {\n      toast.error(\"Failed to copy link to clipboard\");\n    }\n  };\n\n  // Memoize the TriggerButton to prevent unnecessary re-renders\n  const TriggerButton = useMemo(\n    () => (\n      <NeoButton variant={variant} size={size} className={buttonClassName}>\n        <Plus className=\"mr-2 h-4 w-4\" />\n        {buttonLabel}\n      </NeoButton>\n    ),\n    [variant, size, buttonClassName, buttonLabel],\n  );\n\n  // Render the success card with invitation link\n  const SuccessCard = () => (\n    <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n      <div className=\"neo-border mb-5 flex h-14 w-14 items-center justify-center rounded-full bg-green-200 text-black shadow-neo-sm\">\n        <Mail className=\"h-7 w-7\" strokeWidth={2} />\n      </div>\n      <h2 className=\"mb-2 text-xl font-bold\">Invitation Sent!</h2>\n      <p className=\"mb-5 text-sm text-muted-foreground\">\n        The choreographer will receive an email with instructions to join your\n        studio.\n      </p>\n\n      {/* Display invitation link if available */}\n      {inviteLink && (\n        <div className=\"mb-5 w-full\">\n          <p className=\"mb-2 text-sm font-medium\">Invitation Link:</p>\n          <div className=\"flex flex-col gap-2\">\n            <div className=\"relative\">\n              <div className=\"neo-border break-all rounded-md bg-muted p-3 pr-12 text-left text-xs shadow-neo-sm\">\n                {inviteLink}\n              </div>\n              <button\n                onClick={copyToClipboard}\n                className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-md border border-black bg-white p-1 active:shadow-none\"\n                aria-label=\"Copy link\"\n              >\n                {copied ? (\n                  <CheckCircle\n                    className=\"h-4 w-4 text-green-500\"\n                    strokeWidth={2.5}\n                  />\n                ) : (\n                  <Copy className=\"h-4 w-4\" strokeWidth={2.5} />\n                )}\n              </button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              Copy this link to manually share with the choreographer.\n            </p>\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col gap-3 sm:flex-row\">\n        <NeoButton onClick={handleNewInvite} variant=\"secondary\" size=\"sm\">\n          Send Another Invitation\n        </NeoButton>\n        <NeoButton onClick={handleClose} size=\"sm\">\n          Close\n        </NeoButton>\n      </div>\n    </div>\n  );\n\n  // Render the invite form\n  const InviteForm = () => (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-5\">\n        {/* Invitation Section Header */}\n        <div className=\"flex items-center gap-3\">\n          <div className=\"neo-border flex h-9 w-9 items-center justify-center rounded-full bg-blue-200 text-black shadow-neo-sm\">\n            <Mail className=\"h-4 w-4\" strokeWidth={2.5} />\n          </div>\n          <h3 className=\"text-base font-bold\">Invite a Choreographer</h3>\n        </div>\n\n        {/* Explanation Card */}\n        <NeoCard>\n          <p className=\"text-xs\">\n            Send an invitation to a choreographer to join your studio. They will\n            receive an email with a link to accept the invitation.\n          </p>\n        </NeoCard>\n\n        {/* Email Field */}\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"font-bold\">\n                Email Address <span className=\"text-red-500\">*</span>\n              </FormLabel>\n              <FormControl>\n                <Input\n                  type=\"email\"\n                  placeholder=\"choreographer@example.com\"\n                  {...field}\n                  className=\"neo-border bg-white p-3 shadow-neo-sm transition-all focus:translate-x-0.5 focus:translate-y-0.5 focus:shadow-none dark:bg-black\"\n                />\n              </FormControl>\n              <FormDescription className=\"text-xs\">\n                Enter the email address of the choreographer you want to invite.\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        {/* Form Actions */}\n        <div className=\"mt-6 flex justify-end gap-3\">\n          <NeoButton type=\"button\" variant=\"secondary\" onClick={handleClose}>\n            Cancel\n          </NeoButton>\n          <NeoButton type=\"submit\" disabled={isPending}>\n            {isPending ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Sending...\n              </>\n            ) : (\n              <>\n                <Sparkles className=\"mr-2 h-4 w-4\" strokeWidth={2.5} />\n                Send Invitation\n              </>\n            )}\n          </NeoButton>\n        </div>\n      </form>\n    </Form>\n  );\n\n  // Render either Dialog or Drawer based on screen size\n  if (isDesktop) {\n    return (\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogTrigger asChild>{TriggerButton}</DialogTrigger>\n        <DialogContent\n          className=\"sm:max-w-[500px]\"\n          onInteractOutside={(e) => e.preventDefault()}\n          onEscapeKeyDown={(e) => {\n            e.stopPropagation();\n            handleClose();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle></DialogTitle>\n          </DialogHeader>\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  return (\n    <Drawer open={open} onOpenChange={setOpen}>\n      <DrawerTrigger asChild>{TriggerButton}</DrawerTrigger>\n      <DrawerContent\n        onInteractOutside={(e) => e.preventDefault()}\n        onEscapeKeyDown={(e) => {\n          e.stopPropagation();\n          handleClose();\n        }}\n      >\n        <DrawerHeader>\n          <DrawerTitle></DrawerTitle>\n        </DrawerHeader>\n        <div className=\"px-4 pb-6\">\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </div>\n      </DrawerContent>\n    </Drawer>\n  );\n}\n```\n\n        can  you please update the code\nAlright, I'll update the code to complete the invite-accept functionality. The issue is that we need to properly handle the token validation and acceptance flow. Here's the updated code:\n\nFirst, let's update the studio router with the correct methods for token-based invitation:\n\n```typescript\n// Add to the studioRouter in studio.ts - updated token validation method\nvalidateInvitation: publicProcedure\n  .input(\n    z.object({\n      token: z.string(),\n    })\n  )\n  .query(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      if (!tokenData?.id || !tokenData?.studioId || tokenData.type !== \"studio-invitation\") {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findFirst({\n        where: {\n          id: tokenData.id,\n          studioId: tokenData.studioId,\n          status: \"PENDING\",\n        },\n        include: {\n          studio: true,\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      return {\n        valid: true,\n        invitation: {\n          ...invitation,\n          studio: enhanceStudioWithLocationNames(invitation.studio),\n        },\n      };\n    } catch (error) {\n      if (error instanceof TRPCError) {\n        throw error;\n      }\n\n      console.error(\"Validate invitation error:\", error);\n      throw new TRPCError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid invitation link\",\n        cause: error,\n      });\n    }\n  }),\n\n// Accept invitation with token (requires authentication)\nacceptInvitationWithLink: authedProcedure\n  .input(\n    z.object({\n      token: z.string(),\n    })\n  )\n  .mutation(async ({ ctx, input }) => {\n    try {\n      // Verify JWT token\n      const tokenData = await verifyJWT(input.token);\n\n      if (\n        !tokenData?.id ||\n        !tokenData?.studioId ||\n        tokenData.type !== \"studio-invitation\"\n      ) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n        });\n      }\n\n      // Find the invitation\n      const invitation = await ctx.db.studioInvitation.findUnique({\n        where: {\n          id: tokenData.id,\n          status: \"PENDING\",\n        },\n      });\n\n      if (!invitation) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Invitation not found or already used\",\n        });\n      }\n\n      // Check if expired\n      if (invitation.expiresAt < new Date()) {\n        await ctx.db.studioInvitation.update({\n          where: { id: invitation.id },\n          data: { status: \"EXPIRED\" },\n        });\n\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invitation has expired\",\n        });\n      }\n\n      // Check if user is already a member\n      const existingMembership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            \n  \n```ts dance-book-app/src/server/api/routers/studio.ts\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  authedProcedure,\n  adminProcedure,\n  ownerProcedure,\n  staffProcedure,\n} from \"../trpc\";\nimport { type Prisma, type Studio } from \"@prisma/client\";\nimport { Country, State } from \"country-state-city\";\nimport { createClient } from \"~/lib/supabase/server\";\nimport { createJWT, verifyJWT } from \"~/lib/jwt\";\n\n// Validation schemas\nconst studioCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  slug: z.string().min(3).max(100),\n  description: z.string().optional(),\n  address: z.string().min(5).max(255),\n  city: z.string().min(2).max(100),\n  state: z.string().min(2).max(100),\n  postalCode: z.string().min(3).max(20),\n  country: z.string().length(2),\n  logo: z.string().url().optional(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n});\n\nconst studioUpdateSchema = z.object({\n  studioId: z.string().uuid(), // Changed from 'id' to 'studioId' for consistency with middleware\n  name: z.string().min(2).max(100).optional(),\n  slug: z.string().min(3).max(100).optional(),\n  description: z.string().optional().nullable(),\n  address: z.string().min(5).max(255).optional(),\n  city: z.string().min(2).max(100).optional(),\n  state: z.string().min(2).max(100).optional(),\n  postalCode: z.string().min(3).max(20).optional(),\n  country: z.string().length(2).optional(),\n  logo: z.string().url().optional().nullable(),\n  openingHours: z.record(z.string(), z.array(z.string())).optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Finder schema with exclusive fields, similar to profile router\nconst studioFindSchema = z.object({\n  id: z.string().uuid().optional(),\n  slug: z.string().min(3).max(100).optional(),\n});\n\nconst studioQuerySchema = z.object({\n  page: z.number().min(1).default(1),\n  orderBy: z\n    .enum([\"name\", \"city\", \"createdAt\", \"updatedAt\"])\n    .default(\"createdAt\"),\n  order: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n  search: z.string().optional(),\n  city: z.string().optional(),\n  country: z.string().optional(),\n  isActive: z.boolean().optional(),\n});\n\n// Helper function to enhance studio data with full country and state names\nconst enhanceStudioWithLocationNames = <T extends Studio>(\n  studio: T,\n): (T & { countryName?: string; stateName?: string }) | null => {\n  if (!studio) return null;\n\n  const enhancedStudio = { ...studio } as T & {\n    countryName?: string;\n    stateName?: string;\n  };\n\n  if (studio.country) {\n    const countryData = Country.getCountryByCode(studio.country);\n    enhancedStudio.countryName = countryData?.name;\n  }\n\n  if (studio.state && studio.country) {\n    const stateData = State.getStateByCodeAndCountry(\n      studio.state,\n      studio.country,\n    );\n    enhancedStudio.stateName = stateData?.name;\n  }\n\n  return enhancedStudio;\n};\n\n// Helper function to enhance studio arrays\nconst enhanceStudiosWithLocationNames = <T extends Studio>(\n  studios: T[],\n): Array<(T & { countryName?: string; stateName?: string }) | null> => {\n  return studios.map(enhanceStudioWithLocationNames);\n};\n\nexport type EnhancedStudios = ReturnType<\n  typeof enhanceStudiosWithLocationNames\n>;\n\nexport const studioRouter = createTRPCRouter({\n  // Create a new studio\n  create: authedProcedure\n    .input(studioCreateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to create the studio and add the creator as owner\n        return await ctx.db.$transaction(async (tx) => {\n          // Create the studio first\n          const studio = await tx.studio.create({\n            data: {\n              name: input.name,\n              slug: input.slug,\n              description: input.description,\n              address: input.address,\n              city: input.city,\n              state: input.state,\n              postalCode: input.postalCode,\n              country: input.country,\n              logo: input.logo,\n              openingHours: input.openingHours as object,\n            },\n          });\n\n          // Add the creator as an owner\n          await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: studio.id,\n              role: \"OWNER\",\n            },\n          });\n\n          return enhanceStudioWithLocationNames(studio);\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to create studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Find a unique studio, similar to profile router\n  findUnique: publicProcedure\n    .input(studioFindSchema)\n    .query(async ({ ctx, input }) => {\n      const studio = await ctx.db.studio.findUnique({\n        where: { id: input.id, slug: input.slug },\n        include: {\n          members: {\n            include: {\n              profile: true,\n            },\n          },\n        },\n      });\n\n      if (!studio) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Studio not found\",\n        });\n      }\n\n      return enhanceStudioWithLocationNames(studio);\n    }),\n\n  // Update a studio - using adminProcedure which already checks for OWNER or ADMIN role\n  update: adminProcedure\n    .input(studioUpdateSchema)\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Extract the studioId and remove it from the data to be updated\n        const { studioId, ...updateData } = input;\n\n        const updatedStudio = await ctx.db.studio.update({\n          where: { id: studioId },\n          data: {\n            ...updateData,\n            openingHours: updateData.openingHours as object | undefined,\n            updatedAt: new Date(),\n          },\n        });\n\n        return enhanceStudioWithLocationNames(updatedStudio);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to update not found\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Delete a studio - using ownerProcedure which already checks for OWNER role\n  delete: ownerProcedure\n    .input(z.object({ studioId: z.string().uuid() }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Use a transaction to delete all related data\n        return await ctx.db.$transaction(async (tx) => {\n          // First delete all studio memberships\n          await tx.studioMember.deleteMany({\n            where: { studioId: input.studioId },\n          });\n\n          // Then delete the studio itself\n          const deletedStudio = await tx.studio.delete({\n            where: { id: input.studioId },\n          });\n\n          return enhanceStudioWithLocationNames(deletedStudio);\n        });\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes(\"Record to delete does not exist\")\n        ) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Studio not found\",\n          });\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // List all studios with filtering, sorting, and pagination\n  list: publicProcedure\n    .input(studioQuerySchema)\n    .query(async ({ ctx, input }) => {\n      try {\n        const { page, orderBy, order, search, city, country, isActive } = input;\n\n        // Build query options for pagination\n        const paginationOptions: Prisma.StudioFindManyArgs = {\n          orderBy: {\n            [orderBy]: order,\n          },\n        };\n\n        // Add filtering conditions\n        const whereConditions: Prisma.StudioWhereInput = {};\n\n        if (search) {\n          whereConditions.OR = [\n            {\n              name: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              description: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n            {\n              address: {\n                contains: search,\n                mode: \"insensitive\" as Prisma.QueryMode,\n              },\n            },\n          ];\n        }\n\n        if (city) {\n          whereConditions.city = {\n            contains: city,\n            mode: \"insensitive\" as Prisma.QueryMode,\n          };\n        }\n\n        if (country) {\n          whereConditions.country = country;\n        }\n\n        if (isActive !== undefined) {\n          whereConditions.isActive = isActive;\n        }\n\n        if (Object.keys(whereConditions).length > 0) {\n          paginationOptions.where = whereConditions;\n        }\n\n        // Execute pagination query with extension\n        const [studios, meta] = await ctx.db.studio\n          .paginate(paginationOptions)\n          .withPages({\n            page,\n          });\n\n        return {\n          studios: enhanceStudiosWithLocationNames(studios),\n          meta,\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to list studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Get studios managed by the current user\n  myStudios: authedProcedure\n    .input(\n      z\n        .object({\n          role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n        })\n        .optional(),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        const whereConditions: Prisma.StudioMemberWhereInput = {\n          profileId: ctx.profile.id,\n        };\n\n        if (input?.role) {\n          whereConditions.role = input.role;\n        }\n\n        const memberships = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            studio: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n\n        // Enhance studio data in each membership\n        return memberships.map((membership) => ({\n          ...membership,\n          studio: enhanceStudioWithLocationNames(membership.studio),\n        }));\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve your studios\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Add a member to a studio - using adminProcedure which checks for OWNER or ADMIN role\n  addMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by adminProcedure\n        profileId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).default(\"STAFF\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Check if the member already exists\n        const existingMember = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: input.profileId,\n              studioId: input.studioId,\n            },\n          },\n        });\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This person is already a member of this studio\",\n          });\n        }\n\n        // Create the member\n        const member = await ctx.db.studioMember.create({\n          data: {\n            profileId: input.profileId,\n            studioId: input.studioId,\n            role: input.role,\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...member,\n          studio: enhanceStudioWithLocationNames(member.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add member to studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Custom procedure for updating members - we need specific logic for role restrictions\n  updateMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n        role: z.enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to update\n      const memberToUpdate = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToUpdate) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToUpdate.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if trying to update someone with a higher role\n      if (\n        memberToUpdate.role === \"OWNER\" ||\n        (ctx.studioMembership.role === \"ADMIN\" &&\n          memberToUpdate.role === \"ADMIN\")\n      ) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"You cannot modify members with equal or higher roles\",\n        });\n      }\n\n      try {\n        // Update the member\n        const updatedMember = await ctx.db.studioMember.update({\n          where: { id: input.memberId },\n          data: {\n            role: input.role,\n            updatedAt: new Date(),\n          },\n          include: {\n            profile: true,\n            studio: true,\n          },\n        });\n\n        // Enhance studio data in the response\n        return {\n          ...updatedMember,\n          studio: enhanceStudioWithLocationNames(updatedMember.studio),\n        };\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Rest of the code remains unchanged...\n  removeMember: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Required by adminProcedure\n        memberId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Get the member to remove\n      const memberToRemove = await ctx.db.studioMember.findUnique({\n        where: { id: input.memberId },\n      });\n\n      if (!memberToRemove) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Member not found\",\n        });\n      }\n\n      // Verify this member belongs to the studio in the input\n      if (memberToRemove.studioId !== input.studioId) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Member does not belong to specified studio\",\n        });\n      }\n\n      // Check if attempting to remove an owner (only the owner themselves can remove their ownership)\n      const isSelf = memberToRemove.profileId === ctx?.profile?.id;\n\n      if (memberToRemove.role === \"OWNER\" && !isSelf) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"Studio owners cannot be removed by others\",\n        });\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: input.memberId },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to remove studio member\",\n          cause: error,\n        });\n      }\n    }),\n\n  leaveStudio: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      // Find the user's membership\n      const membership = await ctx.db.studioMember.findUnique({\n        where: {\n          profileId_studioId: {\n            profileId: ctx.profile.id,\n            studioId: input.studioId,\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"You are not a member of this studio\",\n        });\n      }\n\n      // Check if they're the sole owner\n      if (membership.role === \"OWNER\") {\n        const ownersCount = await ctx.db.studioMember.count({\n          where: {\n            studioId: input.studioId,\n            role: \"OWNER\",\n          },\n        });\n\n        if (ownersCount <= 1) {\n          throw new TRPCError({\n            code: \"FORBIDDEN\",\n            message:\n              \"You cannot leave as you are the only owner. Transfer ownership first or delete the studio.\",\n          });\n        }\n      }\n\n      try {\n        return await ctx.db.studioMember.delete({\n          where: { id: membership.id },\n        });\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to leave studio\",\n          cause: error,\n        });\n      }\n    }),\n\n  getMembers: authedProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(), // Already required by staffProcedure\n        role: z.enum([\"OWNER\", \"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"]).optional(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      const whereConditions: Prisma.StudioMemberWhereInput = {\n        studioId: input.studioId,\n      };\n\n      if (input.role) {\n        whereConditions.role = input.role;\n      }\n\n      try {\n        const members = await ctx.db.studioMember.findMany({\n          where: whereConditions,\n          include: {\n            profile: true,\n          },\n          orderBy: [{ role: \"asc\" }, { createdAt: \"asc\" }],\n        });\n\n        return members;\n      } catch (error) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to retrieve studio members\",\n          cause: error,\n        });\n      }\n    }),\n\n  inviteChoreographerWithLink: adminProcedure\n    .input(\n      z.object({\n        studioId: z.string().uuid(),\n        email: z.string().email(),\n        role: z\n          .enum([\"ADMIN\", \"CHOREOGRAPHER\", \"STAFF\"])\n          .default(\"CHOREOGRAPHER\"),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Create the Supabase admin client\n        const supabase = await createClient({ isAdmin: true });\n\n        // Check if the email belongs to a registered user\n        const { data } = await supabase.auth.admin.listUsers();\n\n        // Filter users manually to find by email\n        const matchingUsers =\n          data?.users?.filter(\n            (user) => user.email?.toLowerCase() === input.email.toLowerCase(),\n          ) || [];\n\n        // Get user IDs if they exist\n        const userIds = matchingUsers.map((user) => user.id);\n\n        // Check for existing member with this email at this studio\n        const existingMember =\n          userIds.length > 0\n            ? await ctx.db.studioMember.findFirst({\n                where: {\n                  studio: {\n                    id: input.studioId,\n                  },\n                  profile: {\n                    authId: {\n                      in: userIds,\n                    },\n                  },\n                },\n              })\n            : null;\n\n        if (existingMember) {\n          throw new TRPCError({\n            code: \"CONFLICT\",\n            message: \"This user is already a member of this studio\",\n          });\n        }\n\n        // Check for existing pending invitation\n        const existingInvitation = await ctx.db.studioInvitation.findFirst({\n          where: {\n            email: input.email,\n            studioId: input.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (existingInvitation) {\n          // Create a secure JWT token for the existing invitation\n          const token = await createJWT({\n            id: existingInvitation.id,\n            email: input.email,\n            studioId: input.studioId,\n            role: existingInvitation.role,\n            type: \"studio-invitation\",\n          });\n\n          return {\n            status: \"already_invited\",\n            invitation: existingInvitation,\n            inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${existingInvitation.role}&token=${token}`,\n          };\n        }\n\n        // Store the invitation in the database with expiration (30 days)\n        const expirationDate = new Date();\n        expirationDate.setDate(expirationDate.getDate() + 30);\n\n        // ctx.profile is guaranteed to exist in adminProcedure\n        const invitation = await ctx.db.studioInvitation.create({\n          data: {\n            email: input.email,\n            studioId: input.studioId,\n            role: input.role,\n            invitedById: ctx?.profile?.id ?? \"\", // adminProcedure ensures this exists\n            expiresAt: expirationDate,\n            status: \"PENDING\",\n          },\n        });\n\n        // Create a secure JWT token using the jwt.ts utilities\n        const token = await createJWT({\n          id: invitation.id,\n          email: input.email,\n          studioId: input.studioId,\n          role: input.role,\n          type: \"studio-invitation\",\n        });\n\n        return {\n          status: \"invited\",\n          invitation,\n          inviteLink: `${process.env.NEXT_PUBLIC_APP_URL}/invite-accept?studioId=${input.studioId}&role=${input.role}&token=${token}`,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Invite choreographer error:\", error);\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to generate invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  validateInvitation: publicProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .query(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n          include: {\n            studio: true,\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        return {\n          valid: true,\n          invitation: {\n            ...invitation,\n            studio: enhanceStudioWithLocationNames(invitation.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        console.error(\"Validate invitation error:\", error);\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid invitation link\",\n          cause: error,\n        });\n      }\n    }),\n\n  // Update acceptInvitationWithLink procedure\n  acceptInvitationWithLink: authedProcedure\n    .input(\n      z.object({\n        token: z.string(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Verify JWT token\n        const tokenData = await verifyJWT(input.token);\n\n        if (\n          !tokenData?.id ||\n          !tokenData?.studioId ||\n          tokenData.type !== \"studio-invitation\"\n        ) {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid invitation link\",\n          });\n        }\n\n        // Find the invitation\n        const invitation = await ctx.db.studioInvitation.findUnique({\n          where: {\n            id: tokenData.id as string,\n            studioId: tokenData.studioId,\n            status: \"PENDING\",\n          },\n        });\n\n        if (!invitation) {\n          throw new TRPCError({\n            code: \"NOT_FOUND\",\n            message: \"Invitation not found or already used\",\n          });\n        }\n\n        // Check if expired\n        if (invitation.expiresAt < new Date()) {\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"EXPIRED\" },\n          });\n\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Invitation has expired\",\n          });\n        }\n\n        // Check if user is already a member\n        const existingMembership = await ctx.db.studioMember.findUnique({\n          where: {\n            profileId_studioId: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n            },\n          },\n        });\n\n        if (existingMembership) {\n          // Update invitation status\n          await ctx.db.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return {\n            status: \"already_member\",\n            membership: existingMembership,\n          };\n        }\n\n        // Create new membership in a transaction\n        const result = await ctx.db.$transaction(async (tx) => {\n          // Add user to studio\n          const membership = await tx.studioMember.create({\n            data: {\n              profileId: ctx.profile.id,\n              studioId: invitation.studioId,\n              role: invitation.role,\n            },\n            include: {\n              studio: true,\n              profile: true,\n            },\n          });\n\n          // Update invitation status\n          await tx.studioInvitation.update({\n            where: { id: invitation.id },\n            data: { status: \"ACCEPTED\" },\n          });\n\n          return membership;\n        });\n\n        return {\n          status: \"accepted\",\n          membership: {\n            ...result,\n            studio: enhanceStudioWithLocationNames(result.studio),\n          },\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to accept invitation\",\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\nthe studio.ts  is now updated i think we can skip on returning the code here \nyour task now is to update the choreographer-form.tsx file\n```tsx dance-book-app/src/app/(private)/profile/choreographers-form.tsx\n\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { z } from \"zod\";\nimport { Loader2, Mail, Plus, Sparkles, Copy, CheckCircle } from \"lucide-react\";\nimport { api } from \"~/trpc/react\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTrigger,\n} from \"~/components/ui/dialog\";\nimport {\n  Drawer,\n  DrawerContent,\n  DrawerTrigger,\n  DrawerHeader,\n  DrawerTitle,\n} from \"~/components/ui/drawer\";\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"~/components/ui/form\";\nimport { Input } from \"~/components/ui/input\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { Card } from \"~/components/ui/card\";\nimport { useIsMobile } from \"~/hooks/use-mobile\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { DialogTitle } from \"@radix-ui/react-dialog\";\n\n// Simplified schema - only email, no role needed\nconst choreographerInviteSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n});\n\ntype ChoreographerInviteValues = z.infer<typeof choreographerInviteSchema>;\n\nconst defaultValues: ChoreographerInviteValues = {\n  email: \"\",\n};\n\ninterface ChoreographerInviteDialogProps {\n  studioId: string;\n  studioSlug: string;\n  buttonLabel?: string;\n  buttonClassName?: string;\n  variant?: \"default\" | \"outline\" | \"secondary\" | \"ghost\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n}\n\nexport function ChoreographerInviteDialog({\n  studioId,\n  studioSlug,\n  buttonLabel = \"Add Choreographer\",\n  buttonClassName = \"\",\n  variant = \"default\",\n  size = \"default\",\n}: ChoreographerInviteDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [formSubmitted, setFormSubmitted] = useState(false);\n  const [inviteLink, setInviteLink] = useState<string | null>(null);\n  const [copied, setCopied] = useState(false);\n  const isMobile = useIsMobile();\n  const isDesktop = !isMobile;\n\n  const form = useForm<ChoreographerInviteValues>({\n    resolver: zodResolver(choreographerInviteSchema),\n    defaultValues,\n    mode: \"onChange\",\n  });\n\n  // Use the inviteChoreographer mutation\n  const { mutate: inviteChoreographer, isPending } =\n    api.studio.inviteChoreographer.useMutation({\n      onSuccess: (data) => {\n        setFormSubmitted(true);\n\n        // Store the invitation link if available\n        if (data.actionLink) {\n          setInviteLink(data.actionLink);\n        }\n\n        if (data.status === \"invited\") {\n          toast.success(`Invitation sent to ${data.email}!`);\n        } else if (data.status === \"added\") {\n          toast.success(`${data.email} was added to your studio!`);\n        } else if (data.status === \"already_member\") {\n          toast.info(`${data.email} is already a member of your studio.`);\n        } else if (data.status === \"role_updated\") {\n          toast.success(`${data.email}'s role was updated.`);\n        } else if (data.status === \"already_invited\") {\n          toast.info(`${data.email} has already been invited.`);\n        }\n      },\n      onError: (error) => {\n        toast.error(`Failed to send invitation: ${error.message}`);\n      },\n    });\n\n  const onSubmit = async (values: ChoreographerInviteValues) => {\n    inviteChoreographer({\n      studioId,\n      email: values.email,\n      role: \"CHOREOGRAPHER\", // Hardcoded role\n    });\n  };\n\n  const handleNewInvite = () => {\n    setFormSubmitted(false);\n    setInviteLink(null);\n    setCopied(false);\n    form.reset(defaultValues);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    // Reset form after a short delay to avoid visual glitches\n    setTimeout(() => {\n      setFormSubmitted(false);\n      setInviteLink(null);\n      setCopied(false);\n      form.reset(defaultValues);\n    }, 200);\n  };\n\n  const copyToClipboard = async () => {\n    if (!inviteLink) return;\n\n    try {\n      await navigator.clipboard.writeText(inviteLink);\n      setCopied(true);\n      toast.success(\"Link copied to clipboard!\");\n\n      // Reset copied state after 3 seconds\n      setTimeout(() => setCopied(false), 3000);\n    } catch (err) {\n      toast.error(\"Failed to copy link to clipboard\");\n    }\n  };\n\n  // Memoize the TriggerButton to prevent unnecessary re-renders\n  const TriggerButton = useMemo(\n    () => (\n      <NeoButton variant={variant} size={size} className={buttonClassName}>\n        <Plus className=\"mr-2 h-4 w-4\" />\n        {buttonLabel}\n      </NeoButton>\n    ),\n    [variant, size, buttonClassName, buttonLabel],\n  );\n\n  // Render the success card with invitation link\n  const SuccessCard = () => (\n    <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n      <div className=\"neo-border mb-5 flex h-14 w-14 items-center justify-center rounded-full bg-green-200 text-black shadow-neo-sm\">\n        <Mail className=\"h-7 w-7\" strokeWidth={2} />\n      </div>\n      <h2 className=\"mb-2 text-xl font-bold\">Invitation Sent!</h2>\n      <p className=\"mb-5 text-sm text-muted-foreground\">\n        The choreographer will receive an email with instructions to join your\n        studio.\n      </p>\n\n      {/* Display invitation link if available */}\n      {inviteLink && (\n        <div className=\"mb-5 w-full\">\n          <p className=\"mb-2 text-sm font-medium\">Invitation Link:</p>\n          <div className=\"flex flex-col gap-2\">\n            <div className=\"relative\">\n              <div className=\"neo-border break-all rounded-md bg-muted p-3 pr-12 text-left text-xs shadow-neo-sm\">\n                {inviteLink}\n              </div>\n              <button\n                onClick={copyToClipboard}\n                className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-md border border-black bg-white p-1 active:shadow-none\"\n                aria-label=\"Copy link\"\n              >\n                {copied ? (\n                  <CheckCircle\n                    className=\"h-4 w-4 text-green-500\"\n                    strokeWidth={2.5}\n                  />\n                ) : (\n                  <Copy className=\"h-4 w-4\" strokeWidth={2.5} />\n                )}\n              </button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              Copy this link to manually share with the choreographer.\n            </p>\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col gap-3 sm:flex-row\">\n        <NeoButton onClick={handleNewInvite} variant=\"secondary\" size=\"sm\">\n          Send Another Invitation\n        </NeoButton>\n        <NeoButton onClick={handleClose} size=\"sm\">\n          Close\n        </NeoButton>\n      </div>\n    </div>\n  );\n\n  // Render the invite form\n  const InviteForm = () => (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-5\">\n        {/* Invitation Section Header */}\n        <div className=\"flex items-center gap-3\">\n          <div className=\"neo-border flex h-9 w-9 items-center justify-center rounded-full bg-blue-200 text-black shadow-neo-sm\">\n            <Mail className=\"h-4 w-4\" strokeWidth={2.5} />\n          </div>\n          <h3 className=\"text-base font-bold\">Invite a Choreographer</h3>\n        </div>\n\n        {/* Explanation Card */}\n        <NeoCard>\n          <p className=\"text-xs\">\n            Send an invitation to a choreographer to join your studio. They will\n            receive an email with a link to accept the invitation.\n          </p>\n        </NeoCard>\n\n        {/* Email Field */}\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"font-bold\">\n                Email Address <span className=\"text-red-500\">*</span>\n              </FormLabel>\n              <FormControl>\n                <Input\n                  type=\"email\"\n                  placeholder=\"choreographer@example.com\"\n                  {...field}\n                  className=\"neo-border bg-white p-3 shadow-neo-sm transition-all focus:translate-x-0.5 focus:translate-y-0.5 focus:shadow-none dark:bg-black\"\n                />\n              </FormControl>\n              <FormDescription className=\"text-xs\">\n                Enter the email address of the choreographer you want to invite.\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        {/* Form Actions */}\n        <div className=\"mt-6 flex justify-end gap-3\">\n          <NeoButton type=\"button\" variant=\"secondary\" onClick={handleClose}>\n            Cancel\n          </NeoButton>\n          <NeoButton type=\"submit\" disabled={isPending}>\n            {isPending ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Sending...\n              </>\n            ) : (\n              <>\n                <Sparkles className=\"mr-2 h-4 w-4\" strokeWidth={2.5} />\n                Send Invitation\n              </>\n            )}\n          </NeoButton>\n        </div>\n      </form>\n    </Form>\n  );\n\n  // Render either Dialog or Drawer based on screen size\n  if (isDesktop) {\n    return (\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogTrigger asChild>{TriggerButton}</DialogTrigger>\n        <DialogContent\n          className=\"sm:max-w-[500px]\"\n          onInteractOutside={(e) => e.preventDefault()}\n          onEscapeKeyDown={(e) => {\n            e.stopPropagation();\n            handleClose();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle></DialogTitle>\n          </DialogHeader>\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  return (\n    <Drawer open={open} onOpenChange={setOpen}>\n      <DrawerTrigger asChild>{TriggerButton}</DrawerTrigger>\n      <DrawerContent\n        onInteractOutside={(e) => e.preventDefault()}\n        onEscapeKeyDown={(e) => {\n          e.stopPropagation();\n          handleClose();\n        }}\n      >\n        <DrawerHeader>\n          <DrawerTitle></DrawerTitle>\n        </DrawerHeader>\n        <div className=\"px-4 pb-6\">\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </div>\n      </DrawerContent>\n    </Drawer>\n  );\n}\n```\n\n\nI'll update the `choreographers-form.tsx` to work with the new `inviteChoreographerWithLink` procedure we have in the studio router. Here's the updated file:\n\n```tsx\n// src/app/(private)/profile/choreographers-form.tsx\n\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { z } from \"zod\";\nimport { Loader2, Mail, Plus, Sparkles, Copy, CheckCircle } from \"lucide-react\";\nimport { api } from \"~/trpc/react\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTrigger,\n} from \"~/components/ui/dialog\";\nimport {\n  Drawer,\n  DrawerContent,\n  DrawerTrigger,\n  DrawerHeader,\n  DrawerTitle,\n} from \"~/components/ui/drawer\";\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"~/components/ui/form\";\nimport { Input } from \"~/components/ui/input\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { useIsMobile } from \"~/hooks/use-mobile\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { DialogTitle } from \"@radix-ui/react-dialog\";\n\n// Simplified schema - only email, no role needed\nconst choreographerInviteSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n});\n\ntype ChoreographerInviteValues = z.infer<typeof choreographerInviteSchema>;\n\nconst defaultValues: ChoreographerInviteValues = {\n  email: \"\",\n};\n\ninterface ChoreographerInviteDialogProps {\n  studioId: string;\n  studioSlug: string;\n  buttonLabel?: string;\n  buttonClassName?: string;\n  variant?: \"default\" | \"outline\" | \"secondary\" | \"ghost\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n}\n\nexport function ChoreographerInviteDialog({\n  studioId,\n  studioSlug,\n  buttonLabel = \"Add Choreographer\",\n  buttonClassName = \"\",\n  variant = \"default\",\n  size = \"default\",\n}: ChoreographerInviteDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [formSubmitted, setFormSubmitted] = useState(false);\n  const [inviteLink, setInviteLink] = useState<string | null>(null);\n  const [copied, setCopied] = useState(false);\n  const isMobile = useIsMobile();\n  const isDesktop = !isMobile;\n\n  const form = useForm<ChoreographerInviteValues>({\n    resolver: zodResolver(choreographerInviteSchema),\n    defaultValues,\n    mode: \"onChange\",\n  });\n\n  // Use the inviteChoreographerWithLink mutation\n  const { mutate: inviteChoreographer, isPending } =\n    api.studio.inviteChoreographerWithLink.useMutation({\n      onSuccess: (data) => {\n        setFormSubmitted(true);\n\n        // Store the invitation link if available\n        if (data.inviteLink) {\n          setInviteLink(data.inviteLink);\n        }\n\n        if (data.status === \"invited\") {\n          toast.success(`Invitation link generated for ${data.invitation.email}!`);\n        } else if (data.status === \"already_invited\") {\n          toast.info(`${data.invitation.email} has already been invited. Here's the link again.`);\n        }\n      },\n      onError: (error) => {\n        toast.error(`Failed to create invitation: ${error.message}`);\n      },\n    });\n\n  const onSubmit = async (values: ChoreographerInviteValues) => {\n    inviteChoreographer({\n      studioId,\n      email: values.email,\n      role: \"CHOREOGRAPHER\", // Hardcoded role\n    });\n  };\n\n  const handleNewInvite = () => {\n    setFormSubmitted(false);\n    setInviteLink(null);\n    setCopied(false);\n    form.reset(defaultValues);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    // Reset form after a short delay to avoid visual glitches\n    setTimeout(() => {\n      setFormSubmitted(false);\n      setInviteLink(null);\n      setCopied(false);\n      form.reset(defaultValues);\n    }, 200);\n  };\n\n  const copyToClipboard = async () => {\n    if (!inviteLink) return;\n\n    try {\n      await navigator.clipboard.writeText(inviteLink);\n      setCopied(true);\n      toast.success(\"Link copied to clipboard!\");\n\n      // Reset copied state after 3 seconds\n      setTimeout(() => setCopied(false), 3000);\n    } catch (err) {\n      toast.error(\"Failed to copy link to clipboard\");\n    }\n  };\n\n  // Memoize the TriggerButton to prevent unnecessary re-renders\n  const TriggerButton = useMemo(\n    () => (\n      <NeoButton variant={variant} size={size} className={buttonClassName}>\n        <Plus className=\"mr-2 h-4 w-4\" />\n        {buttonLabel}\n      </NeoButton>\n    ),\n    [variant, size, buttonClassName, buttonLabel],\n  );\n\n  // Render the success card with invitation link\n  const SuccessCard = () => (\n    <div className=\"flex flex-col items-center justify-center p-6 text-center\">\n      <div className=\"neo-border mb-5 flex h-14 w-14 items-center justify-center rounded-full bg-green-200 text-black shadow-neo-sm\">\n        <Mail className=\"h-7 w-7\" strokeWidth={2} />\n      </div>\n      <h2 className=\"mb-2 text-xl font-bold\">Invitation Link Generated!</h2>\n      <p className=\"mb-5 text-sm text-muted-foreground\">\n        Copy and share this link with the choreographer to invite them to your studio.\n      </p>\n\n      {/* Display invitation link */}\n      {inviteLink && (\n        <div className=\"mb-5 w-full\">\n          <p className=\"mb-2 text-sm font-medium\">Invitation Link:</p>\n          <div className=\"flex flex-col gap-2\">\n            <div className=\"relative\">\n              <div className=\"neo-border break-all rounded-md bg-muted p-3 pr-12 text-left text-xs shadow-neo-sm\">\n                {inviteLink}\n              </div>\n              <button\n                onClick={copyToClipboard}\n                className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-md border border-black bg-white p-1 active:shadow-none\"\n                aria-label=\"Copy link\"\n              >\n                {copied ? (\n                  <CheckCircle\n                    className=\"h-4 w-4 text-green-500\"\n                    strokeWidth={2.5}\n                  />\n                ) : (\n                  <Copy className=\"h-4 w-4\" strokeWidth={2.5} />\n                )}\n              </button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              This link is valid for 30 days.\n            </p>\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col gap-3 sm:flex-row\">\n        <NeoButton onClick={handleNewInvite} variant=\"secondary\" size=\"sm\">\n          Create Another Invitation\n        </NeoButton>\n        <NeoButton onClick={handleClose} size=\"sm\">\n          Close\n        </NeoButton>\n      </div>\n    </div>\n  );\n\n  // Render the invite form\n  const InviteForm = () => (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-5\">\n        {/* Invitation Section Header */}\n        <div className=\"flex items-center gap-3\">\n          <div className=\"neo-border flex h-9 w-9 items-center justify-center rounded-full bg-blue-200 text-black shadow-neo-sm\">\n            <Mail className=\"h-4 w-4\" strokeWidth={2.5} />\n          </div>\n          <h3 className=\"text-base font-bold\">Invite a Choreographer</h3>\n        </div>\n\n        {/* Explanation Card */}\n        <NeoCard>\n          <p className=\"text-xs\">\n            Create an invitation link to share with a choreographer to join your studio.\n            The link will allow them to sign in and join your studio as a choreographer.\n          </p>\n        </NeoCard>\n\n        {/* Email Field */}\n        <FormField\n          control={form.control}\n          name=\"email\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel className=\"font-bold\">\n                Email Address <span className=\"text-red-500\">*</span>\n              </FormLabel>\n              <FormControl>\n                <Input\n                  type=\"email\"\n                  placeholder=\"choreographer@example.com\"\n                  {...field}\n                  className=\"neo-border bg-white p-3 shadow-neo-sm transition-all focus:translate-x-0.5 focus:translate-y-0.5 focus:shadow-none dark:bg-black\"\n                />\n              </FormControl>\n              <FormDescription className=\"text-xs\">\n                Enter the email address of the choreographer you want to invite.\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        {/* Form Actions */}\n        <div className=\"mt-6 flex justify-end gap-3\">\n          <NeoButton type=\"button\" variant=\"secondary\" onClick={handleClose}>\n            Cancel\n          </NeoButton>\n          <NeoButton type=\"submit\" disabled={isPending}>\n            {isPending ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Generating...\n              </>\n            ) : (\n              <>\n                <Sparkles className=\"mr-2 h-4 w-4\" strokeWidth={2.5} />\n                Generate Invitation Link\n              </>\n            )}\n          </NeoButton>\n        </div>\n      </form>\n    </Form>\n  );\n\n  // Render either Dialog or Drawer based on screen size\n  if (isDesktop) {\n    return (\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogTrigger asChild>{TriggerButton}</DialogTrigger>\n        <DialogContent\n          className=\"sm:max-w-[500px]\"\n          onInteractOutside={(e) => e.preventDefault()}\n          onEscapeKeyDown={(e) => {\n            e.stopPropagation();\n            handleClose();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle></DialogTitle>\n          </DialogHeader>\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  return (\n    <Drawer open={open} onOpenChange={setOpen}>\n      <DrawerTrigger asChild>{TriggerButton}</DrawerTrigger>\n      <DrawerContent\n        onInteractOutside={(e) => e.preventDefault()}\n        onEscapeKeyDown={(e) => {\n          e.stopPropagation();\n          handleClose();\n        }}\n      >\n        <DrawerHeader>\n          <DrawerTitle></DrawerTitle>\n        </DrawerHeader>\n        <div className=\"px-4 pb-6\">\n          {formSubmitted ? <SuccessCard /> : <InviteForm />}\n        </div>\n      </DrawerContent>\n    </Drawer>\n  );\n}\n```\n\nKey changes I've made:\n\n1. Updated the mutation to use `inviteChoreographerWithLink` instead of `inviteChoreographer`\n2. Modified the success handling to work with the response format from `inviteChoreographerWithLink`\n3. Changed the text to reflect that we're generating a link rather than sending an email\n4. Updated the UI to emphasize that the link needs to be copied and shared manually\n5. Added an explanation that the link is valid for 30 days\n6. Changed button text to \"Generate Invitation Link\" to better reflect what's happening\n\nThis component now properly handles the link-based invitation workflow where the studio owner generates a link and shares it with the choreographer manually.\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2 } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [sentEmail, setSentEmail] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    isError,\n    error: profileError,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n    },\n  });\n\n  // Validate the invitation token\n  const { data: validationData, isLoading: isValidating } =\n    api.studio.validateInvitation.useQuery(\n      { token },\n      {\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n          // Invitation is valid\n        },\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n        },\n      },\n    );\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle magic link sign-in\n  const handleMagicLinkSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim()) {\n      toast.error(\"Please enter your email address\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n\n      // Generate magic link that redirects back to this invitation page\n      const { error } = await supabase.auth.signInWithOtp({\n        email: email.trim(),\n        options: {\n          emailRedirectTo: window.location.href, // Redirect back to this page\n        },\n      });\n\n      if (error) {\n        throw error;\n      }\n\n      // Show success message\n      toast.success(\"Check your email for a sign-in link!\");\n      setSentEmail(true);\n    } catch (err) {\n      console.error(\"Error sending magic link:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Failed to send sign-in link\",\n      );\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render magic link sign-in form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n\n          {sentEmail ? (\n            <div className=\"text-center\">\n              <p className=\"mb-4 text-gray-700\">\n                Check your email for a sign-in link!\n              </p>\n              <p className=\"text-sm text-gray-500\">\n                After signing in, you'll be able to accept this invitation.\n              </p>\n            </div>\n          ) : (\n            <form onSubmit={handleMagicLinkSignIn} className=\"mt-4 space-y-4\">\n              <p className=\"mb-2 text-center text-gray-700\">\n                Sign in with your email to accept this invitation\n              </p>\n              <Input\n                type=\"email\"\n                placeholder=\"Your email address\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full\"\n              />\n              <NeoButton\n                type=\"submit\"\n                className=\"w-full\"\n                size=\"lg\"\n                disabled={processing}\n              >\n                {processing ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Sign In\"\n                )}\n              </NeoButton>\n            </form>\n          )}\n        </NeoCard>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\nsignInWithOtp and signInWithMagicLink requires sending an email inorder to login. I think what we can do is login with google and a login with user and pass\n```ts dance-book-app/src/lib/supabase/client.ts\nimport { createBrowserClient } from \"@supabase/ssr\";\n\nexport function createClient() {\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n  );\n}\n```\n\ndance-book-app/src/app/auth/callback\n```ts dance-book-app/src/app/auth/callback/route.ts\nimport { NextResponse } from \"next/server\";\n// The client you created from the Server-Side Auth instructions\nimport { createClient } from \"~/lib/supabase/server\";\nimport { db } from \"~/server/db\";\n\nexport async function GET(request: Request) {\n  const { searchParams, origin } = new URL(request.url);\n  const code = searchParams.get(\"code\");\n  // if \"next\" is in param, use it as the redirect URL\n  let next = searchParams.get(\"next\") ?? \"/setup\";\n\n  if (code) {\n    const supabase = await createClient();\n    const { error } = await supabase.auth.exchangeCodeForSession(code);\n    if (!error) {\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n\n      const authId = user?.id;\n\n      if (authId) {\n        const profile = await db.profile.findUnique({\n          where: {\n            authId,\n          },\n        });\n\n        if (!profile) {\n          await db.profile.create({\n            data: {\n              authId,\n            },\n          });\n        } else {\n          // Check if user has a studio\n          const studioMember = await db.studioMember.findFirst({\n            where: {\n              profileId: profile?.id,\n            },\n            include: { studio: true },\n          });\n\n          if (!studioMember) {\n            next = \"/setup\";\n          } else {\n            next = `/profile`;\n          }\n        }\n      }\n\n      const forwardedHost = request.headers.get(\"x-forwarded-host\"); // original origin before load balancer\n      const isLocalEnv = process.env.NODE_ENV === \"development\";\n      if (isLocalEnv) {\n        // we can be sure that there is no load balancer in between, so no need to watch for X-Forwarded-Host\n        return NextResponse.redirect(`${origin}${next}`);\n      } else if (forwardedHost) {\n        return NextResponse.redirect(`https://${forwardedHost}${next}`);\n      } else {\n        return NextResponse.redirect(`${origin}${next}`);\n      }\n    }\n  }\n\n  // return the user to an error page with instructions\n  return NextResponse.redirect(`${origin}/auth/auth-code-error`);\n}\n```\n\n\n\nYou're right - using magic links requires sending emails, which wouldn't work well for our requirements. Let's update the `invite-accept-content.tsx` component to use standard email/password and Google authentication options:\n\n```tsx\n// src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2, Mail, Lock, User } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\nimport { FcGoogle } from \"react-icons/fc\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"~/components/ui/tabs\";\nimport { Label } from \"~/components/ui/label\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [signUpMode, setSignUpMode] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    refetch: refetchProfile,\n    isError,\n    error: profileError,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n    },\n  });\n\n  // Validate the invitation token\n  const { data: validationData, isLoading: isValidating } =\n    api.studio.validateInvitation.useQuery(\n      { token },\n      {\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n          }\n        },\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n        },\n      },\n    );\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle email/password sign in\n  const handleEmailSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!email.trim() || !password.trim()) {\n      toast.error(\"Please enter both email and password\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\"next\", window.location.pathname + window.location.search);\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\"next\", redirectURL.pathname + redirectURL.search);\n\n      if (signUpMode) {\n        // Handle sign up\n        if (password !== confirmPassword) {\n          toast.error(\"Passwords do not match\");\n          setProcessing(false);\n          return;\n        }\n\n        const { error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: {\n            emailRedirectTo: callbackURL.toString(),\n          }\n        });\n        \n        if (error) throw error;\n        \n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1500);\n      } else {\n        // Handle sign in\n        const { error } = await supabase.auth.signInWithPassword({\n          email,\n          password\n        });\n        \n        if (error) throw error;\n        \n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1000);\n      }\n    } catch (err) {\n      console.error(\"Auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Authentication failed\"\n      );\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // Handle Google sign in\n  const handleGoogleSignIn = async () => {\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\"next\", window.location.pathname + window.location.search);\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\"next\", redirectURL.pathname + redirectURL.search);\n\n      const { error } = await supabase.auth.signInWithOAuth({\n        provider: 'google',\n        options: {\n          redirectTo: callbackURL.toString()\n        }\n      });\n      \n      if (error) throw error;\n    } catch (err) {\n      console.error(\"Google auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Google authentication failed\"\n      );\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render auth form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n          <p className=\"text-center text-sm text-muted-foreground\">\n            Sign in or create an account to accept this invitation\n          </p>\n        </NeoCard>\n\n        <div className=\"space-y-4\">\n          {/* Google Sign In */}\n          <NeoButton\n            className=\"w-full justify-center\"\n            variant=\"outline\"\n            size=\"lg\"\n            onClick={handleGoogleSignIn}\n            disabled={processing}\n          >\n            {processing ? (\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FcGoogle className=\"mr-2 h-5 w-5\" />\n            )}\n            Continue with Google\n          </NeoButton>\n\n          <div className=\"relative my-4\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <span className=\"w-full border-t border-gray-300\" />\n            </div>\n            <div className=\"relative flex justify-center text-xs uppercase\">\n              <span className=\"bg-white px-2 text-muted-foreground\">\n                Or continue with\n              </span>\n            </div>\n          </div>\n\n          {/* Email/Password Auth */}\n          <Tabs defaultValue=\"signin\" className=\"w-full\" onValueChange={(value) => setSignUpMode(value === \"signup\")}>\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"signin\">Sign In</TabsTrigger>\n              <TabsTrigger value=\"signup\">Sign Up</TabsTrigger>\n            </TabsList>\n            \n            <TabsContent value=\"signin\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n                \n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n                \n                <NeoButton \n                  type=\"submit\"\n                  className=\"w-full\" \n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Signing in...\n                    </>\n                  ) : (\n                    \"Sign In\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n            \n            <TabsContent value=\"signup\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n                \n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n                \n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"confirm-password\"\n                      type=\"password\"\n                      value={confirmPassword}\n                      onChange={(e) => setConfirmPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n                \n                <NeoButton \n                  type=\"submit\"\n                  className=\"w-full\" \n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Creating account...\n                    </>\n                  ) : (\n                    \"Create Account\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\nThe key changes I've made:\n\n1. Added email/password sign-in and sign-up tabs, replacing the magic link functionality\n2. Added Google sign-in as an alternative authentication method\n3\n```tsx dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2, Mail, Lock, User } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"~/components/ui/tabs\";\nimport { Label } from \"~/components/ui/label\";\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token: string;\n  studioName?: string;\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [signUpMode, setSignUpMode] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    refetch: refetchProfile,\n    isError,\n    error: profileError,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n    },\n  });\n\n  // Validate the invitation token\n  const { data: validationData, isLoading: isValidating } =\n    api.studio.validateInvitation.useQuery(\n      { token },\n      {\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n          }\n        },\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n        },\n      },\n    );\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle email/password sign in\n  const handleEmailSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim() || !password.trim()) {\n      toast.error(\"Please enter both email and password\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      if (signUpMode) {\n        // Handle sign up\n        if (password !== confirmPassword) {\n          toast.error(\"Passwords do not match\");\n          setProcessing(false);\n          return;\n        }\n\n        const { error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: {\n            emailRedirectTo: callbackURL.toString(),\n          },\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1500);\n      } else {\n        // Handle sign in\n        const { error } = await supabase.auth.signInWithPassword({\n          email,\n          password,\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1000);\n      }\n    } catch (err) {\n      console.error(\"Auth error:\", err);\n      toast.error(err instanceof Error ? err.message : \"Authentication failed\");\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // Handle Google sign in\n  const handleGoogleSignIn = async () => {\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      const { error } = await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: {\n          redirectTo: callbackURL.toString(),\n        },\n      });\n\n      if (error) throw error;\n    } catch (err) {\n      console.error(\"Google auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Google authentication failed\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render auth form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n          <p className=\"text-center text-sm text-muted-foreground\">\n            Sign in or create an account to accept this invitation\n          </p>\n        </NeoCard>\n\n        <div className=\"space-y-4\">\n          {/* Google Sign In */}\n          <NeoButton\n            className=\"w-full justify-center\"\n            variant=\"outline\"\n            size=\"lg\"\n            onClick={handleGoogleSignIn}\n            disabled={processing}\n          >\n            {processing ? (\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FcGoogle className=\"mr-2 h-5 w-5\" />\n            )}\n            Continue with Google\n          </NeoButton>\n\n          <div className=\"relative my-4\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <span className=\"w-full border-t border-gray-300\" />\n            </div>\n            <div className=\"relative flex justify-center text-xs uppercase\">\n              <span className=\"bg-white px-2 text-muted-foreground\">\n                Or continue with\n              </span>\n            </div>\n          </div>\n\n          {/* Email/Password Auth */}\n          <Tabs\n            defaultValue=\"signin\"\n            className=\"w-full\"\n            onValueChange={(value) => setSignUpMode(value === \"signup\")}\n          >\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"signin\">Sign In</TabsTrigger>\n              <TabsTrigger value=\"signup\">Sign Up</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"signin\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Signing in...\n                    </>\n                  ) : (\n                    \"Sign In\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n\n            <TabsContent value=\"signup\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"confirm-password\"\n                      type=\"password\"\n                      value={confirmPassword}\n                      onChange={(e) => setConfirmPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Creating account...\n                    </>\n                  ) : (\n                    \"Create Account\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\ndiagnostics\ndance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n```tsx\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n//          Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n```\n```tsx\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ....'.\n//          Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, ...'.\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n```\n```tsx\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n// error: Parameter 'data' implicitly has an 'any' type.\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n```\n```tsx\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n// error: Unsafe member access .invitation on an `any` value.\n            setEmail(data.invitation.email);\n          }\n```\n```tsx\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n// error: Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string>`.\n          }\n        },\n```\n```tsx\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n// error: Unsafe member access .invitation on an `any` value.\n          }\n        },\n```\n```tsx\n          }\n        },\n        onError: (error) => {\n// error: Parameter 'error' implicitly has an 'any' type.\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n```\n```tsx\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n// error: Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string | null>`.\n        },\n      },\n```\n```tsx\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n// error: Unsafe member access .message on an `any` value.\n        },\n      },\n```\n```tsx\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n// error: Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n//          Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n```\n```tsx\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n// error: Unsafe member access .slug on an `error` typed value.\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n```\n```tsx\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n// error: Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n//          Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.\n        } else {\n          router.push(`/studios`);\n```\n```tsx\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n// error: Unsafe member access .slug on an `error` typed value.\n        } else {\n          router.push(`/studios`);\n```\n```tsx\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1500);\n// error: Promise returned in function argument where a void return was expected.\n      } else {\n        // Handle sign in\n```\n```tsx\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1000);\n// error: Promise returned in function argument where a void return was expected.\n      }\n    } catch (err) {\n```\n```tsx\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n// error: `'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n```\n```tsx\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FcGoogle className=\"mr-2 h-5 w-5\" />\n// error: Cannot find name 'FcGoogle'.\n            )}\n            Continue with Google\n```\n```tsx\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FcGoogle className=\"mr-2 h-5 w-5\" />\n// error: 'FcGoogle' is not defined.\n            )}\n            Continue with Google\n```\n```tsx\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n// error: `'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n```\n```tsx\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in and ready to join this studio\n// error: `'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.\n        </p>\n      </NeoCard>\n```\ndance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx\n```tsx\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n//          Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n```\n```tsx\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n// error: No overload matches this call.\n//          Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ....'.\n//          Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n//            Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, ...'.\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n```\n```tsx\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data) => {\n// error: Parameter 'data' implicitly has an 'any' type.\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n```\n```tsx\n          // Invitation is valid\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n// error: Unsafe member access .invitation on an `any` value.\n            setEmail(data.invitation.email);\n          }\n```\n```tsx\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n// error: Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string>`.\n          }\n        },\n```\n```tsx\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n// error: Unsafe member access .invitation on an `any` value.\n          }\n        },\n```\n```tsx\n          }\n        },\n        onError: (error) => {\n// error: Parameter 'error' implicitly has an 'any' type.\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n```\n```tsx\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n// error: Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string | null>`.\n        },\n      },\n```\n```tsx\n        onError: (error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n// error: Unsafe member access .message on an `any` value.\n        },\n      },\n```\n```tsx\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n// error: Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n//          Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n```\n```tsx\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n// error: Unsafe member access .slug on an `error` typed value.\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n```\n```tsx\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n// error: Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n//          Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.\n        } else {\n          router.push(`/studios`);\n```\n```tsx\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n// error: Unsafe member access .slug on an `error` typed value.\n        } else {\n          router.push(`/studios`);\n```\n```tsx\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1500);\n// error: Promise returned in function argument where a void return was expected.\n      } else {\n        // Handle sign in\n```\n```tsx\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => refetchProfile(), 1000);\n// error: Promise returned in function argument where a void return was expected.\n      }\n    } catch (err) {\n```\n```tsx\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You've been invited as a\n// error: `'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n```\n```tsx\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FcGoogle className=\"mr-2 h-5 w-5\" />\n// error: Cannot find name 'FcGoogle'.\n            )}\n            Continue with Google\n```\n```tsx\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FcGoogle className=\"mr-2 h-5 w-5\" />\n// error: 'FcGoogle' is not defined.\n            )}\n            Continue with Google\n```\n```tsx\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You've been invited as a\n// error: `'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n```\n```tsx\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You're signed in and ready to join this studio\n// error: `'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.\n        </p>\n      </NeoCard>\n```\ndance-book-app/src/app/(public)/invite-accept/page.tsx\n```tsx\n                <p className=\"text-md\">\n                  {studioData.address}, {studioData.city},{\" \"}\n                  {studioData.stateName || studioData.state}\n// error: Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.\n                  {studioData.postalCode && `, ${studioData.postalCode}`}\n                </p>\n```\ndance-book-app/src/app/(private)/profile/choreographers-form.tsx\n```tsx\n  const TriggerButton = useMemo(\n    () => (\n      <NeoButton variant={variant} size={size} className={buttonClassName}>\n// error: Type '\"default\" | \"outline\" | \"secondary\" | \"ghost\"' is not assignable to type '\"default\" | \"destructive\" | \"outline\" | \"secondary\" | \"lg\" | undefined'.\n//          Type '\"ghost\"' is not assignable to type '\"default\" | \"destructive\" | \"outline\" | \"secondary\" | \"lg\" | undefined'.\n        <Plus className=\"mr-2 h-4 w-4\" />\n        {buttonLabel}\n```\n\ncan you please fix all the errors\nLet me fix the errors in the code. Here's the corrected version of the `invite-accept-content.tsx` file:\n\n```tsx\n// src/app/(public)/invite-accept/invite-accept-content.tsx\n\"use client\";\n\nimport { useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createClient } from \"~/lib/supabase/client\";\nimport { Loader2, Mail, Lock } from \"lucide-react\";\nimport { NeoButton } from \"~/components/ui/neo-button\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport { api } from \"~/trpc/react\";\nimport { toast } from \"sonner\";\nimport { Input } from \"~/components/ui/input\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"~/components/ui/tabs\";\nimport { Label } from \"~/components/ui/label\";\nimport { FaGoogle } from \"react-icons/fa\"; // Using Font Awesome for Google icon\n\ninterface InviteAcceptContentProps {\n  studioId: string;\n  role: string;\n  token: string;\n  studioName?: string;\n}\n\ninterface InvitationData {\n  valid: boolean;\n  invitation: {\n    email: string;\n    studio: {\n      slug: string;\n      [key: string]: any;\n    };\n    [key: string]: any;\n  };\n}\n\ninterface MembershipData {\n  status: string;\n  membership: {\n    studio?: {\n      slug?: string;\n    };\n  };\n}\n\nexport function InviteAcceptContent({\n  studioId,\n  role,\n  token,\n  studioName = \"Studio\",\n}: InviteAcceptContentProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [processing, setProcessing] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [signUpMode, setSignUpMode] = useState(false);\n  const router = useRouter();\n  const supabase = createClient();\n\n  // Check if the user is authenticated\n  const {\n    data: profile,\n    isLoading: isLoadingProfile,\n    refetch: refetchProfile,\n    isError,\n  } = api.profile.getCurrent.useQuery(undefined, {\n    retry: 0, // Don't retry if the user is not authenticated\n    onError: () => {\n      // This is expected if the user is not logged in\n      console.log(\"User not authenticated yet\");\n    },\n  });\n\n  // Validate the invitation token\n  const { data: validationData, isLoading: isValidating } =\n    api.studio.validateInvitation.useQuery(\n      { token },\n      {\n        enabled: !!token,\n        retry: 1,\n        onSuccess: (data: InvitationData) => {\n          // Pre-fill email if it exists in the invitation\n          if (data.invitation?.email && !email) {\n            setEmail(data.invitation.email);\n          }\n        },\n        onError: (error: Error) => {\n          console.error(\"Invalid invitation:\", error);\n          setError(error.message);\n        },\n      },\n    );\n\n  // Get the acceptInvitation mutation\n  const { mutate: acceptInvitation, isPending: isAcceptingInvitation } =\n    api.studio.acceptInvitationWithLink.useMutation({\n      onSuccess: (data: MembershipData) => {\n        toast.success(\"Successfully joined studio!\");\n        // Navigate to the studio page\n        if (data.membership.studio?.slug) {\n          router.push(`/studio/${data.membership.studio.slug}`);\n        } else {\n          router.push(`/studios`);\n        }\n      },\n      onError: (error: Error) => {\n        console.error(\"Error accepting invitation:\", error);\n        toast.error(\"Failed to join studio: \" + error.message);\n        setError(error.message);\n        setProcessing(false);\n      },\n    });\n\n  // Handle email/password sign in\n  const handleEmailSignIn = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!email.trim() || !password.trim()) {\n      toast.error(\"Please enter both email and password\");\n      return;\n    }\n\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      if (signUpMode) {\n        // Handle sign up\n        if (password !== confirmPassword) {\n          toast.error(\"Passwords do not match\");\n          setProcessing(false);\n          return;\n        }\n\n        const { error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: {\n            emailRedirectTo: callbackURL.toString(),\n          },\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Account created! Redirecting...\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1500);\n      } else {\n        // Handle sign in\n        const { error } = await supabase.auth.signInWithPassword({\n          email,\n          password,\n        });\n\n        if (error) throw error;\n\n        toast.success(\"Signed in successfully!\");\n        // Wait a moment and then refetch profile\n        setTimeout(() => {\n          void refetchProfile();\n        }, 1000);\n      }\n    } catch (err) {\n      console.error(\"Auth error:\", err);\n      toast.error(err instanceof Error ? err.message : \"Authentication failed\");\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  // Handle Google sign in\n  const handleGoogleSignIn = async () => {\n    try {\n      setProcessing(true);\n      const redirectURL = new URL(window.location.href);\n      redirectURL.searchParams.set(\n        \"next\",\n        window.location.pathname + window.location.search,\n      );\n      const callbackURL = new URL(\"/auth/callback\", window.location.origin);\n      callbackURL.searchParams.set(\n        \"next\",\n        redirectURL.pathname + redirectURL.search,\n      );\n\n      const { error } = await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: {\n          redirectTo: callbackURL.toString(),\n        },\n      });\n\n      if (error) throw error;\n    } catch (err) {\n      console.error(\"Google auth error:\", err);\n      toast.error(\n        err instanceof Error ? err.message : \"Google authentication failed\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // When the user clicks \"Join Studio\" button\n  const handleAcceptInvitation = async () => {\n    if (!token) return;\n\n    try {\n      setProcessing(true);\n      // Accept the invitation using the TRPC mutation\n      acceptInvitation({ token });\n    } catch (err) {\n      console.error(\"Error accepting invitation:\", err);\n      setError(\n        err instanceof Error ? err.message : \"Failed to accept invitation\",\n      );\n      setProcessing(false);\n    }\n  };\n\n  // Show validation error if the invitation is invalid\n  if (error) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-red-50\"\n        className=\"mt-4 p-4 text-center\"\n      >\n        <p className=\"mb-3 text-red-700\">\n          {error || \"Invalid invitation link\"}\n        </p>\n        <NeoButton onClick={() => router.push(\"/\")} size=\"sm\">\n          Go to Home Page\n        </NeoButton>\n      </NeoCard>\n    );\n  }\n\n  // Processing state\n  if (isValidating || processing || isLoadingProfile || isAcceptingInvitation) {\n    return (\n      <NeoCard\n        variant=\"colored\"\n        colorClassName=\"bg-blue-50\"\n        className=\"mb-6 p-4 text-center\"\n      >\n        <div className=\"mb-2 flex justify-center\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-primary\" />\n        </div>\n        <p className=\"text-gray-700\">\n          {isValidating\n            ? \"Validating your invitation...\"\n            : isAcceptingInvitation\n              ? \"Accepting your invitation...\"\n              : isLoadingProfile\n                ? \"Checking your account...\"\n                : \"Processing...\"}\n        </p>\n      </NeoCard>\n    );\n  }\n\n  // Render auth form if not signed in\n  if (!profile) {\n    return (\n      <>\n        <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n          <p className=\"mb-3 text-center text-lg font-bold\">\n            You&apos;ve been invited as a\n            <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n              {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n            </span>\n          </p>\n          <p className=\"text-center text-sm text-muted-foreground\">\n            Sign in or create an account to accept this invitation\n          </p>\n        </NeoCard>\n\n        <div className=\"space-y-4\">\n          {/* Google Sign In */}\n          <NeoButton\n            className=\"w-full justify-center\"\n            variant=\"outline\"\n            size=\"lg\"\n            onClick={handleGoogleSignIn}\n            disabled={processing}\n          >\n            {processing ? (\n              <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            ) : (\n              <FaGoogle className=\"mr-2 h-5 w-5\" />\n            )}\n            Continue with Google\n          </NeoButton>\n\n          <div className=\"relative my-4\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <span className=\"w-full border-t border-gray-300\" />\n            </div>\n            <div className=\"relative flex justify-center text-xs uppercase\">\n              <span className=\"bg-white px-2 text-muted-foreground\">\n                Or continue with\n              </span>\n            </div>\n          </div>\n\n          {/* Email/Password Auth */}\n          <Tabs\n            defaultValue=\"signin\"\n            className=\"w-full\"\n            onValueChange={(value) => setSignUpMode(value === \"signup\")}\n          >\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"signin\">Sign In</TabsTrigger>\n              <TabsTrigger value=\"signup\">Sign Up</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"signin\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Signing in...\n                    </>\n                  ) : (\n                    \"Sign In\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n\n            <TabsContent value=\"signup\">\n              <form onSubmit={handleEmailSignIn} className=\"space-y-4 py-2\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-email\">Email</Label>\n                  <div className=\"relative\">\n                    <Mail className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-email\"\n                      placeholder=\"name@example.com\"\n                      type=\"email\"\n                      value={email}\n                      onChange={(e) => setEmail(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"signup-password\">Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"signup-password\"\n                      type=\"password\"\n                      value={password}\n                      onChange={(e) => setPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                  <div className=\"relative\">\n                    <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                    <Input\n                      id=\"confirm-password\"\n                      type=\"password\"\n                      value={confirmPassword}\n                      onChange={(e) => setConfirmPassword(e.target.value)}\n                      className=\"pl-10\"\n                      required\n                      minLength={6}\n                    />\n                  </div>\n                </div>\n\n                <NeoButton\n                  type=\"submit\"\n                  className=\"w-full\"\n                  size=\"lg\"\n                  disabled={processing}\n                >\n                  {processing ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n                      Creating account...\n                    </>\n                  ) : (\n                    \"Create Account\"\n                  )}\n                </NeoButton>\n              </form>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </>\n    );\n  }\n\n  // Render the accept invitation UI for signed-in users\n  return (\n    <>\n      <NeoCard variant=\"colored\" className=\"mb-6 p-4\">\n        <p className=\"mb-3 text-center text-lg font-bold\">\n          You&apos;ve been invited as a\n          <span className=\"ml-1 inline-block rounded-md bg-primary px-2 py-1 text-white\">\n            {role?.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </span>\n        </p>\n        <p className=\"text-center text-gray-700\">\n          You&apos;re signed in and ready to join this studio\n        </p>\n      </NeoCard>\n\n      <NeoButton\n        onClick={handleAcceptInvitation}\n        disabled={processing || isAcceptingInvitation}\n        className=\"w-full\"\n        size=\"lg\"\n      >\n        {processing || isAcceptingInvitation ?\ncontinue\nHere's the rest of the fixed code:\n\n```tsx\n        {processing || isAcceptingInvitation ? (\n          <>\n            <Loader2 className=\"mr-2 h-5 w-5 animate-spin\" />\n            Processing...\n          </>\n        ) : (\n          <>Join {studioName}</>\n        )}\n      </NeoButton>\n    </>\n  );\n}\n```\n\nAnd I need to fix the `page.tsx` file to address the nullish coalescing error:\n\n```tsx\n// src/app/(public)/invite-accept/page.tsx\nimport React, { Suspense } from \"react\";\nimport { api } from \"~/trpc/server\";\nimport { InviteAcceptContent } from \"./invite-accept-content\";\nimport { InviteAcceptSkeleton } from \"./invite-accept-skeleton\";\nimport { MapPin, Building2 } from \"lucide-react\";\nimport { NeoCard } from \"~/components/ui/neo-card\";\nimport Image from \"next/image\";\nimport { notFound } from \"next/navigation\";\n\ninterface InviteAcceptPageProps {\n  searchParams: {\n    studioId?: string;\n    role?: string;\n    token?: string;\n  };\n}\n\nexport default async function InviteAcceptPage({ searchParams }: InviteAcceptPageProps) {\n  const { studioId, role, token } = searchParams;\n\n  // Return early if no studioId, role or token\n  if (!studioId || !role || !token) {\n    return notFound();\n  }\n\n  try {\n    // Fetch studio data on the server\n    const studioData = await api.studio.findUnique({ id: studioId });\n\n    if (!studioData) {\n      return notFound();\n    }\n\n    return (\n      <div className=\"flex min-h-screen flex-col items-center justify-center p-4 sm:p-8\">\n        <NeoCard className=\"w-full max-w-md overflow-hidden p-0\">\n          {/* Studio Logo/Banner */}\n          <div className=\"neo-border relative h-40 w-full overflow-hidden rounded-xl border-b-4 border-black\">\n            {studioData.logo ? (\n              <Image\n                src={studioData.logo}\n                alt={studioData.name}\n                fill\n                sizes=\"(max-width: 768px) 100vw, 400px\"\n                className=\"object-cover\"\n                unoptimized\n              />\n            ) : (\n              <div className=\"flex h-full w-full items-center justify-center bg-muted\">\n                <Building2 className=\"h-16 w-16 text-muted-foreground\" />\n              </div>\n            )}\n          </div>\n\n          <div className=\"p-6\">\n            {/* Studio Info */}\n            <div className=\"mb-8\">\n              <h1 className=\"mb-3 text-center text-2xl font-black\">\n                {studioData.name || \"Studio\"}\n              </h1>\n\n              <div className=\"mb-4 flex items-start gap-2\">\n                <MapPin className=\"mt-1 h-5 w-5 flex-shrink-0 text-primary\" />\n                <p className=\"text-md\">\n                  {studioData.address}, {studioData.city},{\" \"}\n                  {studioData.stateName ?? studioData.state}\n                  {studioData.postalCode && `, ${studioData.postalCode}`}\n                </p>\n              </div>\n\n              {studioData.description && (\n                <p className=\"mt-3 text-gray-700\">{studioData.description}</p>\n              )}\n            </div>\n\n            <Suspense fallback={<InviteAcceptSkeleton />}>\n              {/* Client component handles authentication */}\n              <InviteAcceptContent\n                token={token}\n                studioId={studioId}\n                role={role}\n                studioName={studioData.name}\n              />\n            </Suspense>\n          </div>\n        </NeoCard>\n      </div>\n    );\n  } catch (error) {\n    console.error(\"Error loading studio:\", error);\n    return notFound();\n  }\n}\n```\n\nFinally, I'll fix the `choreographers-form.tsx` to address the button variant issue:\n\n```tsx\n// Inside choreographers-form.tsx, update the TriggerButton to fix the variant type error\nconst TriggerButton = useMemo(\n  () => (\n    <NeoButton \n      variant={variant === \"ghost\" ? \"secondary\" : variant} \n      size={size} \n      className={buttonClassName}\n    >\n      <Plus className=\"mr-2 h-4 w-4\" />\n      {buttonLabel}\n    </NeoButton>\n  ),\n  [variant, size, buttonClassName, buttonLabel],\n);\n```\n\nThe main changes I made to fix the errors:\n\n1. Added proper type interfaces for invitation and membership data\n2. Fixed promise return issues in setTimeout callbacks using `void` operator\n3. Changed apostrophes to use `&apos;` to satisfy JSX escaping rules\n4. Replaced `FcGoogle` with `FaGoogle` from react-icons\n5. Added explicit type annotations for parameters in callbacks\n6. Fixed the nullish coalescing operator usage (`??` instead of `||`)\n7. Fixed the button variant issue by mapping \"ghost\" to \"secondary\" if needed\n\nThese changes should resolve all the TypeScript errors while maintaining the functionality of the invitation system.\n/fil","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5463}}},{"id":{"replica_id":0,"value":13},"start":2328,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5464}}},{"id":{"replica_id":0,"value":61},"start":47699,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5465}}},{"id":{"replica_id":0,"value":219},"start":47863,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5466}}},{"id":{"replica_id":0,"value":220},"start":62300,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5467}}},{"id":{"replica_id":0,"value":459},"start":62364,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5468}}},{"id":{"replica_id":0,"value":530},"start":68511,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5469}}},{"id":{"replica_id":0,"value":531},"start":82691,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5470}}},{"id":{"replica_id":0,"value":833},"start":93085,"metadata":{"role":"assistant","status":"Canceled","timestamp":{"replica_id":0,"value":5471}}},{"id":{"replica_id":0,"value":834},"start":96615,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5472}}},{"id":{"replica_id":0,"value":1190},"start":123716,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5473}}},{"id":{"replica_id":0,"value":1400},"start":123775,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5474}}},{"id":{"replica_id":0,"value":1465},"start":134111,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5475}}},{"id":{"replica_id":0,"value":1466},"start":144969,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5476}}},{"id":{"replica_id":0,"value":2866},"start":153054,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5477}}},{"id":{"replica_id":0,"value":3237},"start":155476,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5478}}},{"id":{"replica_id":0,"value":3238},"start":170674,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5479}}},{"id":{"replica_id":0,"value":3889},"start":206196,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5480}}},{"id":{"replica_id":0,"value":3890},"start":221233,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5481}}},{"id":{"replica_id":0,"value":4956},"start":221242,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5482}}},{"id":{"replica_id":0,"value":4957},"start":225907,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5483}}}],"summary":"I'll implement the necessary changes to make the choreographer invitation system fully functional.","slash_command_output_sections":[{"range":{"start":0,"end":1276},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1275},"icon":"Library","label":"General","metadata":null},{"range":{"start":2328,"end":29561},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":29562,"end":41968},"icon":"Folder","label":"dance-book-app/src/app/(public)/invite-accept","metadata":null},{"range":{"start":29608,"end":36736},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}},{"range":{"start":36737,"end":38535},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-skeleton.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-skeleton.tsx"}},{"range":{"start":38536,"end":41967},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/page.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/page.tsx"}},{"range":{"start":41969,"end":47697},"icon":"File","label":"dance-book-app/prisma/schema.prisma","metadata":{"path":"dance-book-app/prisma/schema.prisma"}},{"range":{"start":62367,"end":68474},"icon":"File","label":"dance-book-app/src/server/api/routers/profile.ts","metadata":{"path":"dance-book-app/src/server/api/routers/profile.ts"}},{"range":{"start":82710,"end":93044},"icon":"File","label":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx","metadata":{"path":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx"}},{"range":{"start":96618,"end":123637},"icon":"File","label":"dance-book-app/src/server/api/routers/studio.ts","metadata":{"path":"dance-book-app/src/server/api/routers/studio.ts"}},{"range":{"start":123775,"end":134109},"icon":"File","label":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx","metadata":{"path":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx"}},{"range":{"start":144969,"end":152896},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}},{"range":{"start":153054,"end":153321},"icon":"File","label":"dance-book-app/src/lib/supabase/client.ts","metadata":{"path":"dance-book-app/src/lib/supabase/client.ts"}},{"range":{"start":153322,"end":155474},"icon":"Folder","label":"dance-book-app/src/app/auth/callback","metadata":null},{"range":{"start":153359,"end":155473},"icon":"File","label":"dance-book-app/src/app/auth/callback/route.ts","metadata":{"path":"dance-book-app/src/app/auth/callback/route.ts"}},{"range":{"start":170674,"end":185416},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":{"path":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx"}},{"range":{"start":185417,"end":206161},"icon":"Warning","label":"Diagnostics: 22 errors","metadata":null},{"range":{"start":185429,"end":195297},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":null},{"range":{"start":185501,"end":187513},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n  Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.","metadata":null},{"range":{"start":187514,"end":189493},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ....'.\n  Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, ...'.","metadata":null},{"range":{"start":189494,"end":189728},"icon":"XCircle","label":"Parameter 'data' implicitly has an 'any' type.","metadata":null},{"range":{"start":189729,"end":190000},"icon":"XCircle","label":"Unsafe member access .invitation on an `any` value.","metadata":null},{"range":{"start":190001,"end":190286},"icon":"XCircle","label":"Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string>`.","metadata":null},{"range":{"start":190287,"end":190536},"icon":"XCircle","label":"Unsafe member access .invitation on an `any` value.","metadata":null},{"range":{"start":190537,"end":190748},"icon":"XCircle","label":"Parameter 'error' implicitly has an 'any' type.","metadata":null},{"range":{"start":190749,"end":191004},"icon":"XCircle","label":"Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string | null>`.","metadata":null},{"range":{"start":191005,"end":191214},"icon":"XCircle","label":"Unsafe member access .message on an `any` value.","metadata":null},{"range":{"start":191215,"end":191947},"icon":"XCircle","label":"Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n  Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.","metadata":null},{"range":{"start":191948,"end":192241},"icon":"XCircle","label":"Unsafe member access .slug on an `error` typed value.","metadata":null},{"range":{"start":192242,"end":192955},"icon":"XCircle","label":"Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n  Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.","metadata":null},{"range":{"start":192956,"end":193230},"icon":"XCircle","label":"Unsafe member access .slug on an `error` typed value.","metadata":null},{"range":{"start":193231,"end":193522},"icon":"XCircle","label":"Promise returned in function argument where a void return was expected.","metadata":null},{"range":{"start":193523,"end":193793},"icon":"XCircle","label":"Promise returned in function argument where a void return was expected.","metadata":null},{"range":{"start":193794,"end":194201},"icon":"XCircle","label":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","metadata":null},{"range":{"start":194202,"end":194433},"icon":"XCircle","label":"Cannot find name 'FcGoogle'.","metadata":null},{"range":{"start":194434,"end":194663},"icon":"XCircle","label":"'FcGoogle' is not defined.","metadata":null},{"range":{"start":194664,"end":195061},"icon":"XCircle","label":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","metadata":null},{"range":{"start":195062,"end":195297},"icon":"XCircle","label":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","metadata":null},{"range":{"start":195298,"end":205166},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/invite-accept-content.tsx","metadata":null},{"range":{"start":195370,"end":197382},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: void | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'DefinedUseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientEr...'.\n  Overload 2 of 2, '(input: void | typeof skipToken, opts?: UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; ... 7 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike<...>, { ...; } & { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onError' does not exist in type 'UseTRPCQueryOptions<{ studioMembers: ({ studio: { description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; city: string; ... 4 more ...; openingHours: JsonValue; }; } & { ...; })[]; } & { ...; }, { ...; } & { ...; }, TRPCClientErrorLike...'.","metadata":null},{"range":{"start":197383,"end":199362},"icon":"XCircle","label":"No overload matches this call.\n  Overload 1 of 2, '(input: { token: string; } | typeof skipToken, opts: DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }>): DefinedUseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'DefinedUseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ....'.\n  Overload 2 of 2, '(input: { token: string; } | typeof skipToken, opts?: UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; ... 8 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, TRPCClientErrorLike<...>, { ...; }> | undefined): UseTRPCQueryResult<...>', gave the following error.\n    Object literal may only specify known properties, and 'onSuccess' does not exist in type 'UseTRPCQueryOptions<{ valid: boolean; invitation: { studio: ({ description: string | null; name: string; id: string; createdAt: Date; updatedAt: Date; isActive: boolean; slug: string; address: string; ... 5 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 7 more ...; invitedById: string; }; }, { ...; }, ...'.","metadata":null},{"range":{"start":199363,"end":199597},"icon":"XCircle","label":"Parameter 'data' implicitly has an 'any' type.","metadata":null},{"range":{"start":199598,"end":199869},"icon":"XCircle","label":"Unsafe member access .invitation on an `any` value.","metadata":null},{"range":{"start":199870,"end":200155},"icon":"XCircle","label":"Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string>`.","metadata":null},{"range":{"start":200156,"end":200405},"icon":"XCircle","label":"Unsafe member access .invitation on an `any` value.","metadata":null},{"range":{"start":200406,"end":200617},"icon":"XCircle","label":"Parameter 'error' implicitly has an 'any' type.","metadata":null},{"range":{"start":200618,"end":200873},"icon":"XCircle","label":"Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<string | null>`.","metadata":null},{"range":{"start":200874,"end":201083},"icon":"XCircle","label":"Unsafe member access .message on an `any` value.","metadata":null},{"range":{"start":201084,"end":201816},"icon":"XCircle","label":"Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n  Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.","metadata":null},{"range":{"start":201817,"end":202110},"icon":"XCircle","label":"Unsafe member access .slug on an `error` typed value.","metadata":null},{"range":{"start":202111,"end":202824},"icon":"XCircle","label":"Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; } | { studio: ({ description: string | null; name: string; ... 11 more ...; openingHours: JsonValue; } & { ...; }) | null; ... 6 more ...; profileId: string; }'. Did you mean 'studioId'?\n  Property 'studio' does not exist on type '{ id: string; createdAt: Date; updatedAt: Date; role: StudioRole; studioId: string; profileId: string; }'.","metadata":null},{"range":{"start":202825,"end":203099},"icon":"XCircle","label":"Unsafe member access .slug on an `error` typed value.","metadata":null},{"range":{"start":203100,"end":203391},"icon":"XCircle","label":"Promise returned in function argument where a void return was expected.","metadata":null},{"range":{"start":203392,"end":203662},"icon":"XCircle","label":"Promise returned in function argument where a void return was expected.","metadata":null},{"range":{"start":203663,"end":204070},"icon":"XCircle","label":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","metadata":null},{"range":{"start":204071,"end":204302},"icon":"XCircle","label":"Cannot find name 'FcGoogle'.","metadata":null},{"range":{"start":204303,"end":204532},"icon":"XCircle","label":"'FcGoogle' is not defined.","metadata":null},{"range":{"start":204533,"end":204930},"icon":"XCircle","label":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","metadata":null},{"range":{"start":204931,"end":205166},"icon":"XCircle","label":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","metadata":null},{"range":{"start":205167,"end":205609},"icon":"File","label":"dance-book-app/src/app/(public)/invite-accept/page.tsx","metadata":null},{"range":{"start":205222,"end":205609},"icon":"XCircle","label":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","metadata":null},{"range":{"start":205610,"end":206160},"icon":"File","label":"dance-book-app/src/app/(private)/profile/choreographers-form.tsx","metadata":null},{"range":{"start":205675,"end":206160},"icon":"XCircle","label":"Type '\"default\" | \"outline\" | \"secondary\" | \"ghost\"' is not assignable to type '\"default\" | \"destructive\" | \"outline\" | \"secondary\" | \"lg\" | undefined'.\n  Type '\"ghost\"' is not assignable to type '\"default\" | \"destructive\" | \"outline\" | \"secondary\" | \"lg\" | undefined'.","metadata":null}]}